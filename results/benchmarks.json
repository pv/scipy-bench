{
    "blas_lapack.GetBlasLapackFuncs.time_find_best_blas_type": {
        "code": "class GetBlasLapackFuncs:\n    def time_find_best_blas_type(self, dtype1, dtype2, dtype1_ord, dtype2_ord, size):\n        prefix, dtype, prefer_fortran = bla.find_best_blas_type((self.arr1, self.arr2))\n\n    def setup(self, dtype1, dtype2, dtype1_ord, dtype2_ord, size):\n        self.arr1 = np.empty(size, dtype=dtype1, order=dtype1_ord)\n        self.arr2 = np.empty(size, dtype=dtype2, order=dtype2_ord)",
        "min_run_count": 2,
        "name": "blas_lapack.GetBlasLapackFuncs.time_find_best_blas_type",
        "number": 0,
        "param_names": [
            "dtype1",
            "dtype2",
            "dtype1_ord",
            "dtype2_ord",
            "size"
        ],
        "params": [
            [
                "'b'",
                "'G'",
                "'d'"
            ],
            [
                "'d'",
                "'F'",
                "'?'"
            ],
            [
                "'C'",
                "'F'"
            ],
            [
                "'C'",
                "'F'"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "693d25749534553dc3b95bf58b636610a499cd9a6a94d2b82421ebe862eb614c",
        "warmup_time": -1
    },
    "cluster.HierarchyLinkage.time_linkage": {
        "code": "class HierarchyLinkage:\n    def time_linkage(self, method):\n        linkage(self.X, method=method)",
        "min_run_count": 2,
        "name": "cluster.HierarchyLinkage.time_linkage",
        "number": 0,
        "param_names": [
            "method"
        ],
        "params": [
            [
                "'single'",
                "'complete'",
                "'average'",
                "'weighted'",
                "'centroid'",
                "'median'",
                "'ward'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "886a23bad5fa5a00c76656791c898c69a0805a80db466949f34edc28f9ce00bd",
        "warmup_time": -1
    },
    "cluster.KMeans.time_kmeans": {
        "code": "class KMeans:\n    def time_kmeans(self, k):\n        kmeans(self.obs, k, iter=10)",
        "min_run_count": 2,
        "name": "cluster.KMeans.time_kmeans",
        "number": 0,
        "param_names": [
            "k"
        ],
        "params": [
            [
                "2",
                "10",
                "50"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "62d888a0d1080159d649bb8fd1de0cfe8b8b1f892bbeeb7f60de3bf620d20ffb",
        "warmup_time": -1
    },
    "cluster.KMeans2.time_kmeans2": {
        "code": "class KMeans2:\n    def time_kmeans2(self, k, init):\n        with suppress_warnings() as sup:\n            sup.filter(UserWarning,\n                       \"One of the clusters is empty. Re-run kmeans with a \"\n                       \"different initialization\")\n            kmeans2(self.obs, k, minit=init, iter=10)",
        "min_run_count": 2,
        "name": "cluster.KMeans2.time_kmeans2",
        "number": 0,
        "param_names": [
            "k",
            "init"
        ],
        "params": [
            [
                "2",
                "10",
                "50"
            ],
            [
                "'random'",
                "'points'",
                "'++'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c31b9cbce459810759ed0885ce6ceb752574888dda15e6d1ca13e71eed225442",
        "warmup_time": -1
    },
    "cluster.VQ.time_vq": {
        "code": "class VQ:\n    def time_vq(self, k, dtype):\n        vq(self.obs, self.cbook)\n\n    def setup(self, k, dtype):\n        self.obs = self.data.astype(dtype)\n        self.cbook = self.cbook_source[:k].astype(dtype)",
        "min_run_count": 2,
        "name": "cluster.VQ.time_vq",
        "number": 0,
        "param_names": [
            "k",
            "dtype"
        ],
        "params": [
            [
                "2",
                "10",
                "50"
            ],
            [
                "'float32'",
                "'float64'",
                "'float128'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a8ef1a2c1ab11f03bd5a06903492b4472e58f2c62499acb3b715e3cf963ee3f0",
        "warmup_time": -1
    },
    "cluster_hierarchy_disjoint_set.Bench.time_absence": {
        "code": "class Bench:\n    def time_absence(self, n):\n        # Test for absence\n        assert None not in self.pre_merged\n        assert \"dummy\" not in self.pre_merged\n        assert (1, 2, 3) not in self.pre_merged\n\n    def setup(self, n):\n        # Create random edges\n        rng = np.random.RandomState(seed=0)\n        self.edges = rng.randint(0, 10 * n, (n, 2))\n        self.nodes = np.unique(self.edges)\n        self.disjoint_set = DisjointSet(self.nodes)\n    \n        self.pre_merged = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged.merge(a, b)\n    \n        self.pre_merged_found = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged_found.merge(a, b)\n        for x in self.nodes:\n            self.pre_merged_found[x]",
        "min_run_count": 2,
        "name": "cluster_hierarchy_disjoint_set.Bench.time_absence",
        "number": 0,
        "param_names": [
            "n"
        ],
        "params": [
            [
                "100",
                "1000",
                "10000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "28b77d7db34292d962c123ef1cfc01ff87126b979482d56aef240642d196c8e4",
        "warmup_time": -1
    },
    "cluster_hierarchy_disjoint_set.Bench.time_contains": {
        "code": "class Bench:\n    def time_contains(self, n):\n        assert self.nodes[0] in self.pre_merged\n        assert self.nodes[n // 2] in self.pre_merged\n        assert self.nodes[-1] in self.pre_merged\n\n    def setup(self, n):\n        # Create random edges\n        rng = np.random.RandomState(seed=0)\n        self.edges = rng.randint(0, 10 * n, (n, 2))\n        self.nodes = np.unique(self.edges)\n        self.disjoint_set = DisjointSet(self.nodes)\n    \n        self.pre_merged = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged.merge(a, b)\n    \n        self.pre_merged_found = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged_found.merge(a, b)\n        for x in self.nodes:\n            self.pre_merged_found[x]",
        "min_run_count": 2,
        "name": "cluster_hierarchy_disjoint_set.Bench.time_contains",
        "number": 0,
        "param_names": [
            "n"
        ],
        "params": [
            [
                "100",
                "1000",
                "10000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b35e5f755b032d3cb2a1cf191bdf1dc674ad043b89c743e962e9a4344dcd1e97",
        "warmup_time": -1
    },
    "cluster_hierarchy_disjoint_set.Bench.time_find": {
        "code": "class Bench:\n    def time_find(self, n):\n        dis = self.pre_merged\n        return [dis[i] for i in self.nodes]\n\n    def setup(self, n):\n        # Create random edges\n        rng = np.random.RandomState(seed=0)\n        self.edges = rng.randint(0, 10 * n, (n, 2))\n        self.nodes = np.unique(self.edges)\n        self.disjoint_set = DisjointSet(self.nodes)\n    \n        self.pre_merged = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged.merge(a, b)\n    \n        self.pre_merged_found = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged_found.merge(a, b)\n        for x in self.nodes:\n            self.pre_merged_found[x]",
        "min_run_count": 2,
        "name": "cluster_hierarchy_disjoint_set.Bench.time_find",
        "number": 0,
        "param_names": [
            "n"
        ],
        "params": [
            [
                "100",
                "1000",
                "10000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0b7d50b7f5f03f920bd0a0c639e0f085567971793b0e01c04dd9d8b06cf8154f",
        "warmup_time": -1
    },
    "cluster_hierarchy_disjoint_set.Bench.time_find_already_found": {
        "code": "class Bench:\n    def time_find_already_found(self, n):\n        dis = self.pre_merged_found\n        return [dis[i] for i in self.nodes]\n\n    def setup(self, n):\n        # Create random edges\n        rng = np.random.RandomState(seed=0)\n        self.edges = rng.randint(0, 10 * n, (n, 2))\n        self.nodes = np.unique(self.edges)\n        self.disjoint_set = DisjointSet(self.nodes)\n    \n        self.pre_merged = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged.merge(a, b)\n    \n        self.pre_merged_found = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged_found.merge(a, b)\n        for x in self.nodes:\n            self.pre_merged_found[x]",
        "min_run_count": 2,
        "name": "cluster_hierarchy_disjoint_set.Bench.time_find_already_found",
        "number": 0,
        "param_names": [
            "n"
        ],
        "params": [
            [
                "100",
                "1000",
                "10000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7cf68c47a2e5b1b2b5f778fbc00a35b5348a8fe044e78dad5e1da79805419a9c",
        "warmup_time": -1
    },
    "cluster_hierarchy_disjoint_set.Bench.time_merge": {
        "code": "class Bench:\n    def time_merge(self, n):\n        dis = self.disjoint_set\n        for a, b in self.edges:\n            dis.merge(a, b)\n\n    def setup(self, n):\n        # Create random edges\n        rng = np.random.RandomState(seed=0)\n        self.edges = rng.randint(0, 10 * n, (n, 2))\n        self.nodes = np.unique(self.edges)\n        self.disjoint_set = DisjointSet(self.nodes)\n    \n        self.pre_merged = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged.merge(a, b)\n    \n        self.pre_merged_found = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged_found.merge(a, b)\n        for x in self.nodes:\n            self.pre_merged_found[x]",
        "min_run_count": 2,
        "name": "cluster_hierarchy_disjoint_set.Bench.time_merge",
        "number": 0,
        "param_names": [
            "n"
        ],
        "params": [
            [
                "100",
                "1000",
                "10000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e0a88a142f3aa2da399f7d2559aee279f0ff574d9093d4e9b4e761af634a263d",
        "warmup_time": -1
    },
    "cluster_hierarchy_disjoint_set.Bench.time_merge_already_merged": {
        "code": "class Bench:\n    def time_merge_already_merged(self, n):\n        dis = self.pre_merged\n        for a, b in self.edges:\n            dis.merge(a, b)\n\n    def setup(self, n):\n        # Create random edges\n        rng = np.random.RandomState(seed=0)\n        self.edges = rng.randint(0, 10 * n, (n, 2))\n        self.nodes = np.unique(self.edges)\n        self.disjoint_set = DisjointSet(self.nodes)\n    \n        self.pre_merged = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged.merge(a, b)\n    \n        self.pre_merged_found = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged_found.merge(a, b)\n        for x in self.nodes:\n            self.pre_merged_found[x]",
        "min_run_count": 2,
        "name": "cluster_hierarchy_disjoint_set.Bench.time_merge_already_merged",
        "number": 0,
        "param_names": [
            "n"
        ],
        "params": [
            [
                "100",
                "1000",
                "10000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "da430f953ef308d98c79f6cdd545bb2f59f48de0317b62fcf43b35f8048d86f1",
        "warmup_time": -1
    },
    "cython_special.CythonSpecial.time_airy_D": {
        "code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)",
        "min_run_count": 2,
        "name": "cython_special.CythonSpecial.time_airy_D",
        "number": 0,
        "param_names": [
            "name",
            "argument",
            "N",
            "api"
        ],
        "params": [
            [
                "'airy_D'"
            ],
            [
                "(1,)"
            ],
            [
                "10",
                "100",
                "1000"
            ],
            [
                "'python'",
                "'numpy'",
                "'cython'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a",
        "warmup_time": -1
    },
    "cython_special.CythonSpecial.time_airy_d": {
        "code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)",
        "min_run_count": 2,
        "name": "cython_special.CythonSpecial.time_airy_d",
        "number": 0,
        "param_names": [
            "name",
            "argument",
            "N",
            "api"
        ],
        "params": [
            [
                "'airy_d'"
            ],
            [
                "(1,)"
            ],
            [
                "10",
                "100",
                "1000"
            ],
            [
                "'python'",
                "'numpy'",
                "'cython'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a",
        "warmup_time": -1
    },
    "cython_special.CythonSpecial.time_beta_dd": {
        "code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)",
        "min_run_count": 2,
        "name": "cython_special.CythonSpecial.time_beta_dd",
        "number": 0,
        "param_names": [
            "name",
            "argument",
            "N",
            "api"
        ],
        "params": [
            [
                "'beta_dd'"
            ],
            [
                "(0.25, 0.75)"
            ],
            [
                "10",
                "100",
                "1000"
            ],
            [
                "'python'",
                "'numpy'",
                "'cython'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a",
        "warmup_time": -1
    },
    "cython_special.CythonSpecial.time_erf_D": {
        "code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)",
        "min_run_count": 2,
        "name": "cython_special.CythonSpecial.time_erf_D",
        "number": 0,
        "param_names": [
            "name",
            "argument",
            "N",
            "api"
        ],
        "params": [
            [
                "'erf_D'"
            ],
            [
                "((1+1j),)"
            ],
            [
                "10",
                "100",
                "1000"
            ],
            [
                "'python'",
                "'numpy'",
                "'cython'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a",
        "warmup_time": -1
    },
    "cython_special.CythonSpecial.time_erf_d": {
        "code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)",
        "min_run_count": 2,
        "name": "cython_special.CythonSpecial.time_erf_d",
        "number": 0,
        "param_names": [
            "name",
            "argument",
            "N",
            "api"
        ],
        "params": [
            [
                "'erf_d'"
            ],
            [
                "(1,)"
            ],
            [
                "10",
                "100",
                "1000"
            ],
            [
                "'python'",
                "'numpy'",
                "'cython'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a",
        "warmup_time": -1
    },
    "cython_special.CythonSpecial.time_exprel_d": {
        "code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)",
        "min_run_count": 2,
        "name": "cython_special.CythonSpecial.time_exprel_d",
        "number": 0,
        "param_names": [
            "name",
            "argument",
            "N",
            "api"
        ],
        "params": [
            [
                "'exprel_d'"
            ],
            [
                "(1e-06,)"
            ],
            [
                "10",
                "100",
                "1000"
            ],
            [
                "'python'",
                "'numpy'",
                "'cython'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a",
        "warmup_time": -1
    },
    "cython_special.CythonSpecial.time_gamma_D": {
        "code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)",
        "min_run_count": 2,
        "name": "cython_special.CythonSpecial.time_gamma_D",
        "number": 0,
        "param_names": [
            "name",
            "argument",
            "N",
            "api"
        ],
        "params": [
            [
                "'gamma_D'"
            ],
            [
                "((100+100j),)"
            ],
            [
                "10",
                "100",
                "1000"
            ],
            [
                "'python'",
                "'numpy'",
                "'cython'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a",
        "warmup_time": -1
    },
    "cython_special.CythonSpecial.time_gamma_d": {
        "code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)",
        "min_run_count": 2,
        "name": "cython_special.CythonSpecial.time_gamma_d",
        "number": 0,
        "param_names": [
            "name",
            "argument",
            "N",
            "api"
        ],
        "params": [
            [
                "'gamma_d'"
            ],
            [
                "(100,)"
            ],
            [
                "10",
                "100",
                "1000"
            ],
            [
                "'python'",
                "'numpy'",
                "'cython'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a",
        "warmup_time": -1
    },
    "cython_special.CythonSpecial.time_jv_dD": {
        "code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)",
        "min_run_count": 2,
        "name": "cython_special.CythonSpecial.time_jv_dD",
        "number": 0,
        "param_names": [
            "name",
            "argument",
            "N",
            "api"
        ],
        "params": [
            [
                "'jv_dD'"
            ],
            [
                "(1, (1+1j))"
            ],
            [
                "10",
                "100",
                "1000"
            ],
            [
                "'python'",
                "'numpy'",
                "'cython'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a",
        "warmup_time": -1
    },
    "cython_special.CythonSpecial.time_jv_dd": {
        "code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)",
        "min_run_count": 2,
        "name": "cython_special.CythonSpecial.time_jv_dd",
        "number": 0,
        "param_names": [
            "name",
            "argument",
            "N",
            "api"
        ],
        "params": [
            [
                "'jv_dd'"
            ],
            [
                "(1, 1)"
            ],
            [
                "10",
                "100",
                "1000"
            ],
            [
                "'python'",
                "'numpy'",
                "'cython'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a",
        "warmup_time": -1
    },
    "cython_special.CythonSpecial.time_loggamma_D": {
        "code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)",
        "min_run_count": 2,
        "name": "cython_special.CythonSpecial.time_loggamma_D",
        "number": 0,
        "param_names": [
            "name",
            "argument",
            "N",
            "api"
        ],
        "params": [
            [
                "'loggamma_D'"
            ],
            [
                "(20,)"
            ],
            [
                "10",
                "100",
                "1000"
            ],
            [
                "'python'",
                "'numpy'",
                "'cython'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a",
        "warmup_time": -1
    },
    "cython_special.CythonSpecial.time_logit_d": {
        "code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)",
        "min_run_count": 2,
        "name": "cython_special.CythonSpecial.time_logit_d",
        "number": 0,
        "param_names": [
            "name",
            "argument",
            "N",
            "api"
        ],
        "params": [
            [
                "'logit_d'"
            ],
            [
                "(0.5,)"
            ],
            [
                "10",
                "100",
                "1000"
            ],
            [
                "'python'",
                "'numpy'",
                "'cython'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a",
        "warmup_time": -1
    },
    "cython_special.CythonSpecial.time_psi_D": {
        "code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)",
        "min_run_count": 2,
        "name": "cython_special.CythonSpecial.time_psi_D",
        "number": 0,
        "param_names": [
            "name",
            "argument",
            "N",
            "api"
        ],
        "params": [
            [
                "'psi_D'"
            ],
            [
                "(1,)"
            ],
            [
                "10",
                "100",
                "1000"
            ],
            [
                "'python'",
                "'numpy'",
                "'cython'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a",
        "warmup_time": -1
    },
    "cython_special.CythonSpecial.time_psi_d": {
        "code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)",
        "min_run_count": 2,
        "name": "cython_special.CythonSpecial.time_psi_d",
        "number": 0,
        "param_names": [
            "name",
            "argument",
            "N",
            "api"
        ],
        "params": [
            [
                "'psi_d'"
            ],
            [
                "(1,)"
            ],
            [
                "10",
                "100",
                "1000"
            ],
            [
                "'python'",
                "'numpy'",
                "'cython'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a",
        "warmup_time": -1
    },
    "fft_basic.Fft.time_fft": {
        "code": "class Fft:\n    def time_fft(self, size, cmplx, module):\n        self.fft(self.x)\n\n    def setup(self, size, cmplx, module):\n        if cmplx == 'cmplx':\n            self.x = random([size]).astype(cdouble)+random([size]).astype(cdouble)*1j\n        else:\n            self.x = random([size]).astype(double)\n    \n        module = get_module(module)\n        self.fft = getattr(module, 'fft')\n        self.ifft = getattr(module, 'ifft')",
        "min_run_count": 2,
        "name": "fft_basic.Fft.time_fft",
        "number": 0,
        "param_names": [
            "size",
            "type",
            "module"
        ],
        "params": [
            [
                "100",
                "256",
                "313",
                "512",
                "1000",
                "1024",
                "2048",
                "4096",
                "8192"
            ],
            [
                "'real'",
                "'cmplx'"
            ],
            [
                "'scipy.fftpack'",
                "'scipy.fft'",
                "'numpy.fft'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "43cb7e1c276afa37a216c3345642bc059de8fafd391c29d9ce2f34b0af1332f6",
        "warmup_time": -1
    },
    "fft_basic.Fft.time_ifft": {
        "code": "class Fft:\n    def time_ifft(self, size, cmplx, module):\n        self.ifft(self.x)\n\n    def setup(self, size, cmplx, module):\n        if cmplx == 'cmplx':\n            self.x = random([size]).astype(cdouble)+random([size]).astype(cdouble)*1j\n        else:\n            self.x = random([size]).astype(double)\n    \n        module = get_module(module)\n        self.fft = getattr(module, 'fft')\n        self.ifft = getattr(module, 'ifft')",
        "min_run_count": 2,
        "name": "fft_basic.Fft.time_ifft",
        "number": 0,
        "param_names": [
            "size",
            "type",
            "module"
        ],
        "params": [
            [
                "100",
                "256",
                "313",
                "512",
                "1000",
                "1024",
                "2048",
                "4096",
                "8192"
            ],
            [
                "'real'",
                "'cmplx'"
            ],
            [
                "'scipy.fftpack'",
                "'scipy.fft'",
                "'numpy.fft'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6b3dba7555699a7fcf10bdb4931781eb9e1287ac48a696e92444f357d1205ff9",
        "warmup_time": -1
    },
    "fft_basic.FftBackends.time_fft": {
        "code": "class FftBackends:\n    def time_fft(self, size, cmplx, module):\n        self.fft(self.x)\n\n    def setup(self, size, cmplx, backend):\n        import scipy.fft\n        if cmplx == 'cmplx':\n            self.x = random([size]).astype(cdouble)+random([size]).astype(cdouble)*1j\n        else:\n            self.x = random([size]).astype(double)\n    \n        self.fft = scipy.fft.fft\n        self.ifft = scipy.fft.ifft\n    \n        if backend == 'pocketfft':\n            scipy.fft.set_global_backend('scipy')\n        elif backend == 'pyfftw':\n            if not has_pyfftw:\n                raise NotImplementedError\n            scipy.fft.set_global_backend(PyfftwBackend)\n        elif backend == 'numpy':\n            from scipy.fft._debug_backends import NumPyBackend\n            scipy.fft.set_global_backend(NumPyBackend)\n        elif backend == 'direct':\n            import scipy.fft._pocketfft\n            self.fft = scipy.fft._pocketfft.fft\n            self.ifft = scipy.fft._pocketfft.ifft",
        "min_run_count": 2,
        "name": "fft_basic.FftBackends.time_fft",
        "number": 0,
        "param_names": [
            "size",
            "type",
            "backend"
        ],
        "params": [
            [
                "100",
                "256",
                "313",
                "512",
                "1000",
                "1024",
                "2048",
                "4096",
                "8192"
            ],
            [
                "'real'",
                "'cmplx'"
            ],
            [
                "'pocketfft'",
                "'pyfftw'",
                "'numpy'",
                "'direct'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "fa985c0626675fcf7e506c6ba5ba852eb496adffc8ea0d6c70930b032eb10f20",
        "warmup_time": -1
    },
    "fft_basic.FftBackends.time_ifft": {
        "code": "class FftBackends:\n    def time_ifft(self, size, cmplx, module):\n        self.ifft(self.x)\n\n    def setup(self, size, cmplx, backend):\n        import scipy.fft\n        if cmplx == 'cmplx':\n            self.x = random([size]).astype(cdouble)+random([size]).astype(cdouble)*1j\n        else:\n            self.x = random([size]).astype(double)\n    \n        self.fft = scipy.fft.fft\n        self.ifft = scipy.fft.ifft\n    \n        if backend == 'pocketfft':\n            scipy.fft.set_global_backend('scipy')\n        elif backend == 'pyfftw':\n            if not has_pyfftw:\n                raise NotImplementedError\n            scipy.fft.set_global_backend(PyfftwBackend)\n        elif backend == 'numpy':\n            from scipy.fft._debug_backends import NumPyBackend\n            scipy.fft.set_global_backend(NumPyBackend)\n        elif backend == 'direct':\n            import scipy.fft._pocketfft\n            self.fft = scipy.fft._pocketfft.fft\n            self.ifft = scipy.fft._pocketfft.ifft",
        "min_run_count": 2,
        "name": "fft_basic.FftBackends.time_ifft",
        "number": 0,
        "param_names": [
            "size",
            "type",
            "backend"
        ],
        "params": [
            [
                "100",
                "256",
                "313",
                "512",
                "1000",
                "1024",
                "2048",
                "4096",
                "8192"
            ],
            [
                "'real'",
                "'cmplx'"
            ],
            [
                "'pocketfft'",
                "'pyfftw'",
                "'numpy'",
                "'direct'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4b34c6676e64ef332e08a23bd92f95efa2d2ef52fc44daa807082886eef87762",
        "warmup_time": -1
    },
    "fft_basic.FftThreading.time_fft": {
        "code": "class FftThreading:\n    def time_fft(self, size, num_transforms, method):\n        if method == 'threading':\n            self.map_thread(scipy_fft.fft)\n        else:\n            for x in self.xs:\n                scipy_fft.fft(x, workers=-1)\n\n    def setup(self, size, num_transforms, method):\n        if not has_scipy_fft:\n            raise NotImplementedError\n    \n        size = list(map(int, size.split(\"x\")))\n        self.xs = [(random(size)+1j*random(size)).astype(np.complex128)\n                   for _ in range(num_transforms)]\n    \n        if method == 'threading':\n            self.pool = futures.ThreadPoolExecutor(os.cpu_count())",
        "min_run_count": 2,
        "name": "fft_basic.FftThreading.time_fft",
        "number": 0,
        "param_names": [
            "size",
            "num_transforms",
            "method"
        ],
        "params": [
            [
                "'100x100'",
                "'1000x100'",
                "'256x256'",
                "'512x512'"
            ],
            [
                "1",
                "8",
                "32",
                "100"
            ],
            [
                "'workers'",
                "'threading'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "01c8d4ac7176096dd9169b1dccba311314ba689f6994d8c2aca0b8875797185e",
        "warmup_time": -1
    },
    "fft_basic.FftThreading.time_fftn": {
        "code": "class FftThreading:\n    def time_fftn(self, size, num_transforms, method):\n        if method == 'threading':\n            self.map_thread(scipy_fft.fftn)\n        else:\n            for x in self.xs:\n                scipy_fft.fftn(x, workers=-1)\n\n    def setup(self, size, num_transforms, method):\n        if not has_scipy_fft:\n            raise NotImplementedError\n    \n        size = list(map(int, size.split(\"x\")))\n        self.xs = [(random(size)+1j*random(size)).astype(np.complex128)\n                   for _ in range(num_transforms)]\n    \n        if method == 'threading':\n            self.pool = futures.ThreadPoolExecutor(os.cpu_count())",
        "min_run_count": 2,
        "name": "fft_basic.FftThreading.time_fftn",
        "number": 0,
        "param_names": [
            "size",
            "num_transforms",
            "method"
        ],
        "params": [
            [
                "'100x100'",
                "'1000x100'",
                "'256x256'",
                "'512x512'"
            ],
            [
                "1",
                "8",
                "32",
                "100"
            ],
            [
                "'workers'",
                "'threading'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5776b5cd181dfaec02e289c6719a8854727ad9c851142440c3a2935d97b5b50c",
        "warmup_time": -1
    },
    "fft_basic.Fftn.time_fftn": {
        "code": "class Fftn:\n    def time_fftn(self, size, cmplx, module):\n        self.fftn(self.x)\n\n    def setup(self, size, cmplx, module):\n        size = list(map(int, size.split(\"x\")))\n    \n        if cmplx != 'cmplx':\n            self.x = random(size).astype(double)\n        else:\n            self.x = random(size).astype(cdouble)+random(size).astype(cdouble)*1j\n    \n        self.fftn = getattr(get_module(module), 'fftn')",
        "min_run_count": 2,
        "name": "fft_basic.Fftn.time_fftn",
        "number": 0,
        "param_names": [
            "size",
            "type",
            "module"
        ],
        "params": [
            [
                "'100x100'",
                "'313x100'",
                "'1000x100'",
                "'256x256'",
                "'512x512'"
            ],
            [
                "'real'",
                "'cmplx'"
            ],
            [
                "'scipy.fftpack'",
                "'scipy.fft'",
                "'numpy.fft'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "46c3c6117d2afa7ff988d4b2a228967a6311e8a9240d1d4421b4c4676f1dedda",
        "warmup_time": -1
    },
    "fft_basic.FftnBackends.time_fft": {
        "code": "class FftnBackends:\n    def time_fft(self, size, cmplx, module):\n        self.fftn(self.x)\n\n    def setup(self, size, cmplx, backend):\n        import scipy.fft\n        size = list(map(int, size.split(\"x\")))\n    \n        if cmplx == 'cmplx':\n            self.x = random(size).astype(double)+random(size).astype(double)*1j\n        else:\n            self.x = random(size).astype(double)\n    \n        self.fftn = scipy.fft.fftn\n        self.ifftn = scipy.fft.ifftn\n    \n        if backend == 'pocketfft':\n            scipy.fft.set_global_backend('scipy')\n        elif backend == 'pyfftw':\n            if not has_pyfftw:\n                raise NotImplementedError\n            scipy.fft.set_global_backend(PyfftwBackend)\n        elif backend == 'numpy':\n            from scipy.fft._debug_backends import NumPyBackend\n            scipy.fft.set_global_backend(NumPyBackend)\n        elif backend == 'direct':\n            import scipy.fft._pocketfft\n            self.fftn = scipy.fft._pocketfft.fftn\n            self.ifftn = scipy.fft._pocketfft.ifftn",
        "min_run_count": 2,
        "name": "fft_basic.FftnBackends.time_fft",
        "number": 0,
        "param_names": [
            "size",
            "type",
            "backend"
        ],
        "params": [
            [
                "'100x100'",
                "'313x100'",
                "'1000x100'",
                "'256x256'",
                "'512x512'"
            ],
            [
                "'real'",
                "'cmplx'"
            ],
            [
                "'pocketfft'",
                "'pyfftw'",
                "'numpy'",
                "'direct'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9210ea7955292189368628dd908c18ac7c03d1c51e0dc4385830514319fbd98e",
        "warmup_time": -1
    },
    "fft_basic.FftnBackends.time_ifft": {
        "code": "class FftnBackends:\n    def time_ifft(self, size, cmplx, module):\n        self.ifftn(self.x)\n\n    def setup(self, size, cmplx, backend):\n        import scipy.fft\n        size = list(map(int, size.split(\"x\")))\n    \n        if cmplx == 'cmplx':\n            self.x = random(size).astype(double)+random(size).astype(double)*1j\n        else:\n            self.x = random(size).astype(double)\n    \n        self.fftn = scipy.fft.fftn\n        self.ifftn = scipy.fft.ifftn\n    \n        if backend == 'pocketfft':\n            scipy.fft.set_global_backend('scipy')\n        elif backend == 'pyfftw':\n            if not has_pyfftw:\n                raise NotImplementedError\n            scipy.fft.set_global_backend(PyfftwBackend)\n        elif backend == 'numpy':\n            from scipy.fft._debug_backends import NumPyBackend\n            scipy.fft.set_global_backend(NumPyBackend)\n        elif backend == 'direct':\n            import scipy.fft._pocketfft\n            self.fftn = scipy.fft._pocketfft.fftn\n            self.ifftn = scipy.fft._pocketfft.ifftn",
        "min_run_count": 2,
        "name": "fft_basic.FftnBackends.time_ifft",
        "number": 0,
        "param_names": [
            "size",
            "type",
            "backend"
        ],
        "params": [
            [
                "'100x100'",
                "'313x100'",
                "'1000x100'",
                "'256x256'",
                "'512x512'"
            ],
            [
                "'real'",
                "'cmplx'"
            ],
            [
                "'pocketfft'",
                "'pyfftw'",
                "'numpy'",
                "'direct'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b24b074608dd3bbe10b7dd28d42a003392711954883f8f5ab7a770653a5f252e",
        "warmup_time": -1
    },
    "fft_basic.NextFastLen.time_next_fast_len": {
        "code": "class NextFastLen:\n    def time_next_fast_len(self, size):\n        scipy_fft.next_fast_len.__wrapped__(size)\n\n    def setup(self, size):\n        if not has_scipy_fft:\n            raise NotImplementedError",
        "min_run_count": 2,
        "name": "fft_basic.NextFastLen.time_next_fast_len",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "12",
                "13",
                "1021",
                "1024",
                "16381",
                "16384",
                "262139",
                "262144",
                "999983",
                "1048576"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "67af4eb88556ff515fed9299578487d0a1b461fa77f61813319ecd11aba1d4cd",
        "warmup_time": -1
    },
    "fft_basic.NextFastLen.time_next_fast_len_cached": {
        "code": "class NextFastLen:\n    def time_next_fast_len_cached(self, size):\n        scipy_fft.next_fast_len(size)\n\n    def setup(self, size):\n        if not has_scipy_fft:\n            raise NotImplementedError",
        "min_run_count": 2,
        "name": "fft_basic.NextFastLen.time_next_fast_len_cached",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "12",
                "13",
                "1021",
                "1024",
                "16381",
                "16384",
                "262139",
                "262144",
                "999983",
                "1048576"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ce847bc3ab55322c9e7a0c167a71a368e987e504a4cfc9a7f5489e51e9ce45cf",
        "warmup_time": -1
    },
    "fft_basic.RFft.time_irfft": {
        "code": "class RFft:\n    def time_irfft(self, size, module):\n        self.irfft(self.y)\n\n    def setup(self, size, module):\n        self.x = random([size]).astype(double)\n    \n        module = get_module(module)\n        self.rfft = getattr(module, 'rfft')\n        self.irfft = getattr(module, 'irfft')\n    \n        self.y = self.rfft(self.x)",
        "min_run_count": 2,
        "name": "fft_basic.RFft.time_irfft",
        "number": 0,
        "param_names": [
            "size",
            "module"
        ],
        "params": [
            [
                "100",
                "256",
                "313",
                "512",
                "1000",
                "1024",
                "2048",
                "4096",
                "8192"
            ],
            [
                "'scipy.fftpack'",
                "'scipy.fft'",
                "'numpy.fft'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b29b8d884549ae838535aa610c255789236a95b97f0c33189871a8063f697fde",
        "warmup_time": -1
    },
    "fft_basic.RFft.time_rfft": {
        "code": "class RFft:\n    def time_rfft(self, size, module):\n        self.rfft(self.x)\n\n    def setup(self, size, module):\n        self.x = random([size]).astype(double)\n    \n        module = get_module(module)\n        self.rfft = getattr(module, 'rfft')\n        self.irfft = getattr(module, 'irfft')\n    \n        self.y = self.rfft(self.x)",
        "min_run_count": 2,
        "name": "fft_basic.RFft.time_rfft",
        "number": 0,
        "param_names": [
            "size",
            "module"
        ],
        "params": [
            [
                "100",
                "256",
                "313",
                "512",
                "1000",
                "1024",
                "2048",
                "4096",
                "8192"
            ],
            [
                "'scipy.fftpack'",
                "'scipy.fft'",
                "'numpy.fft'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "addbbfc97a7f43a5b3d08b5f48fc1fbfeaa0bbfb7d29833234666c1add1279a3",
        "warmup_time": -1
    },
    "fft_basic.RealTransforms1D.time_dct": {
        "code": "class RealTransforms1D:\n    def time_dct(self, size, type, module):\n        self.dct(self.x, self.type)\n\n    def setup(self, size, type, module):\n        module = get_module(module)\n        self.dct = getattr(module, 'dct')\n        self.dst = getattr(module, 'dst')\n        self.type = {'I':1, 'II':2, 'III':3, 'IV':4}[type]\n    \n        # The \"logical\" transform size should be smooth, which for dct/dst\n        # type 1 is offset by -1/+1 respectively\n    \n        if self.type == 1:\n            size += 1\n    \n        self.x = random([size]).astype(double)\n    \n        if self.type == 1:\n            self.x_dst = self.x[:-2].copy()",
        "min_run_count": 2,
        "name": "fft_basic.RealTransforms1D.time_dct",
        "number": 0,
        "param_names": [
            "size",
            "type",
            "module"
        ],
        "params": [
            [
                "75",
                "100",
                "135",
                "256",
                "313",
                "512",
                "675",
                "1024",
                "2025",
                "2048"
            ],
            [
                "'I'",
                "'II'",
                "'III'",
                "'IV'"
            ],
            [
                "'scipy.fftpack'",
                "'scipy.fft'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e3497bca3bb059fd894674a9e02f6fe8bdd409e765011df69339b96bc5079627",
        "warmup_time": -1
    },
    "fft_basic.RealTransforms1D.time_dst": {
        "code": "class RealTransforms1D:\n    def time_dst(self, size, type, module):\n        x = self.x if self.type != 1 else self.x_dst\n        self.dst(x, self.type)\n\n    def setup(self, size, type, module):\n        module = get_module(module)\n        self.dct = getattr(module, 'dct')\n        self.dst = getattr(module, 'dst')\n        self.type = {'I':1, 'II':2, 'III':3, 'IV':4}[type]\n    \n        # The \"logical\" transform size should be smooth, which for dct/dst\n        # type 1 is offset by -1/+1 respectively\n    \n        if self.type == 1:\n            size += 1\n    \n        self.x = random([size]).astype(double)\n    \n        if self.type == 1:\n            self.x_dst = self.x[:-2].copy()",
        "min_run_count": 2,
        "name": "fft_basic.RealTransforms1D.time_dst",
        "number": 0,
        "param_names": [
            "size",
            "type",
            "module"
        ],
        "params": [
            [
                "75",
                "100",
                "135",
                "256",
                "313",
                "512",
                "675",
                "1024",
                "2025",
                "2048"
            ],
            [
                "'I'",
                "'II'",
                "'III'",
                "'IV'"
            ],
            [
                "'scipy.fftpack'",
                "'scipy.fft'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ad275b349d0c19daf585e2327fbaf421b498839a302391bb20a64ba5491ade91",
        "warmup_time": -1
    },
    "fft_basic.RealTransformsND.time_dctn": {
        "code": "class RealTransformsND:\n    def time_dctn(self, size, type, module):\n        self.dctn(self.x, self.type)\n\n    def setup(self, size, type, module):\n        self.dctn = getattr(get_module(module), 'dctn')\n        self.dstn = getattr(get_module(module), 'dstn')\n        self.type = {'I':1, 'II':2, 'III':3, 'IV':4}[type]\n    \n        # The \"logical\" transform size should be smooth, which for dct/dst\n        # type 1 is offset by -1/+1 respectively\n    \n        size = list(map(int, size.split('x')))\n        if self.type == 1:\n            size = (s + 1 for s in size)\n    \n        self.x = random(size).astype(double)\n        if self.type == 1:\n            self.x_dst = self.x[:-2,:-2].copy()",
        "min_run_count": 2,
        "name": "fft_basic.RealTransformsND.time_dctn",
        "number": 0,
        "param_names": [
            "size",
            "type",
            "module"
        ],
        "params": [
            [
                "'75x75'",
                "'100x100'",
                "'135x135'",
                "'313x363'",
                "'1000x100'",
                "'256x256'"
            ],
            [
                "'I'",
                "'II'",
                "'III'",
                "'IV'"
            ],
            [
                "'scipy.fftpack'",
                "'scipy.fft'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7ccc290bcc48df1765899eeebf91721e5ac2b3098c5caf5e11381d29ad90c55f",
        "warmup_time": -1
    },
    "fft_basic.RealTransformsND.time_dstn": {
        "code": "class RealTransformsND:\n    def time_dstn(self, size, type, module):\n        x = self.x if self.type != 1 else self.x_dst\n        self.dstn(x, self.type)\n\n    def setup(self, size, type, module):\n        self.dctn = getattr(get_module(module), 'dctn')\n        self.dstn = getattr(get_module(module), 'dstn')\n        self.type = {'I':1, 'II':2, 'III':3, 'IV':4}[type]\n    \n        # The \"logical\" transform size should be smooth, which for dct/dst\n        # type 1 is offset by -1/+1 respectively\n    \n        size = list(map(int, size.split('x')))\n        if self.type == 1:\n            size = (s + 1 for s in size)\n    \n        self.x = random(size).astype(double)\n        if self.type == 1:\n            self.x_dst = self.x[:-2,:-2].copy()",
        "min_run_count": 2,
        "name": "fft_basic.RealTransformsND.time_dstn",
        "number": 0,
        "param_names": [
            "size",
            "type",
            "module"
        ],
        "params": [
            [
                "'75x75'",
                "'100x100'",
                "'135x135'",
                "'313x363'",
                "'1000x100'",
                "'256x256'"
            ],
            [
                "'I'",
                "'II'",
                "'III'",
                "'IV'"
            ],
            [
                "'scipy.fftpack'",
                "'scipy.fft'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0b77ec9d87bc2e7d48b9f235ad180970366b029e160f798bd56e6835a8ab3624",
        "warmup_time": -1
    },
    "fftpack_pseudo_diffs.Bench.time_diff": {
        "code": "class Bench:\n    def time_diff(self, size, soltype):\n        if soltype == 'fft':\n            diff(self.f, 3)\n        else:\n            direct_diff(self.f, 3)\n\n    def setup(self, size, type):\n        size = int(size)\n    \n        x = arange(size)*2*pi/size\n        a = 1\n        self.a = a\n        if size < 2000:\n            self.f = sin(x)*cos(4*x)+exp(sin(3*x))\n            self.sf = sin(x+a)*cos(4*(x+a))+exp(sin(3*(x+a)))\n        else:\n            self.f = sin(x)*cos(4*x)\n            self.sf = sin(x+a)*cos(4*(x+a))",
        "min_run_count": 2,
        "name": "fftpack_pseudo_diffs.Bench.time_diff",
        "number": 0,
        "param_names": [
            "size",
            "type"
        ],
        "params": [
            [
                "100",
                "256",
                "512",
                "1000",
                "1024",
                "2048",
                "4096",
                "8192"
            ],
            [
                "'fft'",
                "'direct'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ecbb51be15a54011afaf7419e4de58bf02949a7abc534276a2a18849eef9985d",
        "warmup_time": -1
    },
    "fftpack_pseudo_diffs.Bench.time_hilbert": {
        "code": "class Bench:\n    def time_hilbert(self, size, soltype):\n        if soltype == 'fft':\n            hilbert(self.f)\n        else:\n            direct_hilbert(self.f)\n\n    def setup(self, size, type):\n        size = int(size)\n    \n        x = arange(size)*2*pi/size\n        a = 1\n        self.a = a\n        if size < 2000:\n            self.f = sin(x)*cos(4*x)+exp(sin(3*x))\n            self.sf = sin(x+a)*cos(4*(x+a))+exp(sin(3*(x+a)))\n        else:\n            self.f = sin(x)*cos(4*x)\n            self.sf = sin(x+a)*cos(4*(x+a))",
        "min_run_count": 2,
        "name": "fftpack_pseudo_diffs.Bench.time_hilbert",
        "number": 0,
        "param_names": [
            "size",
            "type"
        ],
        "params": [
            [
                "100",
                "256",
                "512",
                "1000",
                "1024",
                "2048",
                "4096",
                "8192"
            ],
            [
                "'fft'",
                "'direct'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8b3864453f4e979dcd4238fbebaaa50967556fc1ad60bcd23efb503a899b40d5",
        "warmup_time": -1
    },
    "fftpack_pseudo_diffs.Bench.time_shift": {
        "code": "class Bench:\n    def time_shift(self, size, soltype):\n        if soltype == 'fft':\n            shift(self.f, self.a)\n        else:\n            direct_shift(self.f, self.a)\n\n    def setup(self, size, type):\n        size = int(size)\n    \n        x = arange(size)*2*pi/size\n        a = 1\n        self.a = a\n        if size < 2000:\n            self.f = sin(x)*cos(4*x)+exp(sin(3*x))\n            self.sf = sin(x+a)*cos(4*(x+a))+exp(sin(3*(x+a)))\n        else:\n            self.f = sin(x)*cos(4*x)\n            self.sf = sin(x+a)*cos(4*(x+a))",
        "min_run_count": 2,
        "name": "fftpack_pseudo_diffs.Bench.time_shift",
        "number": 0,
        "param_names": [
            "size",
            "type"
        ],
        "params": [
            [
                "100",
                "256",
                "512",
                "1000",
                "1024",
                "2048",
                "4096",
                "8192"
            ],
            [
                "'fft'",
                "'direct'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4af1e866705c2b2da21bb261c884019e967221fc2e7a27937a0fa09e012bb221",
        "warmup_time": -1
    },
    "fftpack_pseudo_diffs.Bench.time_tilbert": {
        "code": "class Bench:\n    def time_tilbert(self, size, soltype):\n        if soltype == 'fft':\n            tilbert(self.f, 1)\n        else:\n            direct_tilbert(self.f, 1)\n\n    def setup(self, size, type):\n        size = int(size)\n    \n        x = arange(size)*2*pi/size\n        a = 1\n        self.a = a\n        if size < 2000:\n            self.f = sin(x)*cos(4*x)+exp(sin(3*x))\n            self.sf = sin(x+a)*cos(4*(x+a))+exp(sin(3*(x+a)))\n        else:\n            self.f = sin(x)*cos(4*x)\n            self.sf = sin(x+a)*cos(4*(x+a))",
        "min_run_count": 2,
        "name": "fftpack_pseudo_diffs.Bench.time_tilbert",
        "number": 0,
        "param_names": [
            "size",
            "type"
        ],
        "params": [
            [
                "100",
                "256",
                "512",
                "1000",
                "1024",
                "2048",
                "4096",
                "8192"
            ],
            [
                "'fft'",
                "'direct'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9c700f861e3acd4a87c8e6abbd4fc60967a0ab446c25ea480db726774354ffa4",
        "warmup_time": -1
    },
    "integrate.Quad.time_quad_cffi": {
        "code": "class Quad:\n    def time_quad_cffi(self):\n        quad(self.f_cffi, 0, np.pi)\n\n    def setup(self):\n        from math import sin\n    \n        self.f_python = lambda x: sin(x)\n        self.f_cython = from_cython(_ccallback_c, \"sine\")\n    \n        try:\n            from scipy.integrate.tests.test_quadpack import get_clib_test_routine\n            self.f_ctypes = get_clib_test_routine('_multivariate_sin', ctypes.c_double,\n                                                  ctypes.c_int, ctypes.c_double)\n        except ImportError:\n            lib = ctypes.CDLL(clib_test.__file__)\n            self.f_ctypes = lib._multivariate_sin\n            self.f_ctypes.restype = ctypes.c_double\n            self.f_ctypes.argtypes = (ctypes.c_int, ctypes.c_double)\n    \n        if cffi is not None:\n            voidp = ctypes.cast(self.f_ctypes, ctypes.c_void_p)\n            address = voidp.value\n            ffi = cffi.FFI()\n            self.f_cffi = LowLevelCallable(ffi.cast(\"double (*)(int, double *)\", address))",
        "min_run_count": 2,
        "name": "integrate.Quad.time_quad_cffi",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "47cc43352473cb8f1672bd55e600d8f6c35e86f47588ed3f313de0bc21837b42",
        "warmup_time": -1
    },
    "integrate.Quad.time_quad_ctypes": {
        "code": "class Quad:\n    def time_quad_ctypes(self):\n        quad(self.f_ctypes, 0, np.pi)\n\n    def setup(self):\n        from math import sin\n    \n        self.f_python = lambda x: sin(x)\n        self.f_cython = from_cython(_ccallback_c, \"sine\")\n    \n        try:\n            from scipy.integrate.tests.test_quadpack import get_clib_test_routine\n            self.f_ctypes = get_clib_test_routine('_multivariate_sin', ctypes.c_double,\n                                                  ctypes.c_int, ctypes.c_double)\n        except ImportError:\n            lib = ctypes.CDLL(clib_test.__file__)\n            self.f_ctypes = lib._multivariate_sin\n            self.f_ctypes.restype = ctypes.c_double\n            self.f_ctypes.argtypes = (ctypes.c_int, ctypes.c_double)\n    \n        if cffi is not None:\n            voidp = ctypes.cast(self.f_ctypes, ctypes.c_void_p)\n            address = voidp.value\n            ffi = cffi.FFI()\n            self.f_cffi = LowLevelCallable(ffi.cast(\"double (*)(int, double *)\", address))",
        "min_run_count": 2,
        "name": "integrate.Quad.time_quad_ctypes",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "70cf2fdf9febf32a4e1c220cdba552e3ea5a0dbc48265a355956071d97a30d30",
        "warmup_time": -1
    },
    "integrate.Quad.time_quad_cython": {
        "code": "class Quad:\n    def time_quad_cython(self):\n        quad(self.f_cython, 0, np.pi)\n\n    def setup(self):\n        from math import sin\n    \n        self.f_python = lambda x: sin(x)\n        self.f_cython = from_cython(_ccallback_c, \"sine\")\n    \n        try:\n            from scipy.integrate.tests.test_quadpack import get_clib_test_routine\n            self.f_ctypes = get_clib_test_routine('_multivariate_sin', ctypes.c_double,\n                                                  ctypes.c_int, ctypes.c_double)\n        except ImportError:\n            lib = ctypes.CDLL(clib_test.__file__)\n            self.f_ctypes = lib._multivariate_sin\n            self.f_ctypes.restype = ctypes.c_double\n            self.f_ctypes.argtypes = (ctypes.c_int, ctypes.c_double)\n    \n        if cffi is not None:\n            voidp = ctypes.cast(self.f_ctypes, ctypes.c_void_p)\n            address = voidp.value\n            ffi = cffi.FFI()\n            self.f_cffi = LowLevelCallable(ffi.cast(\"double (*)(int, double *)\", address))",
        "min_run_count": 2,
        "name": "integrate.Quad.time_quad_cython",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e2edfcdcee583057b5ed3b0457a0651204b56555482f883a4172c2a348c82ff6",
        "warmup_time": -1
    },
    "integrate.Quad.time_quad_python": {
        "code": "class Quad:\n    def time_quad_python(self):\n        quad(self.f_python, 0, np.pi)\n\n    def setup(self):\n        from math import sin\n    \n        self.f_python = lambda x: sin(x)\n        self.f_cython = from_cython(_ccallback_c, \"sine\")\n    \n        try:\n            from scipy.integrate.tests.test_quadpack import get_clib_test_routine\n            self.f_ctypes = get_clib_test_routine('_multivariate_sin', ctypes.c_double,\n                                                  ctypes.c_int, ctypes.c_double)\n        except ImportError:\n            lib = ctypes.CDLL(clib_test.__file__)\n            self.f_ctypes = lib._multivariate_sin\n            self.f_ctypes.restype = ctypes.c_double\n            self.f_ctypes.argtypes = (ctypes.c_int, ctypes.c_double)\n    \n        if cffi is not None:\n            voidp = ctypes.cast(self.f_ctypes, ctypes.c_void_p)\n            address = voidp.value\n            ffi = cffi.FFI()\n            self.f_cffi = LowLevelCallable(ffi.cast(\"double (*)(int, double *)\", address))",
        "min_run_count": 2,
        "name": "integrate.Quad.time_quad_python",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4acf496a93c06b7898de52abd5077f1ad3e3fcf93a1b0477889e660b34515417",
        "warmup_time": -1
    },
    "integrate.SolveBVP.time_flow": {
        "code": "class SolveBVP:\n    def time_flow(self):\n        x = np.linspace(0, 1, 10)\n        y = np.ones((7, x.size))\n        solve_bvp(self.fun_flow, self.bc_flow, x, y, p=[1], tol=self.TOL)",
        "min_run_count": 2,
        "name": "integrate.SolveBVP.time_flow",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "293d0d48d7da84b9911e7dc04cf3e31bdb1a4397e68597d8833cd1e39757f2b0",
        "warmup_time": -1
    },
    "integrate.SolveBVP.time_gas": {
        "code": "class SolveBVP:\n    def time_gas(self):\n        x = np.linspace(0, 3, 5)\n        y = np.empty((2, x.size))\n        y[0] = 0.5\n        y[1] = -0.5\n        solve_bvp(self.fun_gas, self.bc_gas, x, y, tol=self.TOL)",
        "min_run_count": 2,
        "name": "integrate.SolveBVP.time_gas",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "62ed65f56095bdfe5e0cb9b1ed557471ee4156fd3ce8778282a49bc79625b19c",
        "warmup_time": -1
    },
    "integrate.SolveBVP.time_peak": {
        "code": "class SolveBVP:\n    def time_peak(self):\n        x = np.linspace(-1, 1, 5)\n        y = np.zeros((2, x.size))\n        solve_bvp(self.fun_peak, self.bc_peak, x, y, tol=self.TOL)",
        "min_run_count": 2,
        "name": "integrate.SolveBVP.time_peak",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b4c8fe896d280ca8d3be45f4f837d03ef487b935598f20e10e080f9ca6c20c1c",
        "warmup_time": -1
    },
    "interpolate.BenchPPoly.time_evaluation": {
        "code": "class BenchPPoly:\n    def time_evaluation(self):\n        self.pp(self.xp)\n\n    def setup(self):\n        np.random.seed(1234)\n        m, k = 55, 3\n        x = np.sort(np.random.random(m+1))\n        c = np.random.random((3, m))\n        self.pp = interpolate.PPoly(c, x)\n    \n        npts = 100\n        self.xp = np.linspace(0, 1, npts)",
        "min_run_count": 2,
        "name": "interpolate.BenchPPoly.time_evaluation",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7b3c30a7aae410ff669a6194881961262f69b80709978c3720fbaa41a48e0ffa",
        "warmup_time": -1
    },
    "interpolate.BivariateSpline.time_lsq_bivariate_spline": {
        "code": "class BivariateSpline:\n    def time_lsq_bivariate_spline(self, n_samples):\n        interpolate.LSQBivariateSpline(self.x, self.y, self.z, self.xknots.flat, self.yknots.flat)\n\n    def setup(self, n_samples):\n        x = np.arange(0, n_samples, 0.5)\n        y = np.arange(0, n_samples, 0.5)\n        x, y = np.meshgrid(x, y)\n        x = x.ravel()\n        y = y.ravel()\n        xmin = x.min()-1\n        xmax = x.max()+1\n        ymin = y.min()-1\n        ymax = y.max()+1\n        s = 1.1\n        self.yknots = np.linspace(ymin+s, ymax-s, 10)\n        self.xknots = np.linspace(xmin+s, xmax-s, 10)\n        self.z = np.sin(x) + 0.1*np.random.normal(size=x.shape)\n        self.x = x\n        self.y = y",
        "min_run_count": 2,
        "name": "interpolate.BivariateSpline.time_lsq_bivariate_spline",
        "number": 0,
        "param_names": [
            "n_samples"
        ],
        "params": [
            [
                "10",
                "20",
                "30"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "26edc79385876a35063595d97558e84b15b2853afa424174781e5b6519cf0c15",
        "warmup_time": -1
    },
    "interpolate.BivariateSpline.time_smooth_bivariate_spline": {
        "code": "class BivariateSpline:\n    def time_smooth_bivariate_spline(self, n_samples):\n        interpolate.SmoothBivariateSpline(self.x, self.y, self.z)\n\n    def setup(self, n_samples):\n        x = np.arange(0, n_samples, 0.5)\n        y = np.arange(0, n_samples, 0.5)\n        x, y = np.meshgrid(x, y)\n        x = x.ravel()\n        y = y.ravel()\n        xmin = x.min()-1\n        xmax = x.max()+1\n        ymin = y.min()-1\n        ymax = y.max()+1\n        s = 1.1\n        self.yknots = np.linspace(ymin+s, ymax-s, 10)\n        self.xknots = np.linspace(xmin+s, xmax-s, 10)\n        self.z = np.sin(x) + 0.1*np.random.normal(size=x.shape)\n        self.x = x\n        self.y = y",
        "min_run_count": 2,
        "name": "interpolate.BivariateSpline.time_smooth_bivariate_spline",
        "number": 0,
        "param_names": [
            "n_samples"
        ],
        "params": [
            [
                "10",
                "20",
                "30"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8875044efdaa5468cee675d6cbafc5eec34054c8cb8e3dcbdeb62354818ef8af",
        "warmup_time": -1
    },
    "interpolate.GridData.time_evaluation": {
        "code": "class GridData:\n    def time_evaluation(self, n_grids, method):\n        interpolate.griddata(self.points, self.values, (self.grid_x, self.grid_y), method=method)\n\n    def setup(self, n_grids, method):\n        self.func = lambda x, y: x*(1-x)*np.cos(4*np.pi*x) * np.sin(4*np.pi*y**2)**2\n        self.grid_x, self.grid_y = np.mgrid[0:1:n_grids, 0:1:n_grids]\n        self.points = np.random.rand(1000, 2)\n        self.values = self.func(self.points[:, 0], self.points[:, 1])",
        "min_run_count": 2,
        "name": "interpolate.GridData.time_evaluation",
        "number": 0,
        "param_names": [
            "n_grids",
            "method"
        ],
        "params": [
            [
                "10j",
                "100j",
                "1000j"
            ],
            [
                "'nearest'",
                "'linear'",
                "'cubic'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "923d16af64b5a3a7b7c90d693c0d51555c0b3434cb436920a0e400d9ec8ada02",
        "warmup_time": -1
    },
    "interpolate.Interpolate.time_interpolate": {
        "code": "class Interpolate:\n    def time_interpolate(self, n_samples, module):\n        if module == 'scipy':\n            interpolate.interp1d(self.x, self.y, kind=\"linear\")\n        else:\n            np.interp(self.z, self.x, self.y)\n\n    def setup(self, n_samples, module):\n        self.x = np.arange(n_samples)\n        self.y = np.exp(-self.x/3.0)\n        self.z = np.random.normal(size=self.x.shape)",
        "min_run_count": 2,
        "name": "interpolate.Interpolate.time_interpolate",
        "number": 0,
        "param_names": [
            "n_samples",
            "module"
        ],
        "params": [
            [
                "10",
                "50",
                "100"
            ],
            [
                "'numpy'",
                "'scipy'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c7f060979e3517fffcbf1a369ef545515a013076ac2c659ccdf1596a636cc394",
        "warmup_time": -1
    },
    "interpolate.Interpolate1d.time_interpolate": {
        "code": "class Interpolate1d:\n    def time_interpolate(self, n_samples, method):\n        \"\"\"Time the construction overhead.\"\"\"\n        interpolate.interp1d(self.x, self.y, kind=method)\n\n    def setup(self, n_samples, method):\n        self.x = np.arange(n_samples)\n        self.y = np.exp(-self.x/3.0)\n        self.interpolator = interpolate.interp1d(self.x, self.y, kind=method)\n        self.xp = np.linspace(self.x[0], self.x[-1], 4*n_samples)",
        "min_run_count": 2,
        "name": "interpolate.Interpolate1d.time_interpolate",
        "number": 0,
        "param_names": [
            "n_samples",
            "method"
        ],
        "params": [
            [
                "10",
                "50",
                "100",
                "1000",
                "10000"
            ],
            [
                "'linear'",
                "'nearest'",
                "'zero'",
                "'slinear'",
                "'quadratic'",
                "'cubic'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "53ba4880a25d7a65d8bec417088d2ca3afa8e6a6534ed1eb7cf8eefe94f495bd",
        "warmup_time": -1
    },
    "interpolate.Interpolate1d.time_interpolate_eval": {
        "code": "class Interpolate1d:\n    def time_interpolate_eval(self, n_samples, method):\n        \"\"\"Time the evaluation.\"\"\"\n        self.interpolator(self.xp)\n\n    def setup(self, n_samples, method):\n        self.x = np.arange(n_samples)\n        self.y = np.exp(-self.x/3.0)\n        self.interpolator = interpolate.interp1d(self.x, self.y, kind=method)\n        self.xp = np.linspace(self.x[0], self.x[-1], 4*n_samples)",
        "min_run_count": 2,
        "name": "interpolate.Interpolate1d.time_interpolate_eval",
        "number": 0,
        "param_names": [
            "n_samples",
            "method"
        ],
        "params": [
            [
                "10",
                "50",
                "100",
                "1000",
                "10000"
            ],
            [
                "'linear'",
                "'nearest'",
                "'zero'",
                "'slinear'",
                "'quadratic'",
                "'cubic'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3e0c45886b58b68e7ea23068e78aee4f40175e59b2d3ec290f376d1fae95809d",
        "warmup_time": -1
    },
    "interpolate.Interpolate2d.time_interpolate": {
        "code": "class Interpolate2d:\n    def time_interpolate(self, n_samples, method):\n        interpolate.interp2d(self.x, self.y, self.z, kind=method)\n\n    def setup(self, n_samples, method):\n        r_samples = n_samples / 2.\n        self.x = np.arange(-r_samples, r_samples, 0.25)\n        self.y = np.arange(-r_samples, r_samples, 0.25)\n        self.xx, self.yy = np.meshgrid(self.x, self.y)\n        self.z = np.sin(self.xx**2+self.yy**2)",
        "min_run_count": 2,
        "name": "interpolate.Interpolate2d.time_interpolate",
        "number": 0,
        "param_names": [
            "n_samples",
            "method"
        ],
        "params": [
            [
                "10",
                "50",
                "100"
            ],
            [
                "'linear'",
                "'cubic'",
                "'quintic'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "48934ebda129680d6805a76a05748186a57d213fc0f27db8782b2705c6d6c7ec",
        "warmup_time": -1
    },
    "interpolate.Leaks.track_leaks": {
        "code": "class Leaks:\n    def track_leaks(self):\n        set_mem_rlimit()\n    \n        # Setup temp file, make it fit in memory\n        repeats = [2, 5, 10, 50, 200]\n        peak_mems = []\n    \n        for repeat in repeats:\n            code = \"\"\"\n            import numpy as np\n            from scipy.interpolate import griddata\n    \n            def func(x, y):\n                return x*(1-x)*np.cos(4*np.pi*x) * np.sin(4*np.pi*y**2)**2\n    \n            grid_x, grid_y = np.mgrid[0:1:100j, 0:1:200j]\n            points = np.random.rand(1000, 2)\n            values = func(points[:,0], points[:,1])\n    \n            for t in range(%(repeat)d):\n                for method in ['nearest', 'linear', 'cubic']:\n                    griddata(points, values, (grid_x, grid_y), method=method)\n    \n            \"\"\" % dict(repeat=repeat)\n    \n            _, peak_mem = run_monitored(code)\n            peak_mems.append(peak_mem)\n    \n        corr, p = spearmanr(repeats, peak_mems)\n        if p < 0.05:\n            print(\"*\"*79)\n            print(\"PROBABLE MEMORY LEAK\")\n            print(\"*\"*79)\n        else:\n            print(\"PROBABLY NO MEMORY LEAK\")\n    \n        return max(peak_mems) / min(peak_mems)",
        "name": "interpolate.Leaks.track_leaks",
        "param_names": [],
        "params": [],
        "timeout": 60.0,
        "type": "track",
        "unit": "relative increase with repeats",
        "version": "660364525468f5ec677c63e82cdf86d50c2f10a4ccbcc4f1f116be695f7c0f50"
    },
    "interpolate.Rbf.time_rbf_1d": {
        "code": "class Rbf:\n    def time_rbf_1d(self, n_samples, function):\n        interpolate.Rbf(self.x, self.y, function=function)\n\n    def setup(self, n_samples, function):\n        self.x = np.arange(n_samples)\n        self.y = np.sin(self.x)\n        r_samples = n_samples / 2.\n        self.X = np.arange(-r_samples, r_samples, 0.25)\n        self.Y = np.arange(-r_samples, r_samples, 0.25)\n        self.z = np.exp(-self.X**2-self.Y**2)",
        "min_run_count": 2,
        "name": "interpolate.Rbf.time_rbf_1d",
        "number": 0,
        "param_names": [
            "n_samples",
            "function"
        ],
        "params": [
            [
                "10",
                "50",
                "100"
            ],
            [
                "'multiquadric'",
                "'inverse'",
                "'gaussian'",
                "'linear'",
                "'cubic'",
                "'quintic'",
                "'thin_plate'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "322c7df9c3945502018241a8354ba06d665f4724576975d7749676e435f50628",
        "warmup_time": -1
    },
    "interpolate.Rbf.time_rbf_2d": {
        "code": "class Rbf:\n    def time_rbf_2d(self, n_samples, function):\n        interpolate.Rbf(self.X, self.Y, self.z, function=function)\n\n    def setup(self, n_samples, function):\n        self.x = np.arange(n_samples)\n        self.y = np.sin(self.x)\n        r_samples = n_samples / 2.\n        self.X = np.arange(-r_samples, r_samples, 0.25)\n        self.Y = np.arange(-r_samples, r_samples, 0.25)\n        self.z = np.exp(-self.X**2-self.Y**2)",
        "min_run_count": 2,
        "name": "interpolate.Rbf.time_rbf_2d",
        "number": 0,
        "param_names": [
            "n_samples",
            "function"
        ],
        "params": [
            [
                "10",
                "50",
                "100"
            ],
            [
                "'multiquadric'",
                "'inverse'",
                "'gaussian'",
                "'linear'",
                "'cubic'",
                "'quintic'",
                "'thin_plate'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0836465665fd46106764a0b8e45f7701a551aadfc91900cba329fda573193f18",
        "warmup_time": -1
    },
    "interpolate.UnivariateSpline.time_univariate_spline": {
        "code": "class UnivariateSpline:\n    def time_univariate_spline(self, n_samples, degree):\n        interpolate.UnivariateSpline(self.x, self.y, k=degree)\n\n    def setup(self, n_samples, degree):\n        r_samples = n_samples / 2.\n        self.x = np.arange(-r_samples, r_samples, 0.25)\n        self.y = np.exp(-self.x**2) + 0.1 * np.random.randn(*self.x.shape)",
        "min_run_count": 2,
        "name": "interpolate.UnivariateSpline.time_univariate_spline",
        "number": 0,
        "param_names": [
            "n_samples",
            "degree"
        ],
        "params": [
            [
                "10",
                "50",
                "100"
            ],
            [
                "3",
                "4",
                "5"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f29463d3d509e8f0d4533dce41682ae23c6c047e50f237c9afaac689ccf4df7d",
        "warmup_time": -1
    },
    "io_matlab.MemUsage.track_loadmat": {
        "code": "class MemUsage:\n    def track_loadmat(self, size, compressed):\n        size = int(self.sizes[size])\n    \n        x = np.random.rand(size//8).view(dtype=np.uint8)\n        savemat(self.filename, dict(x=x), do_compression=compressed, oned_as='row')\n        del x\n    \n        code = \"\"\"\n        from scipy.io import loadmat\n        loadmat('%s')\n        \"\"\" % (self.filename,)\n        time, peak_mem = run_monitored(code)\n    \n        return peak_mem / size\n\n    def setup(self, size, compressed):\n        set_mem_rlimit()\n        self.sizes = self._get_sizes()\n        size = int(self.sizes[size])\n    \n        mem_info = get_mem_info()\n        try:\n            mem_available = mem_info['memavailable']\n        except KeyError:\n            mem_available = mem_info['memtotal']\n    \n        max_size = int(mem_available * 0.7)//4\n    \n        if size > max_size:\n            raise NotImplementedError()\n    \n        # Setup temp file\n        f = tempfile.NamedTemporaryFile(delete=False, suffix='.mat')\n        f.close()\n        self.filename = f.name",
        "name": "io_matlab.MemUsage.track_loadmat",
        "param_names": [
            "size",
            "compressed"
        ],
        "params": [
            [
                "'1M'",
                "'10M'",
                "'100M'",
                "'300M'"
            ],
            [
                "True",
                "False"
            ]
        ],
        "timeout": 240,
        "type": "track",
        "unit": "actual/optimal memory usage ratio",
        "version": "a3de0f2b928a44594543559ae20a75c3b68b8ef0804ee8d76eb5d22cad39dd88"
    },
    "io_matlab.MemUsage.track_savemat": {
        "code": "class MemUsage:\n    def track_savemat(self, size, compressed):\n        size = int(self.sizes[size])\n    \n        code = \"\"\"\n        import numpy as np\n        from scipy.io import savemat\n        x = np.random.rand(%d//8).view(dtype=np.uint8)\n        savemat('%s', dict(x=x), do_compression=%r, oned_as='row')\n        \"\"\" % (size, self.filename, compressed)\n        time, peak_mem = run_monitored(code)\n        return peak_mem / size\n\n    def setup(self, size, compressed):\n        set_mem_rlimit()\n        self.sizes = self._get_sizes()\n        size = int(self.sizes[size])\n    \n        mem_info = get_mem_info()\n        try:\n            mem_available = mem_info['memavailable']\n        except KeyError:\n            mem_available = mem_info['memtotal']\n    \n        max_size = int(mem_available * 0.7)//4\n    \n        if size > max_size:\n            raise NotImplementedError()\n    \n        # Setup temp file\n        f = tempfile.NamedTemporaryFile(delete=False, suffix='.mat')\n        f.close()\n        self.filename = f.name",
        "name": "io_matlab.MemUsage.track_savemat",
        "param_names": [
            "size",
            "compressed"
        ],
        "params": [
            [
                "'1M'",
                "'10M'",
                "'100M'",
                "'300M'"
            ],
            [
                "True",
                "False"
            ]
        ],
        "timeout": 240,
        "type": "track",
        "unit": "actual/optimal memory usage ratio",
        "version": "457047076d11d25f1a3deee28e9af72616a90b5d6e383857226f869182bd8547"
    },
    "io_matlab.StructArr.time_loadmat": {
        "code": "class StructArr:\n    def time_loadmat(self, nvfs, compression):\n        loadmat(self.str_io)\n\n    def setup(self, nvfs, compression):\n        n_vars, n_fields, n_structs = nvfs\n    \n        self.var_dict = StructArr.make_structarr(n_vars, n_fields, n_structs)\n        self.str_io = BytesIO()\n    \n        savemat(self.str_io, self.var_dict, do_compression=compression)",
        "min_run_count": 2,
        "name": "io_matlab.StructArr.time_loadmat",
        "number": 0,
        "param_names": [
            "(vars, fields, structs)",
            "compression"
        ],
        "params": [
            [
                "(10, 10, 20)",
                "(20, 20, 40)",
                "(30, 30, 50)"
            ],
            [
                "False",
                "True"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "eaa1ea6c664b345fc8dd0a51ff7eedc973ed011300a9b2d3dedeec8cc61c2555",
        "warmup_time": -1
    },
    "io_matlab.StructArr.time_savemat": {
        "code": "class StructArr:\n    def time_savemat(self, nvfs, compression):\n        savemat(self.str_io, self.var_dict, do_compression=compression)\n\n    def setup(self, nvfs, compression):\n        n_vars, n_fields, n_structs = nvfs\n    \n        self.var_dict = StructArr.make_structarr(n_vars, n_fields, n_structs)\n        self.str_io = BytesIO()\n    \n        savemat(self.str_io, self.var_dict, do_compression=compression)",
        "min_run_count": 2,
        "name": "io_matlab.StructArr.time_savemat",
        "number": 0,
        "param_names": [
            "(vars, fields, structs)",
            "compression"
        ],
        "params": [
            [
                "(10, 10, 20)",
                "(20, 20, 40)",
                "(30, 30, 50)"
            ],
            [
                "False",
                "True"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8a4f85a8ff747a27983a799694aabf4332d11c7f5adb4b4a7db60a6b88ee538a",
        "warmup_time": -1
    },
    "linalg.Bench.time_det": {
        "code": "class Bench:\n    def time_det(self, size, contig, module):\n        if module == 'numpy':\n            nl.det(self.a)\n        else:\n            sl.det(self.a)\n\n    def setup(self, size, contig, module):\n        if module == 'numpy' and size >= 200:\n            # skip: slow, and not useful to benchmark numpy\n            raise NotImplementedError()\n    \n        a = random([size, size])\n        # larger diagonal ensures non-singularity:\n        for i in range(size):\n            a[i, i] = 10*(.1+a[i, i])\n        b = random([size])\n    \n        if contig != 'contig':\n            a = a[-1::-1, -1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n    \n        self.a = a\n        self.b = b",
        "min_run_count": 2,
        "name": "linalg.Bench.time_det",
        "number": 0,
        "param_names": [
            "size",
            "contiguous",
            "module"
        ],
        "params": [
            [
                "20",
                "100",
                "500",
                "1000"
            ],
            [
                "'contig'",
                "'nocont'"
            ],
            [
                "'numpy'",
                "'scipy'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "87e530ee50eb6b6c06c7a8abe51c2168e133d5cbd486f4c1c2b9cedc5a078325",
        "warmup_time": -1
    },
    "linalg.Bench.time_eigvals": {
        "code": "class Bench:\n    def time_eigvals(self, size, contig, module):\n        if module == 'numpy':\n            nl.eigvals(self.a)\n        else:\n            sl.eigvals(self.a)\n\n    def setup(self, size, contig, module):\n        if module == 'numpy' and size >= 200:\n            # skip: slow, and not useful to benchmark numpy\n            raise NotImplementedError()\n    \n        a = random([size, size])\n        # larger diagonal ensures non-singularity:\n        for i in range(size):\n            a[i, i] = 10*(.1+a[i, i])\n        b = random([size])\n    \n        if contig != 'contig':\n            a = a[-1::-1, -1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n    \n        self.a = a\n        self.b = b",
        "min_run_count": 2,
        "name": "linalg.Bench.time_eigvals",
        "number": 0,
        "param_names": [
            "size",
            "contiguous",
            "module"
        ],
        "params": [
            [
                "20",
                "100",
                "500",
                "1000"
            ],
            [
                "'contig'",
                "'nocont'"
            ],
            [
                "'numpy'",
                "'scipy'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9d68d3a6b473df9bdda3d3fd25c7f9aeea7d5cee869eec730fb2a2bcd1dfb907",
        "warmup_time": -1
    },
    "linalg.Bench.time_inv": {
        "code": "class Bench:\n    def time_inv(self, size, contig, module):\n        if module == 'numpy':\n            nl.inv(self.a)\n        else:\n            sl.inv(self.a)\n\n    def setup(self, size, contig, module):\n        if module == 'numpy' and size >= 200:\n            # skip: slow, and not useful to benchmark numpy\n            raise NotImplementedError()\n    \n        a = random([size, size])\n        # larger diagonal ensures non-singularity:\n        for i in range(size):\n            a[i, i] = 10*(.1+a[i, i])\n        b = random([size])\n    \n        if contig != 'contig':\n            a = a[-1::-1, -1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n    \n        self.a = a\n        self.b = b",
        "min_run_count": 2,
        "name": "linalg.Bench.time_inv",
        "number": 0,
        "param_names": [
            "size",
            "contiguous",
            "module"
        ],
        "params": [
            [
                "20",
                "100",
                "500",
                "1000"
            ],
            [
                "'contig'",
                "'nocont'"
            ],
            [
                "'numpy'",
                "'scipy'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "20beee193c84a5713da9749246a7c40ef21590186c35ed00a4fe854cce9e153b",
        "warmup_time": -1
    },
    "linalg.Bench.time_solve": {
        "code": "class Bench:\n    def time_solve(self, size, contig, module):\n        if module == 'numpy':\n            nl.solve(self.a, self.b)\n        else:\n            sl.solve(self.a, self.b)\n\n    def setup(self, size, contig, module):\n        if module == 'numpy' and size >= 200:\n            # skip: slow, and not useful to benchmark numpy\n            raise NotImplementedError()\n    \n        a = random([size, size])\n        # larger diagonal ensures non-singularity:\n        for i in range(size):\n            a[i, i] = 10*(.1+a[i, i])\n        b = random([size])\n    \n        if contig != 'contig':\n            a = a[-1::-1, -1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n    \n        self.a = a\n        self.b = b",
        "min_run_count": 2,
        "name": "linalg.Bench.time_solve",
        "number": 0,
        "param_names": [
            "size",
            "contiguous",
            "module"
        ],
        "params": [
            [
                "20",
                "100",
                "500",
                "1000"
            ],
            [
                "'contig'",
                "'nocont'"
            ],
            [
                "'numpy'",
                "'scipy'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1fe788070f1c9132cbe78a47fdb4cce58266427fc636d2aa9450e3c7d92c644c",
        "warmup_time": -1
    },
    "linalg.Bench.time_solve_triangular": {
        "code": "class Bench:\n    def time_solve_triangular(self, size, contig, module):\n        # treats self.a as a lower-triangular matrix by ignoring the strictly\n        # upper-triangular part\n        if module == 'numpy':\n            pass\n        else:\n            sl.solve_triangular(self.a, self.b, lower=True)\n\n    def setup(self, size, contig, module):\n        if module == 'numpy' and size >= 200:\n            # skip: slow, and not useful to benchmark numpy\n            raise NotImplementedError()\n    \n        a = random([size, size])\n        # larger diagonal ensures non-singularity:\n        for i in range(size):\n            a[i, i] = 10*(.1+a[i, i])\n        b = random([size])\n    \n        if contig != 'contig':\n            a = a[-1::-1, -1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n    \n        self.a = a\n        self.b = b",
        "min_run_count": 2,
        "name": "linalg.Bench.time_solve_triangular",
        "number": 0,
        "param_names": [
            "size",
            "contiguous",
            "module"
        ],
        "params": [
            [
                "20",
                "100",
                "500",
                "1000"
            ],
            [
                "'contig'",
                "'nocont'"
            ],
            [
                "'numpy'",
                "'scipy'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f0ca78a2bbbb31809b47991f60d79103e46f6c00da7d9a55146c99be2e120904",
        "warmup_time": -1
    },
    "linalg.Bench.time_svd": {
        "code": "class Bench:\n    def time_svd(self, size, contig, module):\n        if module == 'numpy':\n            nl.svd(self.a)\n        else:\n            sl.svd(self.a)\n\n    def setup(self, size, contig, module):\n        if module == 'numpy' and size >= 200:\n            # skip: slow, and not useful to benchmark numpy\n            raise NotImplementedError()\n    \n        a = random([size, size])\n        # larger diagonal ensures non-singularity:\n        for i in range(size):\n            a[i, i] = 10*(.1+a[i, i])\n        b = random([size])\n    \n        if contig != 'contig':\n            a = a[-1::-1, -1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n    \n        self.a = a\n        self.b = b",
        "min_run_count": 2,
        "name": "linalg.Bench.time_svd",
        "number": 0,
        "param_names": [
            "size",
            "contiguous",
            "module"
        ],
        "params": [
            [
                "20",
                "100",
                "500"
            ],
            [
                "'contig'",
                "'nocont'"
            ],
            [
                "'numpy'",
                "'scipy'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0ccbda456d096e459d4a6eefc6c674a815179e215f83931a81cfa8c18e39d6e3",
        "warmup_time": -1
    },
    "linalg.GetFuncs.time_get_blas_funcs": {
        "code": "class GetFuncs:\n    def time_get_blas_funcs(self):\n        sl.blas.get_blas_funcs('gemm', dtype=float)\n\n    def setup(self):\n        self.x = np.eye(1)",
        "min_run_count": 2,
        "name": "linalg.GetFuncs.time_get_blas_funcs",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "85a492abc5bc17863ce56989679878c5cf88bfbabf331e733bac1e15c8b372c5",
        "warmup_time": -1
    },
    "linalg.GetFuncs.time_get_blas_funcs_2": {
        "code": "class GetFuncs:\n    def time_get_blas_funcs_2(self):\n        sl.blas.get_blas_funcs(('gemm', 'axpy'), (self.x, self.x))\n\n    def setup(self):\n        self.x = np.eye(1)",
        "min_run_count": 2,
        "name": "linalg.GetFuncs.time_get_blas_funcs_2",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c5594e743e5de438fdfc4892c3c3ebf5f647a20b063740bc7b54e1b9728b17d2",
        "warmup_time": -1
    },
    "linalg.GetFuncs.time_small_cholesky": {
        "code": "class GetFuncs:\n    def time_small_cholesky(self):\n        sl.cholesky(self.x)\n\n    def setup(self):\n        self.x = np.eye(1)",
        "min_run_count": 2,
        "name": "linalg.GetFuncs.time_small_cholesky",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5498b2ca496c0cc3be4278c533bbd9f6242df36c6116c748198937ffa7765a3d",
        "warmup_time": -1
    },
    "linalg.Lstsq.time_lstsq": {
        "code": "class Lstsq:\n    def time_lstsq(self, dtype, size, lapack_driver):\n        if lapack_driver == 'numpy':\n            np.linalg.lstsq(self.A, self.b,\n                            rcond=np.finfo(self.A.dtype).eps * 100)\n        else:\n            sl.lstsq(self.A, self.b, cond=None, overwrite_a=False,\n                     overwrite_b=False, check_finite=False,\n                     lapack_driver=lapack_driver)\n\n    def setup(self, dtype, size, lapack_driver):\n        if lapack_driver == 'numpy' and size >= 200:\n            # skip: slow, and not useful to benchmark numpy\n            raise NotImplementedError()\n    \n        np.random.seed(1234)\n        n = math.ceil(2./3. * size)\n        k = math.ceil(1./2. * size)\n        m = size\n    \n        if dtype is np.complex128:\n            A = ((10 * np.random.rand(m,k) - 5) +\n                 1j*(10 * np.random.rand(m,k) - 5))\n            temp = ((10 * np.random.rand(k,n) - 5) +\n                    1j*(10 * np.random.rand(k,n) - 5))\n            b = ((10 * np.random.rand(m,1) - 5) +\n                 1j*(10 * np.random.rand(m,1) - 5))\n        else:\n            A = (10 * np.random.rand(m,k) - 5)\n            temp = 10 * np.random.rand(k,n) - 5\n            b = 10 * np.random.rand(m,1) - 5\n    \n        self.A = A.dot(temp)\n        self.b = b",
        "min_run_count": 2,
        "name": "linalg.Lstsq.time_lstsq",
        "number": 0,
        "param_names": [
            "dtype",
            "size",
            "driver"
        ],
        "params": [
            [
                "<class 'numpy.float64'>",
                "<class 'numpy.complex128'>"
            ],
            [
                "10",
                "100",
                "1000"
            ],
            [
                "'gelss'",
                "'gelsy'",
                "'gelsd'",
                "'numpy'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "15ee0be14a0a597c7d1c9a3dab2c39e15c8ac623484410ffefa406bf6b596ebe",
        "warmup_time": -1
    },
    "linalg.Norm.time_1_norm": {
        "code": "class Norm:\n    def time_1_norm(self, size, contig, module):\n        if module == 'numpy':\n            nl.norm(self.a, ord=1)\n        else:\n            sl.norm(self.a, ord=1)\n\n    def setup(self, shape, contig, module):\n        a = np.random.randn(*shape)\n        if contig != 'contig':\n            a = a[-1::-1,-1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n        self.a = a",
        "min_run_count": 2,
        "name": "linalg.Norm.time_1_norm",
        "number": 0,
        "param_names": [
            "shape",
            "contiguous",
            "module"
        ],
        "params": [
            [
                "(20, 20)",
                "(100, 100)",
                "(1000, 1000)",
                "(20, 1000)",
                "(1000, 20)"
            ],
            [
                "'contig'",
                "'nocont'"
            ],
            [
                "'numpy'",
                "'scipy'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0c4e469d4304940ea54e1e81648836218da8c130601351fcd645b5d0856aad52",
        "warmup_time": -1
    },
    "linalg.Norm.time_frobenius_norm": {
        "code": "class Norm:\n    def time_frobenius_norm(self, size, contig, module):\n        if module == 'numpy':\n            nl.norm(self.a)\n        else:\n            sl.norm(self.a)\n\n    def setup(self, shape, contig, module):\n        a = np.random.randn(*shape)\n        if contig != 'contig':\n            a = a[-1::-1,-1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n        self.a = a",
        "min_run_count": 2,
        "name": "linalg.Norm.time_frobenius_norm",
        "number": 0,
        "param_names": [
            "shape",
            "contiguous",
            "module"
        ],
        "params": [
            [
                "(20, 20)",
                "(100, 100)",
                "(1000, 1000)",
                "(20, 1000)",
                "(1000, 20)"
            ],
            [
                "'contig'",
                "'nocont'"
            ],
            [
                "'numpy'",
                "'scipy'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8fe6813e0aaaefc14b8423df9052a9ae584c655d64d2aa3f640bccf491f5023d",
        "warmup_time": -1
    },
    "linalg.Norm.time_inf_norm": {
        "code": "class Norm:\n    def time_inf_norm(self, size, contig, module):\n        if module == 'numpy':\n            nl.norm(self.a, ord=np.inf)\n        else:\n            sl.norm(self.a, ord=np.inf)\n\n    def setup(self, shape, contig, module):\n        a = np.random.randn(*shape)\n        if contig != 'contig':\n            a = a[-1::-1,-1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n        self.a = a",
        "min_run_count": 2,
        "name": "linalg.Norm.time_inf_norm",
        "number": 0,
        "param_names": [
            "shape",
            "contiguous",
            "module"
        ],
        "params": [
            [
                "(20, 20)",
                "(100, 100)",
                "(1000, 1000)",
                "(20, 1000)",
                "(1000, 20)"
            ],
            [
                "'contig'",
                "'nocont'"
            ],
            [
                "'numpy'",
                "'scipy'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "eeebd84b29c3213e8701161fb693d8ccf1b0a3ce1571b7056a2375d860a9f379",
        "warmup_time": -1
    },
    "linalg.SpecialMatrices.time_block_diag_big": {
        "code": "class SpecialMatrices:\n    def time_block_diag_big(self, size):\n        sl.block_diag(*self.big_blocks)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]",
        "min_run_count": 2,
        "name": "linalg.SpecialMatrices.time_block_diag_big",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "4",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ca1cfb7c5688eb5158bf1a4786c068cadad77dac06e0993bb7a09900268d2f8a",
        "warmup_time": -1
    },
    "linalg.SpecialMatrices.time_block_diag_small": {
        "code": "class SpecialMatrices:\n    def time_block_diag_small(self, size):\n        sl.block_diag(*self.small_blocks)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]",
        "min_run_count": 2,
        "name": "linalg.SpecialMatrices.time_block_diag_small",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "4",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "08bd113cd63ceab984ec8506832a8481a9f71ec545ed6c666bf8b136ba1641a4",
        "warmup_time": -1
    },
    "linalg.SpecialMatrices.time_circulant": {
        "code": "class SpecialMatrices:\n    def time_circulant(self, size):\n        sl.circulant(self.x)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]",
        "min_run_count": 2,
        "name": "linalg.SpecialMatrices.time_circulant",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "4",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9a8e71bd90ee1cee162f93e666ffbe70e52dcff361363ed393451e95173ffb93",
        "warmup_time": -1
    },
    "linalg.SpecialMatrices.time_companion": {
        "code": "class SpecialMatrices:\n    def time_companion(self, size):\n        sl.companion(self.x)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]",
        "min_run_count": 2,
        "name": "linalg.SpecialMatrices.time_companion",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "4",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6a2b51c299f8053c4a2892dfb27fe9c0e04839e27f282ee64082a3c6f945bb26",
        "warmup_time": -1
    },
    "linalg.SpecialMatrices.time_dft": {
        "code": "class SpecialMatrices:\n    def time_dft(self, size):\n        sl.dft(size)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]",
        "min_run_count": 2,
        "name": "linalg.SpecialMatrices.time_dft",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "4",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "774d3ef82e8e8667149d3b0392926b8b14f31654b8e8a1e9040ee11dc8a81001",
        "warmup_time": -1
    },
    "linalg.SpecialMatrices.time_hadamard": {
        "code": "class SpecialMatrices:\n    def time_hadamard(self, size):\n        sl.hadamard(size)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]",
        "min_run_count": 2,
        "name": "linalg.SpecialMatrices.time_hadamard",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "4",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6982c46c572fb1e959ddc398e289b7c0297219cf0b1da0fb2bbe593a8238143e",
        "warmup_time": -1
    },
    "linalg.SpecialMatrices.time_hankel": {
        "code": "class SpecialMatrices:\n    def time_hankel(self, size):\n        sl.hankel(self.x)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]",
        "min_run_count": 2,
        "name": "linalg.SpecialMatrices.time_hankel",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "4",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "df4ca64aee572eecd70fd7579f07d92ead412147971b102d0a5d07085d1a570b",
        "warmup_time": -1
    },
    "linalg.SpecialMatrices.time_helmert": {
        "code": "class SpecialMatrices:\n    def time_helmert(self, size):\n        sl.helmert(size)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]",
        "min_run_count": 2,
        "name": "linalg.SpecialMatrices.time_helmert",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "4",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "95dd6bf94b1595e67c8773393bb7444b228699d7816587cb2c78a5de5a2b7e61",
        "warmup_time": -1
    },
    "linalg.SpecialMatrices.time_hilbert": {
        "code": "class SpecialMatrices:\n    def time_hilbert(self, size):\n        sl.hilbert(size)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]",
        "min_run_count": 2,
        "name": "linalg.SpecialMatrices.time_hilbert",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "4",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "893c05bfdd50af7f0ecd24db33c54fbd8161eda59eee574312a59f9556d1e152",
        "warmup_time": -1
    },
    "linalg.SpecialMatrices.time_invhilbert": {
        "code": "class SpecialMatrices:\n    def time_invhilbert(self, size):\n        sl.invhilbert(size)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]",
        "min_run_count": 2,
        "name": "linalg.SpecialMatrices.time_invhilbert",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "4",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "95fc697960fd6ba2701667dd367983c5da39658cf1ea3912e8070291c88a5651",
        "warmup_time": -1
    },
    "linalg.SpecialMatrices.time_invpascal": {
        "code": "class SpecialMatrices:\n    def time_invpascal(self, size):\n        sl.invpascal(size)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]",
        "min_run_count": 2,
        "name": "linalg.SpecialMatrices.time_invpascal",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "4",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c986e6e8e50989963505966431db567554ecc8d0ce48e3e1b01d864c9fabb823",
        "warmup_time": -1
    },
    "linalg.SpecialMatrices.time_leslie": {
        "code": "class SpecialMatrices:\n    def time_leslie(self, size):\n        sl.leslie(self.x, self.x[1:])\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]",
        "min_run_count": 2,
        "name": "linalg.SpecialMatrices.time_leslie",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "4",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "32f946dce60929e4b038909b92206c66036f26ef3f447ffe35f1acda9adad10c",
        "warmup_time": -1
    },
    "linalg.SpecialMatrices.time_pascal": {
        "code": "class SpecialMatrices:\n    def time_pascal(self, size):\n        sl.pascal(size)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]",
        "min_run_count": 2,
        "name": "linalg.SpecialMatrices.time_pascal",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "4",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7eb81323c4e69ab614ac789d44882ed319c651987bc9795f36af4264a7383a7c",
        "warmup_time": -1
    },
    "linalg.SpecialMatrices.time_toeplitz": {
        "code": "class SpecialMatrices:\n    def time_toeplitz(self, size):\n        sl.toeplitz(self.x)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]",
        "min_run_count": 2,
        "name": "linalg.SpecialMatrices.time_toeplitz",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "4",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "72f43bf3cb772c6ef6be46598b81a7ba5d59f9fc12fb58e3a2f1148c8ec755fb",
        "warmup_time": -1
    },
    "linalg.SpecialMatrices.time_tri": {
        "code": "class SpecialMatrices:\n    def time_tri(self, size):\n        sl.tri(size)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]",
        "min_run_count": 2,
        "name": "linalg.SpecialMatrices.time_tri",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "4",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d05516db154b58d2f451d73de93d7796248136f0ca2000c3ad0e85943dca37ff",
        "warmup_time": -1
    },
    "linalg_logm.Logm.time_logm": {
        "code": "class Logm:\n    def time_logm(self, dtype, n, structure):\n        scipy.linalg.logm(self.A, disp=False)\n\n    def setup(self, dtype, n, structure):\n        n = int(n)\n        dtype = np.dtype(dtype)\n    \n        A = np.random.rand(n, n)\n        if dtype == np.complex128:\n            A = A + 1j*np.random.rand(n, n)\n    \n        if structure == 'pos':\n            A = A @ A.T.conj()\n        elif structure == 'her':\n            A = A + A.T.conj()\n    \n        self.A = A",
        "min_run_count": 2,
        "name": "linalg_logm.Logm.time_logm",
        "number": 0,
        "param_names": [
            "dtype",
            "n",
            "structure"
        ],
        "params": [
            [
                "'float64'",
                "'complex128'"
            ],
            [
                "64",
                "256"
            ],
            [
                "'gen'",
                "'her'",
                "'pos'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6e9f69e2e3cd7003ba0cf66bf2706a2be2c80f065d0f48427d3c7bda668a2058",
        "warmup_time": -1
    },
    "linalg_solve_toeplitz.SolveToeplitz.time_solve_toeplitz": {
        "code": "class SolveToeplitz:\n    def time_solve_toeplitz(self, dtype, n, soltype):\n        if soltype == 'toeplitz':\n            scipy.linalg.solve_toeplitz((self.c, self.r), self.y)\n        else:\n            scipy.linalg.solve(self.T, self.y)\n\n    def setup(self, dtype, n, soltype):\n        random = np.random.RandomState(1234)\n    \n        dtype = np.dtype(dtype)\n    \n        # Sample a random Toeplitz matrix representation and rhs.\n        c = random.randn(n)\n        r = random.randn(n)\n        y = random.randn(n)\n        if dtype == np.complex128:\n            c = c + 1j*random.rand(n)\n            r = r + 1j*random.rand(n)\n            y = y + 1j*random.rand(n)\n    \n        self.c = c\n        self.r = r\n        self.y = y\n        self.T = scipy.linalg.toeplitz(c, r=r)",
        "min_run_count": 2,
        "name": "linalg_solve_toeplitz.SolveToeplitz.time_solve_toeplitz",
        "number": 0,
        "param_names": [
            "dtype",
            "n",
            "solver"
        ],
        "params": [
            [
                "'float64'",
                "'complex128'"
            ],
            [
                "100",
                "300",
                "1000"
            ],
            [
                "'toeplitz'",
                "'generic'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d5d6bb8933b458885e968d871d860965a2af33720ca7a4872dafe7b9db2eb5c3",
        "warmup_time": -1
    },
    "linalg_sqrtm.Sqrtm.time_sqrtm": {
        "code": "class Sqrtm:\n    def time_sqrtm(self, dtype, n, blocksize):\n        scipy.linalg.sqrtm(self.A, disp=False, blocksize=blocksize)\n\n    def setup(self, dtype, n, blocksize):\n        n = int(n)\n        dtype = np.dtype(dtype)\n        blocksize = int(blocksize)\n        A = np.random.rand(n, n)\n        if dtype == np.complex128:\n            A = A + 1j*np.random.rand(n, n)\n        self.A = A\n    \n        if blocksize > n:\n            raise NotImplementedError()",
        "min_run_count": 2,
        "name": "linalg_sqrtm.Sqrtm.time_sqrtm",
        "number": 0,
        "param_names": [
            "dtype",
            "n",
            "blocksize"
        ],
        "params": [
            [
                "'float64'",
                "'complex128'"
            ],
            [
                "64",
                "256"
            ],
            [
                "32",
                "64",
                "256"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "359ff21f2b4f63f08772e0e19eef1758190d58abd549c8b5b6d8b784100b9cb0",
        "warmup_time": -1
    },
    "ndimage_interpolation.NdimageInterpolation.peakmem_rotate": {
        "code": "class NdimageInterpolation:\n    def peakmem_rotate(self, shape, order, mode):\n        rotate(self.x, 15, order=order, mode=mode)\n\n    def setup(self, shape, order, mode):\n        rstate = np.random.RandomState(5)\n        self.x = rstate.standard_normal(shape)\n        self.matrix_2d = np.asarray([[0.8, 0, 1.5],\n                                     [0, 1.2, -5.]])\n        self.matrix_3d = np.asarray([[0.8, 0, 0, 1.5],\n                                     [0, 1.2, 0, -5.],\n                                     [0, 0, 1, 0]])",
        "name": "ndimage_interpolation.NdimageInterpolation.peakmem_rotate",
        "param_names": [
            "shape",
            "order",
            "mode"
        ],
        "params": [
            [
                "(64, 64)",
                "(512, 512)",
                "(2048, 2048)",
                "(16, 16, 16)",
                "(128, 128, 128)"
            ],
            [
                "0",
                "1",
                "3",
                "5"
            ],
            [
                "'mirror'",
                "'constant'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "6f1ea489a0714868c9f52c013d563cda0604c90c44d49df51afe4c5c362a8331"
    },
    "ndimage_interpolation.NdimageInterpolation.peakmem_shift": {
        "code": "class NdimageInterpolation:\n    def peakmem_shift(self, shape, order, mode):\n        shift(self.x, 3, order=order, mode=mode)\n\n    def setup(self, shape, order, mode):\n        rstate = np.random.RandomState(5)\n        self.x = rstate.standard_normal(shape)\n        self.matrix_2d = np.asarray([[0.8, 0, 1.5],\n                                     [0, 1.2, -5.]])\n        self.matrix_3d = np.asarray([[0.8, 0, 0, 1.5],\n                                     [0, 1.2, 0, -5.],\n                                     [0, 0, 1, 0]])",
        "name": "ndimage_interpolation.NdimageInterpolation.peakmem_shift",
        "param_names": [
            "shape",
            "order",
            "mode"
        ],
        "params": [
            [
                "(64, 64)",
                "(512, 512)",
                "(2048, 2048)",
                "(16, 16, 16)",
                "(128, 128, 128)"
            ],
            [
                "0",
                "1",
                "3",
                "5"
            ],
            [
                "'mirror'",
                "'constant'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "c0431a339d0b5e59a56534e533fc4236ebe6fc1086c437410c900ab9005e4dd7"
    },
    "ndimage_interpolation.NdimageInterpolation.time_affine_transform": {
        "code": "class NdimageInterpolation:\n    def time_affine_transform(self, shape, order, mode):\n        if self.x.ndim == 2:\n            matrix = self.matrix_2d\n        else:\n            matrix = self.matrix_3d\n        affine_transform(self.x, matrix, order=order, mode=mode)\n\n    def setup(self, shape, order, mode):\n        rstate = np.random.RandomState(5)\n        self.x = rstate.standard_normal(shape)\n        self.matrix_2d = np.asarray([[0.8, 0, 1.5],\n                                     [0, 1.2, -5.]])\n        self.matrix_3d = np.asarray([[0.8, 0, 0, 1.5],\n                                     [0, 1.2, 0, -5.],\n                                     [0, 0, 1, 0]])",
        "min_run_count": 2,
        "name": "ndimage_interpolation.NdimageInterpolation.time_affine_transform",
        "number": 0,
        "param_names": [
            "shape",
            "order",
            "mode"
        ],
        "params": [
            [
                "(64, 64)",
                "(512, 512)",
                "(2048, 2048)",
                "(16, 16, 16)",
                "(128, 128, 128)"
            ],
            [
                "0",
                "1",
                "3",
                "5"
            ],
            [
                "'mirror'",
                "'constant'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "87ae4c3be4b670d5403bc0cecc52f5b360269fe4b6d91bce0cc65359bbb45888",
        "warmup_time": -1
    },
    "ndimage_interpolation.NdimageInterpolation.time_geometric_transform_mapping": {
        "code": "class NdimageInterpolation:\n    def time_geometric_transform_mapping(self, shape, order, mode):\n        if self.x.ndim == 2:\n            mapping = shift_func_2d\n        if self.x.ndim == 3:\n            mapping = shift_func_3d\n        geometric_transform(self.x, mapping, order=order, mode=mode)\n\n    def setup(self, shape, order, mode):\n        rstate = np.random.RandomState(5)\n        self.x = rstate.standard_normal(shape)\n        self.matrix_2d = np.asarray([[0.8, 0, 1.5],\n                                     [0, 1.2, -5.]])\n        self.matrix_3d = np.asarray([[0.8, 0, 0, 1.5],\n                                     [0, 1.2, 0, -5.],\n                                     [0, 0, 1, 0]])",
        "min_run_count": 2,
        "name": "ndimage_interpolation.NdimageInterpolation.time_geometric_transform_mapping",
        "number": 0,
        "param_names": [
            "shape",
            "order",
            "mode"
        ],
        "params": [
            [
                "(64, 64)",
                "(512, 512)",
                "(2048, 2048)",
                "(16, 16, 16)",
                "(128, 128, 128)"
            ],
            [
                "0",
                "1",
                "3",
                "5"
            ],
            [
                "'mirror'",
                "'constant'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7d3fc4986820607551da357e66e28639b5182b2b75c35dbc7c979748b11042a1",
        "warmup_time": -1
    },
    "ndimage_interpolation.NdimageInterpolation.time_map_coordinates": {
        "code": "class NdimageInterpolation:\n    def time_map_coordinates(self, shape, order, mode):\n        coords = np.meshgrid(*[np.arange(0, s, 2) + 0.3 for s in self.x.shape])\n        map_coordinates(self.x, coords, order=order, mode=mode)\n\n    def setup(self, shape, order, mode):\n        rstate = np.random.RandomState(5)\n        self.x = rstate.standard_normal(shape)\n        self.matrix_2d = np.asarray([[0.8, 0, 1.5],\n                                     [0, 1.2, -5.]])\n        self.matrix_3d = np.asarray([[0.8, 0, 0, 1.5],\n                                     [0, 1.2, 0, -5.],\n                                     [0, 0, 1, 0]])",
        "min_run_count": 2,
        "name": "ndimage_interpolation.NdimageInterpolation.time_map_coordinates",
        "number": 0,
        "param_names": [
            "shape",
            "order",
            "mode"
        ],
        "params": [
            [
                "(64, 64)",
                "(512, 512)",
                "(2048, 2048)",
                "(16, 16, 16)",
                "(128, 128, 128)"
            ],
            [
                "0",
                "1",
                "3",
                "5"
            ],
            [
                "'mirror'",
                "'constant'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "12262655b132fab6113eccbf4e5c74a7683219f463ba745394a95c0eb0e02053",
        "warmup_time": -1
    },
    "ndimage_interpolation.NdimageInterpolation.time_rotate": {
        "code": "class NdimageInterpolation:\n    def time_rotate(self, shape, order, mode):\n        rotate(self.x, 15, order=order, mode=mode)\n\n    def setup(self, shape, order, mode):\n        rstate = np.random.RandomState(5)\n        self.x = rstate.standard_normal(shape)\n        self.matrix_2d = np.asarray([[0.8, 0, 1.5],\n                                     [0, 1.2, -5.]])\n        self.matrix_3d = np.asarray([[0.8, 0, 0, 1.5],\n                                     [0, 1.2, 0, -5.],\n                                     [0, 0, 1, 0]])",
        "min_run_count": 2,
        "name": "ndimage_interpolation.NdimageInterpolation.time_rotate",
        "number": 0,
        "param_names": [
            "shape",
            "order",
            "mode"
        ],
        "params": [
            [
                "(64, 64)",
                "(512, 512)",
                "(2048, 2048)",
                "(16, 16, 16)",
                "(128, 128, 128)"
            ],
            [
                "0",
                "1",
                "3",
                "5"
            ],
            [
                "'mirror'",
                "'constant'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c346329372eb7abaaedd1f78c642ae55fff9d5991644b9608ab3ed4380d00d0c",
        "warmup_time": -1
    },
    "ndimage_interpolation.NdimageInterpolation.time_shift": {
        "code": "class NdimageInterpolation:\n    def time_shift(self, shape, order, mode):\n        shift(self.x, (-2.5,) * self.x.ndim, order=order, mode=mode)\n\n    def setup(self, shape, order, mode):\n        rstate = np.random.RandomState(5)\n        self.x = rstate.standard_normal(shape)\n        self.matrix_2d = np.asarray([[0.8, 0, 1.5],\n                                     [0, 1.2, -5.]])\n        self.matrix_3d = np.asarray([[0.8, 0, 0, 1.5],\n                                     [0, 1.2, 0, -5.],\n                                     [0, 0, 1, 0]])",
        "min_run_count": 2,
        "name": "ndimage_interpolation.NdimageInterpolation.time_shift",
        "number": 0,
        "param_names": [
            "shape",
            "order",
            "mode"
        ],
        "params": [
            [
                "(64, 64)",
                "(512, 512)",
                "(2048, 2048)",
                "(16, 16, 16)",
                "(128, 128, 128)"
            ],
            [
                "0",
                "1",
                "3",
                "5"
            ],
            [
                "'mirror'",
                "'constant'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "136f315880a230d6e7dd105c0bbefde19261fab1b85e40d0d6124dbf51359c04",
        "warmup_time": -1
    },
    "ndimage_interpolation.NdimageInterpolation.time_zoom": {
        "code": "class NdimageInterpolation:\n    def time_zoom(self, shape, order, mode):\n        zoom(self.x, (1.3,) * self.x.ndim, order=order, mode=mode)\n\n    def setup(self, shape, order, mode):\n        rstate = np.random.RandomState(5)\n        self.x = rstate.standard_normal(shape)\n        self.matrix_2d = np.asarray([[0.8, 0, 1.5],\n                                     [0, 1.2, -5.]])\n        self.matrix_3d = np.asarray([[0.8, 0, 0, 1.5],\n                                     [0, 1.2, 0, -5.],\n                                     [0, 0, 1, 0]])",
        "min_run_count": 2,
        "name": "ndimage_interpolation.NdimageInterpolation.time_zoom",
        "number": 0,
        "param_names": [
            "shape",
            "order",
            "mode"
        ],
        "params": [
            [
                "(64, 64)",
                "(512, 512)",
                "(2048, 2048)",
                "(16, 16, 16)",
                "(128, 128, 128)"
            ],
            [
                "0",
                "1",
                "3",
                "5"
            ],
            [
                "'mirror'",
                "'constant'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "986a39adec187cc3b9b3ad42a883d5fa054683bbc38fa75ff3a5c64d9d1fb14d",
        "warmup_time": -1
    },
    "optimize.BenchGlobal.track_all": {
        "code": "class BenchGlobal:\n    def track_all(self, name, ret_value, solver):\n        if name in self.results and solver in self.results[name]:\n            # have we done the function, and done the solver?\n            # if so, then just return the ret_value\n            av_results = self.results[name]\n            if ret_value == 'success%':\n                return 100 * av_results[solver]['nsuccess'] / av_results[solver]['ntrials']\n            elif ret_value == '<nfev>':\n                return av_results[solver]['mean_nfev']\n            else:\n                raise ValueError()\n    \n        klass = self._functions[name]\n        f = klass()\n        try:\n            b = _BenchOptimizers.from_funcobj(name, f)\n            with np.errstate(all='ignore'):\n                b.bench_run_global(methods=[solver],\n                                   numtrials=self.numtrials)\n    \n            av_results = b.average_results()\n    \n            if name not in self.results:\n                self.results[name] = {}\n            self.results[name][solver] = av_results[solver]\n    \n            if ret_value == 'success%':\n                return 100 * av_results[solver]['nsuccess'] / av_results[solver]['ntrials']\n            elif ret_value == '<nfev>':\n                return av_results[solver]['mean_nfev']\n            else:\n                raise ValueError()\n        except Exception:\n            print(\"\".join(traceback.format_exc()))\n            self.results[name] = \"\".join(traceback.format_exc())\n\n    def setup(self, name, ret_value, solver):\n        if name not in self._enabled_functions:\n            raise NotImplementedError(\"skipped\")\n    \n        # load json backing file\n        with open(self.dump_fn, 'r') as f:\n            self.results = json.load(f)\n\n    def setup_cache(self):\n        if not self.enabled:\n            return\n    \n        # create the logfile to start with\n        with open(self.dump_fn, 'w') as f:\n            json.dump({}, f, indent=2)",
        "name": "optimize.BenchGlobal.track_all",
        "param_names": [
            "test function",
            "result type",
            "solver"
        ],
        "params": [
            [
                "'AMGM'",
                "'Ackley01'",
                "'Ackley02'",
                "'Ackley03'",
                "'Adjiman'",
                "'Alpine01'",
                "'Alpine02'",
                "'BartelsConn'",
                "'Beale'",
                "'BiggsExp02'",
                "'BiggsExp03'",
                "'BiggsExp04'",
                "'BiggsExp05'",
                "'Bird'",
                "'Bohachevsky1'",
                "'Bohachevsky2'",
                "'Bohachevsky3'",
                "'BoxBetts'",
                "'Branin01'",
                "'Branin02'",
                "'Brent'",
                "'Brown'",
                "'Bukin02'",
                "'Bukin04'",
                "'Bukin06'",
                "'CarromTable'",
                "'Chichinadze'",
                "'Cigar'",
                "'Cola'",
                "'Colville'",
                "'Corana'",
                "'CosineMixture'",
                "'CrossInTray'",
                "'CrossLegTable'",
                "'CrownedCross'",
                "'Csendes'",
                "'Cube'",
                "'Damavandi'",
                "'DeVilliersGlasser01'",
                "'DeVilliersGlasser02'",
                "'Deb01'",
                "'Deb03'",
                "'Decanomial'",
                "'Deceptive'",
                "'DeckkersAarts'",
                "'DeflectedCorrugatedSpring'",
                "'DixonPrice'",
                "'Dolan'",
                "'DropWave'",
                "'Easom'",
                "'Eckerle4'",
                "'EggCrate'",
                "'EggHolder'",
                "'ElAttarVidyasagarDutta'",
                "'Exp2'",
                "'Exponential'",
                "'FreudensteinRoth'",
                "'Gear'",
                "'Giunta'",
                "'GoldsteinPrice'",
                "'Griewank'",
                "'Gulf'",
                "'Hansen'",
                "'Hartmann3'",
                "'Hartmann6'",
                "'HelicalValley'",
                "'HimmelBlau'",
                "'HolderTable'",
                "'Hosaki'",
                "'Infinity'",
                "'JennrichSampson'",
                "'Judge'",
                "'Katsuura'",
                "'Keane'",
                "'Kowalik'",
                "'Langermann'",
                "'LennardJones'",
                "'Leon'",
                "'Levy03'",
                "'Levy05'",
                "'Levy13'",
                "'Matyas'",
                "'McCormick'",
                "'Meyer'",
                "'Michalewicz'",
                "'MieleCantrell'",
                "'Mishra01'",
                "'Mishra02'",
                "'Mishra03'",
                "'Mishra04'",
                "'Mishra05'",
                "'Mishra06'",
                "'Mishra07'",
                "'Mishra08'",
                "'Mishra09'",
                "'Mishra10'",
                "'Mishra11'",
                "'MultiModal'",
                "'NeedleEye'",
                "'NewFunction01'",
                "'NewFunction02'",
                "'OddSquare'",
                "'Parsopoulos'",
                "'Pathological'",
                "'Paviani'",
                "'PenHolder'",
                "'Penalty01'",
                "'Penalty02'",
                "'PermFunction01'",
                "'PermFunction02'",
                "'Pinter'",
                "'Plateau'",
                "'Powell'",
                "'PowerSum'",
                "'Price01'",
                "'Price02'",
                "'Price03'",
                "'Price04'",
                "'Qing'",
                "'Quadratic'",
                "'Quintic'",
                "'Rana'",
                "'Rastrigin'",
                "'Ratkowsky01'",
                "'Ratkowsky02'",
                "'Ripple01'",
                "'Ripple25'",
                "'Rosenbrock'",
                "'RosenbrockModified'",
                "'RotatedEllipse01'",
                "'RotatedEllipse02'",
                "'Salomon'",
                "'Sargan'",
                "'Schaffer01'",
                "'Schaffer02'",
                "'Schaffer03'",
                "'Schaffer04'",
                "'Schwefel01'",
                "'Schwefel02'",
                "'Schwefel04'",
                "'Schwefel06'",
                "'Schwefel20'",
                "'Schwefel21'",
                "'Schwefel22'",
                "'Schwefel26'",
                "'Schwefel36'",
                "'Shekel05'",
                "'Shekel07'",
                "'Shekel10'",
                "'Shubert01'",
                "'Shubert03'",
                "'Shubert04'",
                "'SineEnvelope'",
                "'SixHumpCamel'",
                "'Sodp'",
                "'Sphere'",
                "'Step'",
                "'Step2'",
                "'Stochastic'",
                "'StretchedV'",
                "'StyblinskiTang'",
                "'TestTubeHolder'",
                "'ThreeHumpCamel'",
                "'Thurber'",
                "'Treccani'",
                "'Trefethen'",
                "'Trid'",
                "'Trigonometric01'",
                "'Trigonometric02'",
                "'Tripod'",
                "'Ursem01'",
                "'Ursem03'",
                "'Ursem04'",
                "'UrsemWaves'",
                "'VenterSobiezcczanskiSobieski'",
                "'Vincent'",
                "'Watson'",
                "'Wavy'",
                "'WayburnSeader01'",
                "'WayburnSeader02'",
                "'Weierstrass'",
                "'Whitley'",
                "'Wolfe'",
                "'XinSheYang01'",
                "'XinSheYang02'",
                "'XinSheYang03'",
                "'XinSheYang04'",
                "'Xor'",
                "'YaoLiu04'",
                "'YaoLiu09'",
                "'Zacharov'",
                "'ZeroSum'",
                "'Zettl'",
                "'Zimmerman'",
                "'Zirilli'"
            ],
            [
                "'success%'",
                "'<nfev>'"
            ],
            [
                "'DE'",
                "'basinh.'",
                "'DA'"
            ]
        ],
        "setup_cache_key": "optimize:519",
        "timeout": 300,
        "type": "track",
        "unit": "unit",
        "version": "054a3246db40d00bd06bdd153e16fba533aa32a939b0cc5a9d4ad3425afdd4d5"
    },
    "optimize.BenchLeastSquares.track_all": {
        "code": "class BenchLeastSquares:\n    def track_all(self, problem_name, result_type):\n        problem = self.problems[problem_name]\n    \n        if problem.lb is not None or problem.ub is not None:\n            raise NotImplementedError\n    \n        ftol = 1e-5\n    \n        if result_type == 'average time':\n            n_runs = 10\n            t0 = time.time()\n            for _ in range(n_runs):\n                leastsq(problem.fun, problem.x0, Dfun=problem.jac, ftol=ftol,\n                        full_output=True)\n            return (time.time() - t0) / n_runs\n    \n        x, cov_x, info, message, ier = leastsq(\n            problem.fun, problem.x0, Dfun=problem.jac,\n            ftol=ftol, full_output=True\n        )\n        if result_type == 'nfev':\n            return info['nfev']\n        elif result_type == 'success':\n            return int(problem.check_answer(x, ftol))\n        else:\n            raise NotImplementedError",
        "name": "optimize.BenchLeastSquares.track_all",
        "param_names": [
            "problem",
            "result type"
        ],
        "params": [
            [
                "'AlphaPineneDirect'",
                "'ChebyshevQuadrature'",
                "'CoatingThickness'",
                "'EnzymeReaction'",
                "'ExponentialFitting'",
                "'GaussianFitting'",
                "'ThermistorResistance'"
            ],
            [
                "'average time'",
                "'nfev'",
                "'success'"
            ]
        ],
        "timeout": 60.0,
        "type": "track",
        "unit": "unit",
        "version": "f38fbe672c2954249e521c5aa92737c6659f885c52e0ed5fa863c171f56bb902"
    },
    "optimize.BenchSmoothUnbounded.track_all": {
        "code": "class BenchSmoothUnbounded:\n    def track_all(self, func_name, method_name, ret_val):\n        return self.result\n\n    def setup(self, func_name, method_name, ret_val):\n        b = getattr(self, 'run_' + func_name)(methods=[method_name])\n        r = b.average_results().get(method_name)\n        if r is None:\n            raise NotImplementedError()\n        self.result = getattr(r, ret_val)",
        "name": "optimize.BenchSmoothUnbounded.track_all",
        "param_names": [
            "test function",
            "solver",
            "result type"
        ],
        "params": [
            [
                "'rosenbrock_slow'",
                "'rosenbrock_nograd'",
                "'rosenbrock'",
                "'rosenbrock_tight'",
                "'simple_quadratic'",
                "'asymmetric_quadratic'",
                "'sin_1d'",
                "'booth'",
                "'beale'",
                "'LJ'"
            ],
            [
                "'COBYLA'",
                "'Powell'",
                "'nelder-mead'",
                "'L-BFGS-B'",
                "'BFGS'",
                "'CG'",
                "'TNC'",
                "'SLSQP'",
                "'Newton-CG'",
                "'dogleg'",
                "'trust-ncg'",
                "'trust-exact'",
                "'trust-krylov'",
                "'trust-constr'"
            ],
            [
                "'mean_nfev'",
                "'mean_time'"
            ]
        ],
        "timeout": 60.0,
        "type": "track",
        "unit": "unit",
        "version": "470a193366611f84efefb220d095286dbc18dc8501b63d8e703aad41a1b0b32f"
    },
    "optimize_lap.LinearAssignment.time_evaluation": {
        "code": "class LinearAssignment:\n    def time_evaluation(self, *args):\n        linear_sum_assignment(self.cost_matrix)\n\n    def setup(self, shape, cost_type):\n    \n        cost_func = {'uniform': random_uniform,\n                     'spatial': random_spatial,\n                     'logarithmic': random_logarithmic,\n                     'integer': random_integer,\n                     'binary': random_binary}[cost_type]\n    \n        self.cost_matrix = cost_func(shape)",
        "min_run_count": 2,
        "name": "optimize_lap.LinearAssignment.time_evaluation",
        "number": 0,
        "param_names": [
            "shape",
            "cost_type"
        ],
        "params": [
            [
                "(100, 100)",
                "(200, 200)",
                "(300, 300)",
                "(400, 400)",
                "(100, 200)",
                "(200, 400)",
                "(300, 600)",
                "(400, 800)",
                "(200, 100)",
                "(400, 200)",
                "(600, 300)",
                "(800, 400)"
            ],
            [
                "'uniform'",
                "'spatial'",
                "'logarithmic'",
                "'integer'",
                "'binary'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ac7928b4de54d3fe94a6560b66d403b8ed9ffe1f2c8e910dd59159fda0bb34b0",
        "warmup_time": -1
    },
    "optimize_linprog.KleeMinty.time_klee_minty": {
        "code": "class KleeMinty:\n    def time_klee_minty(self, meth, dims):\n        method, options = meth\n        res = linprog(c=self.c, A_ub=self.A_ub, b_ub=self.b_ub,\n                      method=method, options=options)\n        self.fun = res.fun\n        self.x = res.x\n\n    def setup(self, meth, dims):\n        self.c, self.A_ub, self.b_ub, self.xf, self.obj = klee_minty(dims)\n        self.fun = None",
        "min_run_count": 2,
        "name": "optimize_linprog.KleeMinty.time_klee_minty",
        "number": 0,
        "param_names": [
            "method",
            "dimensions"
        ],
        "params": [
            [
                "('highs-ipm', {})",
                "('highs-ds', {})"
            ],
            [
                "3",
                "6",
                "9"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "590dc9ee8c5e8773840dee6216d46fd19d8f684dee353f9a5fa6b37c39b9d381",
        "warmup_time": -1
    },
    "optimize_linprog.KleeMinty.track_klee_minty": {
        "code": "class KleeMinty:\n    def track_klee_minty(self, meth, prob):\n        if self.fun is None:\n            self.time_klee_minty(meth, prob)\n        self.abs_error = np.abs(self.fun - self.obj)\n        self.rel_error = np.abs((self.fun - self.obj)/self.obj)\n        return min(self.abs_error, self.rel_error)\n\n    def setup(self, meth, dims):\n        self.c, self.A_ub, self.b_ub, self.xf, self.obj = klee_minty(dims)\n        self.fun = None",
        "name": "optimize_linprog.KleeMinty.track_klee_minty",
        "param_names": [
            "method",
            "dimensions"
        ],
        "params": [
            [
                "('highs-ipm', {})",
                "('highs-ds', {})"
            ],
            [
                "3",
                "6",
                "9"
            ]
        ],
        "timeout": 60.0,
        "type": "track",
        "unit": "unit",
        "version": "64d3a316d3de8ff7bad239207b13f3b6bee2326fe913a4e0d15cf727b3291c30"
    },
    "optimize_linprog.LpGen.time_lpgen": {
        "code": "class LpGen:\n    def time_lpgen(self, meth, m, n):\n        method, options = meth\n        with suppress_warnings() as sup:\n            sup.filter(RuntimeWarning, \"scipy.linalg.solve\\nIll-conditioned\")\n            linprog(c=self.c, A_ub=self.A, b_ub=self.b,\n                    method=method, options=options)\n\n    def setup(self, meth, m, n):\n        self.A, self.b, self.c = lpgen_2d(m, n)",
        "min_run_count": 2,
        "name": "optimize_linprog.LpGen.time_lpgen",
        "number": 0,
        "param_names": [
            "method",
            "m",
            "n"
        ],
        "params": [
            [
                "('highs-ipm', {})",
                "('highs-ds', {})"
            ],
            [
                "20",
                "40",
                "60",
                "80"
            ],
            [
                "20",
                "40",
                "60",
                "80"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "71ffc02cac666c80fe11a5dd116b7e33c97b5d9f27ccb95bb83610359c927c4e",
        "warmup_time": -1
    },
    "optimize_linprog.MagicSquare.time_magic_square": {
        "code": "class MagicSquare:\n    def time_magic_square(self, meth, prob):\n        method, options = meth\n        with suppress_warnings() as sup:\n            sup.filter(OptimizeWarning, \"A_eq does not appear\")\n            res = linprog(c=self.c, A_eq=self.A_eq, b_eq=self.b_eq,\n                          bounds=(0, 1), method=method, options=options)\n            self.fun = res.fun\n\n    def setup(self, meth, prob):\n        if not is_xslow():\n            if prob[0] > 4:\n                raise NotImplementedError(\"skipped\")\n    \n        dims, obj = prob\n        self.A_eq, self.b_eq, self.c, numbers = magic_square(dims)\n        self.fun = None",
        "min_run_count": 2,
        "name": "optimize_linprog.MagicSquare.time_magic_square",
        "number": 0,
        "param_names": [
            "method",
            "(dimensions, objective)"
        ],
        "params": [
            [
                "('highs-ipm', {})",
                "('highs-ds', {})"
            ],
            [
                "(3, 1.7305505947214375)",
                "(4, 1.5485271031586025)",
                "(5, 1.807494583582637)",
                "(6, 1.747266446858304)"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a2d63b603727562fee9f2834a915d3322d974a7771e2d575a937b135cac94e8a",
        "warmup_time": -1
    },
    "optimize_linprog.MagicSquare.track_magic_square": {
        "code": "class MagicSquare:\n    def track_magic_square(self, meth, prob):\n        dims, obj = prob\n        if self.fun is None:\n            self.time_magic_square(meth, prob)\n        self.abs_error = np.abs(self.fun - obj)\n        self.rel_error = np.abs((self.fun - obj)/obj)\n        return min(self.abs_error, self.rel_error)\n\n    def setup(self, meth, prob):\n        if not is_xslow():\n            if prob[0] > 4:\n                raise NotImplementedError(\"skipped\")\n    \n        dims, obj = prob\n        self.A_eq, self.b_eq, self.c, numbers = magic_square(dims)\n        self.fun = None",
        "name": "optimize_linprog.MagicSquare.track_magic_square",
        "param_names": [
            "method",
            "(dimensions, objective)"
        ],
        "params": [
            [
                "('highs-ipm', {})",
                "('highs-ds', {})"
            ],
            [
                "(3, 1.7305505947214375)",
                "(4, 1.5485271031586025)",
                "(5, 1.807494583582637)",
                "(6, 1.747266446858304)"
            ]
        ],
        "timeout": 60.0,
        "type": "track",
        "unit": "unit",
        "version": "e3b369f3a7e63a53038f20ea5c1c758640a6b4385b5e7b361771ed478805c7c2"
    },
    "optimize_linprog.Netlib.time_netlib": {
        "code": "class Netlib:\n    def time_netlib(self, meth, prob):\n        method, options = meth\n        res = linprog(c=self.c,\n                      A_ub=self.A_ub,\n                      b_ub=self.b_ub,\n                      A_eq=self.A_eq,\n                      b_eq=self.b_eq,\n                      bounds=self.bounds,\n                      method=method,\n                      options=options)\n        self.fun = res.fun\n\n    def setup(self, meth, prob):\n        if prob not in enabled_problems:\n            raise NotImplementedError(\"skipped\")\n    \n        dir_path = os.path.dirname(os.path.realpath(__file__))\n        datafile = os.path.join(dir_path, \"linprog_benchmark_files\",\n                                prob + \".npz\")\n        data = np.load(datafile, allow_pickle=True)\n        self.c = data[\"c\"]\n        self.A_eq = data[\"A_eq\"]\n        self.A_ub = data[\"A_ub\"]\n        self.b_ub = data[\"b_ub\"]\n        self.b_eq = data[\"b_eq\"]\n        self.bounds = np.squeeze(data[\"bounds\"])\n        self.obj = float(data[\"obj\"].flatten()[0])\n        self.fun = None",
        "min_run_count": 2,
        "name": "optimize_linprog.Netlib.time_netlib",
        "number": 0,
        "param_names": [
            "method",
            "problems"
        ],
        "params": [
            [
                "('highs-ipm', {})",
                "('highs-ds', {})"
            ],
            [
                "'25FV47'",
                "'80BAU3B'",
                "'ADLITTLE'",
                "'AFIRO'",
                "'AGG'",
                "'AGG2'",
                "'AGG3'",
                "'BANDM'",
                "'BEACONFD'",
                "'BLEND'",
                "'BNL1'",
                "'BNL2'",
                "'BORE3D'",
                "'BRANDY'",
                "'CAPRI'",
                "'CYCLE'",
                "'CZPROB'",
                "'D2Q06C'",
                "'D6CUBE'",
                "'DEGEN2'",
                "'DEGEN3'",
                "'DFL001'",
                "'E226'",
                "'ETAMACRO'",
                "'FFFFF800'",
                "'FINNIS'",
                "'FIT1D'",
                "'FIT1P'",
                "'FIT2D'",
                "'FIT2P'",
                "'GANGES'",
                "'GFRD-PNC'",
                "'GREENBEA'",
                "'GREENBEB'",
                "'GROW15'",
                "'GROW22'",
                "'GROW7'",
                "'ISRAEL'",
                "'KB2'",
                "'LOTFI'",
                "'MAROS'",
                "'MAROS-R7'",
                "'MODSZK1'",
                "'PEROLD'",
                "'PILOT'",
                "'PILOT4'",
                "'PILOT87'",
                "'PILOT-JA'",
                "'PILOTNOV'",
                "'PILOT-WE'",
                "'QAP8'",
                "'QAP12'",
                "'QAP15'",
                "'RECIPE'",
                "'SC105'",
                "'SC205'",
                "'SC50A'",
                "'SC50B'",
                "'SCAGR25'",
                "'SCAGR7'",
                "'SCFXM1'",
                "'SCFXM2'",
                "'SCFXM3'",
                "'SCORPION'",
                "'SCRS8'",
                "'SCSD1'",
                "'SCSD6'",
                "'SCSD8'",
                "'SCTAP1'",
                "'SCTAP2'",
                "'SCTAP3'",
                "'SHARE1B'",
                "'SHARE2B'",
                "'SHELL'",
                "'SHIP04L'",
                "'SHIP04S'",
                "'SHIP08L'",
                "'SHIP08S'",
                "'SHIP12L'",
                "'SHIP12S'",
                "'SIERRA'",
                "'STAIR'",
                "'STANDATA'",
                "'STANDMPS'",
                "'STOCFOR1'",
                "'STOCFOR2'",
                "'STOCFOR3'",
                "'TRUSS'",
                "'TUFF'",
                "'VTP-BASE'",
                "'WOOD1P'",
                "'WOODW'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0f8db47357a83308585eabf9bcd253727c0983fedb1679bd79a7fcbbd98b50c0",
        "warmup_time": -1
    },
    "optimize_linprog.Netlib.track_netlib": {
        "code": "class Netlib:\n    def track_netlib(self, meth, prob):\n        if self.fun is None:\n            self.time_netlib(meth, prob)\n        self.abs_error = np.abs(self.fun - self.obj)\n        self.rel_error = np.abs((self.fun - self.obj)/self.obj)\n        return min(self.abs_error, self.rel_error)\n\n    def setup(self, meth, prob):\n        if prob not in enabled_problems:\n            raise NotImplementedError(\"skipped\")\n    \n        dir_path = os.path.dirname(os.path.realpath(__file__))\n        datafile = os.path.join(dir_path, \"linprog_benchmark_files\",\n                                prob + \".npz\")\n        data = np.load(datafile, allow_pickle=True)\n        self.c = data[\"c\"]\n        self.A_eq = data[\"A_eq\"]\n        self.A_ub = data[\"A_ub\"]\n        self.b_ub = data[\"b_ub\"]\n        self.b_eq = data[\"b_eq\"]\n        self.bounds = np.squeeze(data[\"bounds\"])\n        self.obj = float(data[\"obj\"].flatten()[0])\n        self.fun = None",
        "name": "optimize_linprog.Netlib.track_netlib",
        "param_names": [
            "method",
            "problems"
        ],
        "params": [
            [
                "('highs-ipm', {})",
                "('highs-ds', {})"
            ],
            [
                "'25FV47'",
                "'80BAU3B'",
                "'ADLITTLE'",
                "'AFIRO'",
                "'AGG'",
                "'AGG2'",
                "'AGG3'",
                "'BANDM'",
                "'BEACONFD'",
                "'BLEND'",
                "'BNL1'",
                "'BNL2'",
                "'BORE3D'",
                "'BRANDY'",
                "'CAPRI'",
                "'CYCLE'",
                "'CZPROB'",
                "'D2Q06C'",
                "'D6CUBE'",
                "'DEGEN2'",
                "'DEGEN3'",
                "'DFL001'",
                "'E226'",
                "'ETAMACRO'",
                "'FFFFF800'",
                "'FINNIS'",
                "'FIT1D'",
                "'FIT1P'",
                "'FIT2D'",
                "'FIT2P'",
                "'GANGES'",
                "'GFRD-PNC'",
                "'GREENBEA'",
                "'GREENBEB'",
                "'GROW15'",
                "'GROW22'",
                "'GROW7'",
                "'ISRAEL'",
                "'KB2'",
                "'LOTFI'",
                "'MAROS'",
                "'MAROS-R7'",
                "'MODSZK1'",
                "'PEROLD'",
                "'PILOT'",
                "'PILOT4'",
                "'PILOT87'",
                "'PILOT-JA'",
                "'PILOTNOV'",
                "'PILOT-WE'",
                "'QAP8'",
                "'QAP12'",
                "'QAP15'",
                "'RECIPE'",
                "'SC105'",
                "'SC205'",
                "'SC50A'",
                "'SC50B'",
                "'SCAGR25'",
                "'SCAGR7'",
                "'SCFXM1'",
                "'SCFXM2'",
                "'SCFXM3'",
                "'SCORPION'",
                "'SCRS8'",
                "'SCSD1'",
                "'SCSD6'",
                "'SCSD8'",
                "'SCTAP1'",
                "'SCTAP2'",
                "'SCTAP3'",
                "'SHARE1B'",
                "'SHARE2B'",
                "'SHELL'",
                "'SHIP04L'",
                "'SHIP04S'",
                "'SHIP08L'",
                "'SHIP08S'",
                "'SHIP12L'",
                "'SHIP12S'",
                "'SIERRA'",
                "'STAIR'",
                "'STANDATA'",
                "'STANDMPS'",
                "'STOCFOR1'",
                "'STOCFOR2'",
                "'STOCFOR3'",
                "'TRUSS'",
                "'TUFF'",
                "'VTP-BASE'",
                "'WOOD1P'",
                "'WOODW'"
            ]
        ],
        "timeout": 60.0,
        "type": "track",
        "unit": "unit",
        "version": "befe1a7a33447935ad3d650fd130dc2fc23eb5db0f4181621556a468b07bec42"
    },
    "optimize_linprog.Netlib_infeasible.time_netlib_infeasible": {
        "code": "class Netlib_infeasible:\n    def time_netlib_infeasible(self, meth, prob):\n        method, options = meth\n        res = linprog(c=self.c,\n                      A_ub=self.A_ub,\n                      b_ub=self.b_ub,\n                      A_eq=self.A_eq,\n                      b_eq=self.b_eq,\n                      bounds=self.bounds,\n                      method=method,\n                      options=options)\n        self.status = res.status\n\n    def setup(self, meth, prob):\n        if prob not in enabled_infeasible_problems:\n            raise NotImplementedError(\"skipped\")\n    \n        dir_path = os.path.dirname(os.path.realpath(__file__))\n        datafile = os.path.join(dir_path, \"linprog_benchmark_files\",\n                                \"infeasible\", prob + \".npz\")\n        data = np.load(datafile, allow_pickle=True)\n        self.c = data[\"c\"]\n        self.A_eq = data[\"A_eq\"]\n        self.A_ub = data[\"A_ub\"]\n        self.b_ub = data[\"b_ub\"]\n        self.b_eq = data[\"b_eq\"]\n        self.bounds = np.squeeze(data[\"bounds\"])\n        self.status = None",
        "min_run_count": 2,
        "name": "optimize_linprog.Netlib_infeasible.time_netlib_infeasible",
        "number": 0,
        "param_names": [
            "method",
            "problems"
        ],
        "params": [
            [
                "('highs-ipm', {})",
                "('highs-ds', {})"
            ],
            [
                "'bgdbg1'",
                "'bgetam'",
                "'bgindy'",
                "'bgprtr'",
                "'box1'",
                "'ceria3d'",
                "'chemcom'",
                "'cplex1'",
                "'cplex2'",
                "'ex72a'",
                "'ex73a'",
                "'forest6'",
                "'galenet'",
                "'gosh'",
                "'gran'",
                "'itest2'",
                "'itest6'",
                "'klein1'",
                "'klein2'",
                "'klein3'",
                "'mondou2'",
                "'pang'",
                "'pilot4i'",
                "'qual'",
                "'reactor'",
                "'refinery'",
                "'vol1'",
                "'woodinfe'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "234e7cd5d84acbf11f9592c780274124c4dd0e95221d1070d296c9be8c63fde2",
        "warmup_time": -1
    },
    "optimize_linprog.Netlib_infeasible.track_netlib_infeasible": {
        "code": "class Netlib_infeasible:\n    def track_netlib_infeasible(self, meth, prob):\n        if self.status is None:\n            self.time_netlib_infeasible(meth, prob)\n        return self.status\n\n    def setup(self, meth, prob):\n        if prob not in enabled_infeasible_problems:\n            raise NotImplementedError(\"skipped\")\n    \n        dir_path = os.path.dirname(os.path.realpath(__file__))\n        datafile = os.path.join(dir_path, \"linprog_benchmark_files\",\n                                \"infeasible\", prob + \".npz\")\n        data = np.load(datafile, allow_pickle=True)\n        self.c = data[\"c\"]\n        self.A_eq = data[\"A_eq\"]\n        self.A_ub = data[\"A_ub\"]\n        self.b_ub = data[\"b_ub\"]\n        self.b_eq = data[\"b_eq\"]\n        self.bounds = np.squeeze(data[\"bounds\"])\n        self.status = None",
        "name": "optimize_linprog.Netlib_infeasible.track_netlib_infeasible",
        "param_names": [
            "method",
            "problems"
        ],
        "params": [
            [
                "('highs-ipm', {})",
                "('highs-ds', {})"
            ],
            [
                "'bgdbg1'",
                "'bgetam'",
                "'bgindy'",
                "'bgprtr'",
                "'box1'",
                "'ceria3d'",
                "'chemcom'",
                "'cplex1'",
                "'cplex2'",
                "'ex72a'",
                "'ex73a'",
                "'forest6'",
                "'galenet'",
                "'gosh'",
                "'gran'",
                "'itest2'",
                "'itest6'",
                "'klein1'",
                "'klein2'",
                "'klein3'",
                "'mondou2'",
                "'pang'",
                "'pilot4i'",
                "'qual'",
                "'reactor'",
                "'refinery'",
                "'vol1'",
                "'woodinfe'"
            ]
        ],
        "timeout": 60.0,
        "type": "track",
        "unit": "unit",
        "version": "e850b6f6e316fd1bf5294dabbb3b89686f0bd67a92e7c4b77f898c8170cba67d"
    },
    "optimize_qap.QuadraticAssignment.time_evaluation": {
        "code": "class QuadraticAssignment:\n    def time_evaluation(self, method, qap_prob):\n        quadratic_assignment(self.A, self.B, self.method)\n\n    def setup(self, method, qap_prob):\n        dir_path = os.path.dirname(os.path.realpath(__file__))\n        datafile = np.load(os.path.join(dir_path, \"qapdata/qap_probs.npz\"),\n                           allow_pickle=True)\n        slnfile = np.load(os.path.join(dir_path, \"qapdata/qap_sols.npz\"),\n                          allow_pickle=True)\n        self.A = datafile[qap_prob][0]\n        self.B = datafile[qap_prob][1]\n        self.opt_solution = slnfile[qap_prob]\n        self.method = method",
        "min_run_count": 2,
        "name": "optimize_qap.QuadraticAssignment.time_evaluation",
        "number": 0,
        "param_names": [
            "Method",
            "QAP Problem"
        ],
        "params": [
            [
                "'faq'",
                "'2opt'"
            ],
            [
                "'bur26a'",
                "'bur26b'",
                "'bur26c'",
                "'bur26d'",
                "'bur26e'",
                "'bur26f'",
                "'bur26g'",
                "'bur26h'",
                "'chr12a'",
                "'chr12b'",
                "'chr12c'",
                "'chr15a'",
                "'chr15b'",
                "'chr15c'",
                "'chr18a'",
                "'chr18b'",
                "'chr20a'",
                "'chr20b'",
                "'chr20c'",
                "'chr22a'",
                "'chr22b'",
                "'chr25a'",
                "'els19'",
                "'esc16a'",
                "'esc16b'",
                "'esc16c'",
                "'esc16d'",
                "'esc16e'",
                "'esc16g'",
                "'esc16h'",
                "'esc16i'",
                "'esc16j'",
                "'esc32e'",
                "'esc32g'",
                "'esc128'",
                "'had12'",
                "'had14'",
                "'had16'",
                "'had18'",
                "'had20'",
                "'kra30a'",
                "'kra30b'",
                "'kra32'",
                "'lipa20a'",
                "'lipa20b'",
                "'lipa30a'",
                "'lipa30b'",
                "'lipa40a'",
                "'lipa40b'",
                "'lipa50a'",
                "'lipa50b'",
                "'lipa60a'",
                "'lipa60b'",
                "'lipa70a'",
                "'lipa70b'",
                "'lipa80a'",
                "'lipa90a'",
                "'lipa90b'",
                "'nug12'",
                "'nug14'",
                "'nug16a'",
                "'nug16b'",
                "'nug17'",
                "'nug18'",
                "'nug20'",
                "'nug21'",
                "'nug22'",
                "'nug24'",
                "'nug25'",
                "'nug27'",
                "'nug28'",
                "'nug30'",
                "'rou12'",
                "'rou15'",
                "'rou20'",
                "'scr12'",
                "'scr15'",
                "'scr20'",
                "'sko42'",
                "'sko49'",
                "'sko56'",
                "'sko64'",
                "'sko72'",
                "'sko81'",
                "'sko90'",
                "'sko100a'",
                "'sko100b'",
                "'sko100c'",
                "'sko100d'",
                "'sko100e'",
                "'sko100f'",
                "'ste36b'",
                "'ste36c'",
                "'tai12a'",
                "'tai12b'",
                "'tai15a'",
                "'tai15b'",
                "'tai17a'",
                "'tai20a'",
                "'tai20b'",
                "'tai25a'",
                "'tai25b'",
                "'tai30a'",
                "'tai30b'",
                "'tai35a'",
                "'tai40a'",
                "'tai40b'",
                "'tai50a'",
                "'tai50b'",
                "'tai60a'",
                "'tai60b'",
                "'tai64c'",
                "'tai80a'",
                "'tai100a'",
                "'tai100b'",
                "'tai150b'",
                "'tai256c'",
                "'tho30'",
                "'tho40'",
                "'tho150'",
                "'wil50'",
                "'wil100'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c0a8e360f79b16ca85ddf8a2d090b72de71d8dd6c04c5ff2c090f39c0469bbb6",
        "warmup_time": -1
    },
    "optimize_qap.QuadraticAssignment.track_score": {
        "code": "class QuadraticAssignment:\n    def track_score(self, method, qap_prob):\n        res = quadratic_assignment(self.A, self.B, self.method)\n        score = int(res['score'])\n        percent_diff = (score - self.opt_solution) / self.opt_solution\n        return percent_diff\n\n    def setup(self, method, qap_prob):\n        dir_path = os.path.dirname(os.path.realpath(__file__))\n        datafile = np.load(os.path.join(dir_path, \"qapdata/qap_probs.npz\"),\n                           allow_pickle=True)\n        slnfile = np.load(os.path.join(dir_path, \"qapdata/qap_sols.npz\"),\n                          allow_pickle=True)\n        self.A = datafile[qap_prob][0]\n        self.B = datafile[qap_prob][1]\n        self.opt_solution = slnfile[qap_prob]\n        self.method = method",
        "name": "optimize_qap.QuadraticAssignment.track_score",
        "param_names": [
            "Method",
            "QAP Problem"
        ],
        "params": [
            [
                "'faq'",
                "'2opt'"
            ],
            [
                "'bur26a'",
                "'bur26b'",
                "'bur26c'",
                "'bur26d'",
                "'bur26e'",
                "'bur26f'",
                "'bur26g'",
                "'bur26h'",
                "'chr12a'",
                "'chr12b'",
                "'chr12c'",
                "'chr15a'",
                "'chr15b'",
                "'chr15c'",
                "'chr18a'",
                "'chr18b'",
                "'chr20a'",
                "'chr20b'",
                "'chr20c'",
                "'chr22a'",
                "'chr22b'",
                "'chr25a'",
                "'els19'",
                "'esc16a'",
                "'esc16b'",
                "'esc16c'",
                "'esc16d'",
                "'esc16e'",
                "'esc16g'",
                "'esc16h'",
                "'esc16i'",
                "'esc16j'",
                "'esc32e'",
                "'esc32g'",
                "'esc128'",
                "'had12'",
                "'had14'",
                "'had16'",
                "'had18'",
                "'had20'",
                "'kra30a'",
                "'kra30b'",
                "'kra32'",
                "'lipa20a'",
                "'lipa20b'",
                "'lipa30a'",
                "'lipa30b'",
                "'lipa40a'",
                "'lipa40b'",
                "'lipa50a'",
                "'lipa50b'",
                "'lipa60a'",
                "'lipa60b'",
                "'lipa70a'",
                "'lipa70b'",
                "'lipa80a'",
                "'lipa90a'",
                "'lipa90b'",
                "'nug12'",
                "'nug14'",
                "'nug16a'",
                "'nug16b'",
                "'nug17'",
                "'nug18'",
                "'nug20'",
                "'nug21'",
                "'nug22'",
                "'nug24'",
                "'nug25'",
                "'nug27'",
                "'nug28'",
                "'nug30'",
                "'rou12'",
                "'rou15'",
                "'rou20'",
                "'scr12'",
                "'scr15'",
                "'scr20'",
                "'sko42'",
                "'sko49'",
                "'sko56'",
                "'sko64'",
                "'sko72'",
                "'sko81'",
                "'sko90'",
                "'sko100a'",
                "'sko100b'",
                "'sko100c'",
                "'sko100d'",
                "'sko100e'",
                "'sko100f'",
                "'ste36b'",
                "'ste36c'",
                "'tai12a'",
                "'tai12b'",
                "'tai15a'",
                "'tai15b'",
                "'tai17a'",
                "'tai20a'",
                "'tai20b'",
                "'tai25a'",
                "'tai25b'",
                "'tai30a'",
                "'tai30b'",
                "'tai35a'",
                "'tai40a'",
                "'tai40b'",
                "'tai50a'",
                "'tai50b'",
                "'tai60a'",
                "'tai60b'",
                "'tai64c'",
                "'tai80a'",
                "'tai100a'",
                "'tai100b'",
                "'tai150b'",
                "'tai256c'",
                "'tho30'",
                "'tho40'",
                "'tho150'",
                "'wil50'",
                "'wil100'"
            ]
        ],
        "timeout": 60.0,
        "type": "track",
        "unit": "unit",
        "version": "7fd078571786b0045317452e802e6a9349ec55adc9aaa282a4aff71f97abbeef"
    },
    "optimize_zeros.Newton.time_newton": {
        "code": "class Newton:\n    def time_newton(self, func, meth):\n        newton(self.f, self.x0, args=(), fprime=self.f_1, fprime2=self.f_2)\n\n    def setup(self, func, meth):\n        self.x0 = 3\n        self.f_1 = None\n        self.f_2 = None\n        if func == 'f1':\n            self.f = lambda x: x ** 2 - 2 * x - 1\n            if meth in ('newton', 'halley'):\n                self.f_1 = lambda x: 2 * x - 2\n            if meth == 'halley':\n                self.f_2 = lambda x: 2.0 + 0 * x\n        else:\n            self.f = lambda x: exp(x) - cos(x)\n            if meth in ('newton', 'halley'):\n                self.f_1 = lambda x: exp(x) + sin(x)\n            if meth == 'halley':\n                self.f_2 = lambda x: exp(x) + cos(x)",
        "min_run_count": 2,
        "name": "optimize_zeros.Newton.time_newton",
        "number": 0,
        "param_names": [
            "test function",
            "solver"
        ],
        "params": [
            [
                "'f1'",
                "'f2'"
            ],
            [
                "'newton'",
                "'secant'",
                "'halley'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "2c7e7c8c9002fcceb6a5f95ad638eb0f73720bf302d480fa391416abc5f6dfc9",
        "warmup_time": -1
    },
    "optimize_zeros.NewtonArray.time_array_newton": {
        "code": "class NewtonArray:\n    def time_array_newton(self, vec, meth):\n    \n        def f(x, *a):\n            b = a[0] + x * a[3]\n            return a[1] - a[2] * (np.exp(b / a[5]) - 1.0) - b / a[4] - x\n    \n        def f_1(x, *a):\n            b = a[3] / a[5]\n            return -a[2] * np.exp(a[0] / a[5] + x * b) * b - a[3] / a[4] - 1\n    \n        def f_2(x, *a):\n            b = a[3] / a[5]\n            return -a[2] * np.exp(a[0] / a[5] + x * b) * b ** 2\n    \n        a0 = np.array([\n            5.32725221, 5.48673747, 5.49539973,\n            5.36387202, 4.80237316, 1.43764452,\n            5.23063958, 5.46094772, 5.50512718,\n            5.42046290\n        ])\n        a1 = (np.sin(range(10)) + 1.0) * 7.0\n        args = (a0, a1, 1e-09, 0.004, 10, 0.27456)\n        x0 = [7.0] * 10\n        self.fvec(f, x0, args=args, fprime=f_1, fprime2=f_2)\n\n    def setup(self, vec, meth):\n        if vec == 'loop':\n            if meth == 'newton':\n                self.fvec = lambda f, x0, args, fprime, fprime2: [\n                    newton(f, x, args=(a0, a1) + args[2:], fprime=fprime)\n                    for (x, a0, a1) in zip(x0, args[0], args[1])\n                ]\n            elif meth == 'halley':\n                self.fvec = lambda f, x0, args, fprime, fprime2: [\n                    newton(\n                        f, x, args=(a0, a1) + args[2:], fprime=fprime,\n                        fprime2=fprime2\n                    ) for (x, a0, a1) in zip(x0, args[0], args[1])\n                ]\n            else:\n                self.fvec = lambda f, x0, args, fprime, fprime2: [\n                    newton(f, x, args=(a0, a1) + args[2:]) for (x, a0, a1)\n                    in zip(x0, args[0], args[1])\n                ]\n        else:\n            if meth == 'newton':\n                self.fvec = lambda f, x0, args, fprime, fprime2: newton(\n                    f, x0, args=args, fprime=fprime\n                )\n            elif meth == 'halley':\n                self.fvec = newton\n            else:\n                self.fvec = lambda f, x0, args, fprime, fprime2: newton(\n                    f, x0, args=args\n                )",
        "min_run_count": 2,
        "name": "optimize_zeros.NewtonArray.time_array_newton",
        "number": 0,
        "param_names": [
            "vectorization",
            "solver"
        ],
        "params": [
            [
                "'loop'",
                "'array'"
            ],
            [
                "'newton'",
                "'secant'",
                "'halley'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "08e3d8401f54536bbfe96c467755557f8ebe99ce10bf63de17e8fe5d7229bf4d",
        "warmup_time": -1
    },
    "optimize_zeros.Zeros.time_zeros": {
        "code": "class Zeros:\n    def time_zeros(self, func, meth):\n        self.meth(self.func, self.a, self.b)\n\n    def setup(self, func, meth):\n        self.a = .5\n        self.b = sqrt(3)\n    \n        self.func = functions[fstrings.index(func)]\n        self.meth = methods[mstrings.index(meth)]",
        "min_run_count": 2,
        "name": "optimize_zeros.Zeros.time_zeros",
        "number": 0,
        "param_names": [
            "test function",
            "solver"
        ],
        "params": [
            [
                "'f2'",
                "'f3'",
                "'f4'",
                "'f5'",
                "'f6'"
            ],
            [
                "'cc.bisect'",
                "'cc.ridder'",
                "'cc.brenth'",
                "'cc.brentq'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e70efd439f371e19964039ab8d954254811da7754783c41cc71759ad0f59e24a",
        "warmup_time": -1
    },
    "peak_finding.FindPeaks.time_find_peaks": {
        "code": "class FindPeaks:\n    def time_find_peaks(self, distance):\n        find_peaks(self.x, distance=distance)\n\n    def setup(self, distance):\n        self.x = electrocardiogram()",
        "min_run_count": 2,
        "name": "peak_finding.FindPeaks.time_find_peaks",
        "number": 0,
        "param_names": [
            "distance"
        ],
        "params": [
            [
                "None",
                "8",
                "64",
                "512",
                "4096"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "69a82ba1236f6512a03a49fd386938b5f04df15b93f34eb5ac9b6b08a86e66e0",
        "warmup_time": -1
    },
    "peak_finding.PeakProminences.time_peak_prominences": {
        "code": "class PeakProminences:\n    def time_peak_prominences(self, wlen):\n        peak_prominences(self.x, self.peaks, wlen)\n\n    def setup(self, wlen):\n        self.x = electrocardiogram()\n        self.peaks = find_peaks(self.x)[0]",
        "min_run_count": 2,
        "name": "peak_finding.PeakProminences.time_peak_prominences",
        "number": 0,
        "param_names": [
            "wlen"
        ],
        "params": [
            [
                "None",
                "8",
                "64",
                "512",
                "4096"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "76d52d7d796caad16fcd0900dc178ef04ea504a0d89c87ce861cc44808ee06d5",
        "warmup_time": -1
    },
    "peak_finding.PeakWidths.time_peak_widths": {
        "code": "class PeakWidths:\n    def time_peak_widths(self, rel_height):\n        peak_widths(self.x, self.peaks, rel_height, self.prominence_data)\n\n    def setup(self, rel_height):\n        self.x = electrocardiogram()\n        self.peaks = find_peaks(self.x)[0]\n        self.prominence_data = peak_prominences(self.x, self.peaks)",
        "min_run_count": 2,
        "name": "peak_finding.PeakWidths.time_peak_widths",
        "number": 0,
        "param_names": [
            "rel_height"
        ],
        "params": [
            [
                "0",
                "0.25",
                "0.5",
                "0.75",
                "1"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "775a3e41b71d89f5c58cb2d36b19adaac830d6f9e21b6fa4b82f3bfc67dca1d3",
        "warmup_time": -1
    },
    "signal.CalculateWindowedFFT.time_coherence": {
        "code": "class CalculateWindowedFFT:\n    def time_coherence(self):\n        signal.coherence(self.x, self.y)\n\n    def setup(self):\n        np.random.seed(5678)\n        # Create some long arrays for computation\n        x = np.random.randn(2**20)\n        y = np.random.randn(2**20)\n        self.x = x\n        self.y = y",
        "min_run_count": 2,
        "name": "signal.CalculateWindowedFFT.time_coherence",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "264b03ada7f4710c1fac42e5f704c83e4456ffe9d30fd2a23be1511df8115022",
        "warmup_time": -1
    },
    "signal.CalculateWindowedFFT.time_csd": {
        "code": "class CalculateWindowedFFT:\n    def time_csd(self):\n        signal.csd(self.x, self.y)\n\n    def setup(self):\n        np.random.seed(5678)\n        # Create some long arrays for computation\n        x = np.random.randn(2**20)\n        y = np.random.randn(2**20)\n        self.x = x\n        self.y = y",
        "min_run_count": 2,
        "name": "signal.CalculateWindowedFFT.time_csd",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "aec73d92d2e6342b381c748a3af200838c3b8d2916207ffe20c42b322c6dada8",
        "warmup_time": -1
    },
    "signal.CalculateWindowedFFT.time_periodogram": {
        "code": "class CalculateWindowedFFT:\n    def time_periodogram(self):\n        signal.periodogram(self.x)\n\n    def setup(self):\n        np.random.seed(5678)\n        # Create some long arrays for computation\n        x = np.random.randn(2**20)\n        y = np.random.randn(2**20)\n        self.x = x\n        self.y = y",
        "min_run_count": 2,
        "name": "signal.CalculateWindowedFFT.time_periodogram",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e9722853e1c16a747daaa48d2f6f5d92ab20479788cec7957a4842cb0ff65c3c",
        "warmup_time": -1
    },
    "signal.CalculateWindowedFFT.time_spectrogram": {
        "code": "class CalculateWindowedFFT:\n    def time_spectrogram(self):\n        signal.spectrogram(self.x)\n\n    def setup(self):\n        np.random.seed(5678)\n        # Create some long arrays for computation\n        x = np.random.randn(2**20)\n        y = np.random.randn(2**20)\n        self.x = x\n        self.y = y",
        "min_run_count": 2,
        "name": "signal.CalculateWindowedFFT.time_spectrogram",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ad8b14343bc83e0ac6baabb34c10edf2b8ff25adbf2c5f0b54365f8223ab35ca",
        "warmup_time": -1
    },
    "signal.CalculateWindowedFFT.time_welch": {
        "code": "class CalculateWindowedFFT:\n    def time_welch(self):\n        signal.welch(self.x)\n\n    def setup(self):\n        np.random.seed(5678)\n        # Create some long arrays for computation\n        x = np.random.randn(2**20)\n        y = np.random.randn(2**20)\n        self.x = x\n        self.y = y",
        "min_run_count": 2,
        "name": "signal.CalculateWindowedFFT.time_welch",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a250d739676f9ee24c1c85850424941a65cbac0c01d89b9d08942043e805b679",
        "warmup_time": -1
    },
    "signal.Convolve.time_convolve": {
        "code": "class Convolve:\n    def time_convolve(self, mode):\n        for a, b in self.pairs['1d']:\n            if b.shape[0] > a.shape[0]:\n                continue\n            signal.convolve(a, b, mode=mode)\n\n    def setup(self, mode):\n        np.random.seed(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = {'1d': [], '2d': []}\n        for ma, nb in product((1, 2, 8, 13, 30, 36, 50, 75), repeat=2):\n            a = np.random.randn(ma)\n            b = np.random.randn(nb)\n            pairs['1d'].append((a, b))\n    \n        for n_image in [256, 512, 1024]:\n            for n_kernel in [3, 5, 7]:\n                x = np.random.randn(n_image, n_image)\n                h = np.random.randn(n_kernel, n_kernel)\n                pairs['2d'].append((x, h))\n        self.pairs = pairs",
        "min_run_count": 2,
        "name": "signal.Convolve.time_convolve",
        "number": 0,
        "param_names": [
            "mode"
        ],
        "params": [
            [
                "'full'",
                "'valid'",
                "'same'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6e5205b096de1044d197896439360edbe41af5ac786a3667214b8cd0ffddc9fd",
        "warmup_time": -1
    },
    "signal.Convolve.time_convolve2d": {
        "code": "class Convolve:\n    def time_convolve2d(self, mode):\n        for a, b in self.pairs['2d']:\n            if mode == 'valid':\n                if b.shape[0] > a.shape[0] or b.shape[1] > a.shape[1]:\n                    continue\n            signal.convolve(a, b, mode=mode)\n\n    def setup(self, mode):\n        np.random.seed(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = {'1d': [], '2d': []}\n        for ma, nb in product((1, 2, 8, 13, 30, 36, 50, 75), repeat=2):\n            a = np.random.randn(ma)\n            b = np.random.randn(nb)\n            pairs['1d'].append((a, b))\n    \n        for n_image in [256, 512, 1024]:\n            for n_kernel in [3, 5, 7]:\n                x = np.random.randn(n_image, n_image)\n                h = np.random.randn(n_kernel, n_kernel)\n                pairs['2d'].append((x, h))\n        self.pairs = pairs",
        "min_run_count": 2,
        "name": "signal.Convolve.time_convolve2d",
        "number": 0,
        "param_names": [
            "mode"
        ],
        "params": [
            [
                "'full'",
                "'valid'",
                "'same'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "13f7c2529a3fabd672ef5be73b2a9db45e7f3d6906fba6639979bd063fe396d9",
        "warmup_time": -1
    },
    "signal.Convolve.time_correlate": {
        "code": "class Convolve:\n    def time_correlate(self, mode):\n        for a, b in self.pairs['1d']:\n            if b.shape[0] > a.shape[0]:\n                continue\n            signal.correlate(a, b, mode=mode)\n\n    def setup(self, mode):\n        np.random.seed(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = {'1d': [], '2d': []}\n        for ma, nb in product((1, 2, 8, 13, 30, 36, 50, 75), repeat=2):\n            a = np.random.randn(ma)\n            b = np.random.randn(nb)\n            pairs['1d'].append((a, b))\n    \n        for n_image in [256, 512, 1024]:\n            for n_kernel in [3, 5, 7]:\n                x = np.random.randn(n_image, n_image)\n                h = np.random.randn(n_kernel, n_kernel)\n                pairs['2d'].append((x, h))\n        self.pairs = pairs",
        "min_run_count": 2,
        "name": "signal.Convolve.time_correlate",
        "number": 0,
        "param_names": [
            "mode"
        ],
        "params": [
            [
                "'full'",
                "'valid'",
                "'same'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7db23a1a5078e3931011fdab6e15fccb1278a268d90c2426709d1ec7292c80d2",
        "warmup_time": -1
    },
    "signal.Convolve.time_correlate2d": {
        "code": "class Convolve:\n    def time_correlate2d(self, mode):\n        for a, b in self.pairs['2d']:\n            if mode == 'valid':\n                if b.shape[0] > a.shape[0] or b.shape[1] > a.shape[1]:\n                    continue\n            signal.correlate(a, b, mode=mode)\n\n    def setup(self, mode):\n        np.random.seed(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = {'1d': [], '2d': []}\n        for ma, nb in product((1, 2, 8, 13, 30, 36, 50, 75), repeat=2):\n            a = np.random.randn(ma)\n            b = np.random.randn(nb)\n            pairs['1d'].append((a, b))\n    \n        for n_image in [256, 512, 1024]:\n            for n_kernel in [3, 5, 7]:\n                x = np.random.randn(n_image, n_image)\n                h = np.random.randn(n_kernel, n_kernel)\n                pairs['2d'].append((x, h))\n        self.pairs = pairs",
        "min_run_count": 2,
        "name": "signal.Convolve.time_correlate2d",
        "number": 0,
        "param_names": [
            "mode"
        ],
        "params": [
            [
                "'full'",
                "'valid'",
                "'same'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d18f8d1fd5ee4ab7bd4fa3144ede0e0fa647bfe95f9eb5fcd5a7a7d7ac7fee7d",
        "warmup_time": -1
    },
    "signal.Convolve2D.time_convolve2d": {
        "code": "class Convolve2D:\n    def time_convolve2d(self, mode, boundary):\n        for a, b in self.pairs:\n            if mode == 'valid':\n                if b.shape[0] > a.shape[0] or b.shape[1] > a.shape[1]:\n                    continue\n            signal.convolve2d(a, b, mode=mode, boundary=boundary)\n\n    def setup(self, mode, boundary):\n        np.random.seed(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = []\n        for ma, na, mb, nb in product((8, 13, 30, 36), repeat=4):\n            a = np.random.randn(ma, na)\n            b = np.random.randn(mb, nb)\n            pairs.append((a, b))\n        self.pairs = pairs",
        "min_run_count": 2,
        "name": "signal.Convolve2D.time_convolve2d",
        "number": 0,
        "param_names": [
            "mode",
            "boundary"
        ],
        "params": [
            [
                "'full'",
                "'valid'",
                "'same'"
            ],
            [
                "'fill'",
                "'wrap'",
                "'symm'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "83b0d2a83005c6faf9c15d7244ad60c642a8c81e35ad28d9db69b900fcf0d497",
        "warmup_time": -1
    },
    "signal.Convolve2D.time_correlate2d": {
        "code": "class Convolve2D:\n    def time_correlate2d(self, mode, boundary):\n        for a, b in self.pairs:\n            if mode == 'valid':\n                if b.shape[0] > a.shape[0] or b.shape[1] > a.shape[1]:\n                    continue\n            signal.correlate2d(a, b, mode=mode, boundary=boundary)\n\n    def setup(self, mode, boundary):\n        np.random.seed(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = []\n        for ma, na, mb, nb in product((8, 13, 30, 36), repeat=4):\n            a = np.random.randn(ma, na)\n            b = np.random.randn(mb, nb)\n            pairs.append((a, b))\n        self.pairs = pairs",
        "min_run_count": 2,
        "name": "signal.Convolve2D.time_correlate2d",
        "number": 0,
        "param_names": [
            "mode",
            "boundary"
        ],
        "params": [
            [
                "'full'",
                "'valid'",
                "'same'"
            ],
            [
                "'fill'",
                "'wrap'",
                "'symm'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5054b95a37d5aa88f61b0f3b779a37c3e398b1236b69015fe0e27075cea2acca",
        "warmup_time": -1
    },
    "signal.FFTConvolve.time_convolve2d": {
        "code": "class FFTConvolve:\n    def time_convolve2d(self, mode, size):\n        signal.fftconvolve(self.a, self.b, mode=mode)\n\n    def setup(self, mode, size):\n        np.random.seed(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = []\n        self.a = np.random.randn(size[0])\n        self.b = np.random.randn(size[1])",
        "min_run_count": 2,
        "name": "signal.FFTConvolve.time_convolve2d",
        "number": 0,
        "param_names": [
            "mode",
            "size"
        ],
        "params": [
            [
                "'full'",
                "'valid'",
                "'same'"
            ],
            [
                "(1, 1)",
                "(2, 1)",
                "(2, 2)",
                "(8, 1)",
                "(8, 2)",
                "(8, 8)",
                "(36, 1)",
                "(36, 2)",
                "(36, 8)",
                "(36, 36)",
                "(60, 1)",
                "(60, 2)",
                "(60, 8)",
                "(60, 36)",
                "(60, 60)",
                "(150, 1)",
                "(150, 2)",
                "(150, 8)",
                "(150, 36)",
                "(150, 60)",
                "(150, 150)",
                "(200, 1)",
                "(200, 2)",
                "(200, 8)",
                "(200, 36)",
                "(200, 60)",
                "(200, 150)",
                "(200, 200)",
                "(500, 1)",
                "(500, 2)",
                "(500, 8)",
                "(500, 36)",
                "(500, 60)",
                "(500, 150)",
                "(500, 200)",
                "(500, 500)"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4b766e1835e4c0d127f12d845e7e743520a027ce660830a7c68d345ee617e27d",
        "warmup_time": -1
    },
    "signal.FIRLS.time_firls": {
        "code": "class FIRLS:\n    def time_firls(self, n, edges):\n        signal.firls(n, (0,) + edges + (1,), [1, 1, 0, 0])",
        "min_run_count": 2,
        "name": "signal.FIRLS.time_firls",
        "number": 0,
        "param_names": [
            "n",
            "edges"
        ],
        "params": [
            [
                "21",
                "101",
                "1001",
                "2001"
            ],
            [
                "(0.1, 0.9)",
                "(0.01, 0.99)"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "2f5dd858f18576cf308f8bd907d6a2ba6ac434e7e9e60212a00b6adb24baa7f4",
        "warmup_time": -1
    },
    "signal.LTI.time_bode": {
        "code": "class LTI:\n    def time_bode(self):\n        signal.bode(self.system)\n\n    def setup(self):\n        self.system = signal.lti(1.0, [1, 0, 1])\n        self.t = np.arange(0, 100, 0.5)\n        self.u = np.sin(2 * self.t)",
        "min_run_count": 2,
        "name": "signal.LTI.time_bode",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9b6900694dcd1678ace232e739006f5edb8fd1ab439b2641c656a52a6a3570a5",
        "warmup_time": -1
    },
    "signal.LTI.time_impulse": {
        "code": "class LTI:\n    def time_impulse(self):\n        signal.impulse(self.system, T=self.t)\n\n    def setup(self):\n        self.system = signal.lti(1.0, [1, 0, 1])\n        self.t = np.arange(0, 100, 0.5)\n        self.u = np.sin(2 * self.t)",
        "min_run_count": 2,
        "name": "signal.LTI.time_impulse",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "36ed9a1159c7a7896d49780e31bf765fedd30ff0e5170d6f5a90d31286ffdd04",
        "warmup_time": -1
    },
    "signal.LTI.time_lsim": {
        "code": "class LTI:\n    def time_lsim(self):\n        signal.lsim(self.system, self.u, self.t)\n\n    def setup(self):\n        self.system = signal.lti(1.0, [1, 0, 1])\n        self.t = np.arange(0, 100, 0.5)\n        self.u = np.sin(2 * self.t)",
        "min_run_count": 2,
        "name": "signal.LTI.time_lsim",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ab2f127be1b0ae823db19367021a5a82ca4d3f9b41c29574f98efb3a4a9a48cc",
        "warmup_time": -1
    },
    "signal.LTI.time_lsim2": {
        "code": "class LTI:\n    def time_lsim2(self):\n        signal.lsim2(self.system, self.u, self.t)\n\n    def setup(self):\n        self.system = signal.lti(1.0, [1, 0, 1])\n        self.t = np.arange(0, 100, 0.5)\n        self.u = np.sin(2 * self.t)",
        "min_run_count": 2,
        "name": "signal.LTI.time_lsim2",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5d54047fba8c4fd772104b076d52ba13045b21326e50ea9124871ff3a3924b6e",
        "warmup_time": -1
    },
    "signal.LTI.time_step": {
        "code": "class LTI:\n    def time_step(self):\n        signal.step(self.system, T=self.t)\n\n    def setup(self):\n        self.system = signal.lti(1.0, [1, 0, 1])\n        self.t = np.arange(0, 100, 0.5)\n        self.u = np.sin(2 * self.t)",
        "min_run_count": 2,
        "name": "signal.LTI.time_step",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "02de19e2a7d49a4b5349af8a4765271980b219a4c890120b26195f0cae2578c4",
        "warmup_time": -1
    },
    "signal.OAConvolve.time_convolve2d": {
        "code": "class OAConvolve:\n    def time_convolve2d(self, mode, size):\n        signal.oaconvolve(self.a, self.b, mode=mode)\n\n    def setup(self, mode, size):\n        np.random.seed(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = []\n        self.a = np.random.randn(size[0])\n        self.b = np.random.randn(size[1])",
        "min_run_count": 2,
        "name": "signal.OAConvolve.time_convolve2d",
        "number": 0,
        "param_names": [
            "mode",
            "size"
        ],
        "params": [
            [
                "'full'",
                "'valid'",
                "'same'"
            ],
            [
                "(200, 40)",
                "(3000, 40)",
                "(3000, 200)"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c3f173cb4145f5a080236def2cc63422a9d7ba6c1d062b9614ccaf6cba977a5c",
        "warmup_time": -1
    },
    "signal.Resample.time_complex": {
        "code": "class Resample:\n    def time_complex(self, N, num):\n        signal.resample(self.y + 0j, num)\n\n    def setup(self, N, num):\n        x = np.linspace(0, 10, N, endpoint=False)\n        self.y = np.cos(-x**2/6.0)",
        "min_run_count": 2,
        "name": "signal.Resample.time_complex",
        "number": 0,
        "param_names": [
            "N",
            "num"
        ],
        "params": [
            [
                "977",
                "9973",
                "16384",
                "65536"
            ],
            [
                "977",
                "9973",
                "16384",
                "65536"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "55c642f290bf16f0ff9e966c50e70d48705973f05959f5008075efe985777bd9",
        "warmup_time": -1
    },
    "signal.Resample.time_real": {
        "code": "class Resample:\n    def time_real(self, N, num):\n        signal.resample(self.y, num)\n\n    def setup(self, N, num):\n        x = np.linspace(0, 10, N, endpoint=False)\n        self.y = np.cos(-x**2/6.0)",
        "min_run_count": 2,
        "name": "signal.Resample.time_real",
        "number": 0,
        "param_names": [
            "N",
            "num"
        ],
        "params": [
            [
                "977",
                "9973",
                "16384",
                "65536"
            ],
            [
                "977",
                "9973",
                "16384",
                "65536"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5ab4afe1c564b74994385ce0419ea640e36628bce8d72e88b411126057acd53e",
        "warmup_time": -1
    },
    "signal.Upfirdn1D.time_upfirdn1d": {
        "code": "class Upfirdn1D:\n    def time_upfirdn1d(self, up, down):\n        for h, x in self.pairs:\n            signal.upfirdn(h, x, up=up, down=down)\n\n    def setup(self, up, down):\n        np.random.seed(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = []\n        for nfilt in [8, ]:\n            for n in [32, 128, 512, 2048]:\n                h = np.random.randn(nfilt)\n                x = np.random.randn(n)\n                pairs.append((h, x))\n    \n        self.pairs = pairs",
        "min_run_count": 2,
        "name": "signal.Upfirdn1D.time_upfirdn1d",
        "number": 0,
        "param_names": [
            "up",
            "down"
        ],
        "params": [
            [
                "1",
                "4"
            ],
            [
                "1",
                "4"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c00030e1ba6fc22727cfb6ebd267b73fab61f120c4ba6b02c62f000713d7b816",
        "warmup_time": -1
    },
    "signal.Upfirdn2D.time_upfirdn2d": {
        "code": "class Upfirdn2D:\n    def time_upfirdn2d(self, up, down, axis):\n        for h, x in self.pairs:\n            signal.upfirdn(h, x, up=up, down=down, axis=axis)\n\n    def setup(self, up, down, axis):\n        np.random.seed(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = []\n        for nfilt in [8, ]:\n            for n in [32, 128, 512]:\n                h = np.random.randn(nfilt)\n                x = np.random.randn(n, n)\n                pairs.append((h, x))\n    \n        self.pairs = pairs",
        "min_run_count": 2,
        "name": "signal.Upfirdn2D.time_upfirdn2d",
        "number": 0,
        "param_names": [
            "up",
            "down",
            "axis"
        ],
        "params": [
            [
                "1",
                "4"
            ],
            [
                "1",
                "4"
            ],
            [
                "0",
                "-1"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7a2c0609a0663adcfa60a84963455d890e488216a74e9250a43d2f116f92860f",
        "warmup_time": -1
    },
    "signal_filtering.Decimate.time_decimate": {
        "code": "class Decimate:\n    def time_decimate(self, q, ftype, zero_phase):\n        decimate(self.sig, q, ftype=ftype, zero_phase=zero_phase)\n\n    def setup(self, q, ftype, zero_phase):\n        np.random.seed(123456)\n        sample_rate = 10000.\n        t = np.arange(int(1e6), dtype=np.float64) / sample_rate\n        self.sig = np.sin(2*np.pi*500*t) + 0.3 * np.sin(2*np.pi*4e3*t)",
        "min_run_count": 2,
        "name": "signal_filtering.Decimate.time_decimate",
        "number": 0,
        "param_names": [
            "q",
            "ftype",
            "zero_phase"
        ],
        "params": [
            [
                "2",
                "10",
                "30"
            ],
            [
                "'iir'",
                "'fir'"
            ],
            [
                "True",
                "False"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "aae23358cbe3088f5e199c70a09eec3957561c00aa278ce63bace7052f266e3f",
        "warmup_time": -1
    },
    "signal_filtering.Lfilter.time_lfilter": {
        "code": "class Lfilter:\n    def time_lfilter(self, n_samples, numtaps):\n        lfilter(self.coeff, 1.0, self.sig)\n\n    def setup(self, n_samples, numtaps):\n        np.random.seed(125678)\n        sample_rate = 25000.\n        t = np.arange(n_samples, dtype=np.float64) / sample_rate\n        nyq_rate = sample_rate / 2.\n        cutoff_hz = 3000.0\n        self.sig = np.sin(2*np.pi*500*t) + 0.3 * np.sin(2*np.pi*11e3*t)\n        self.coeff = firwin(numtaps, cutoff_hz/nyq_rate)",
        "min_run_count": 2,
        "name": "signal_filtering.Lfilter.time_lfilter",
        "number": 0,
        "param_names": [
            "n_samples",
            "numtaps"
        ],
        "params": [
            [
                "1000.0",
                "50000.0",
                "1000000.0"
            ],
            [
                "9",
                "23",
                "51"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d30c400692d02cd1bbe665e3146724b8d0c3ba0b274d9816d543808508aecd6e",
        "warmup_time": -1
    },
    "signal_filtering.MedFilt2D.peakmem_medfilt2d": {
        "code": "class MedFilt2D:\n    def peakmem_medfilt2d(self, threads):\n        self._medfilt2d(threads)\n\n    def setup(self, threads):\n        np.random.seed(8176)\n        self.chunks = np.array_split(np.random.randn(250, 349), threads)",
        "name": "signal_filtering.MedFilt2D.peakmem_medfilt2d",
        "param_names": [
            "threads"
        ],
        "params": [
            [
                "1",
                "2",
                "4"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "6b344fcc0b5bb9e118364792e1482bd7d9b9bd59d0bb3522f3746f9f58c770bf"
    },
    "signal_filtering.MedFilt2D.time_medfilt2d": {
        "code": "class MedFilt2D:\n    def time_medfilt2d(self, threads):\n        self._medfilt2d(threads)\n\n    def setup(self, threads):\n        np.random.seed(8176)\n        self.chunks = np.array_split(np.random.randn(250, 349), threads)",
        "min_run_count": 2,
        "name": "signal_filtering.MedFilt2D.time_medfilt2d",
        "number": 0,
        "param_names": [
            "threads"
        ],
        "params": [
            [
                "1",
                "2",
                "4"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "edcdb08ab698cf85a32652afb24dd6805eaf34ea02c9407cbd3e546e0a1b2a15",
        "warmup_time": -1
    },
    "signal_filtering.ParallelSosfilt.time_sosfilt": {
        "code": "class ParallelSosfilt:\n    def time_sosfilt(self, n_samples, threads):\n        with ThreadPoolExecutor(max_workers=threads) as pool:\n            futures = []\n            for i in range(threads):\n                futures.append(pool.submit(sosfilt, self.filt, self.chunks[i]))\n    \n            wait(futures)\n\n    def setup(self, n_samples, threads):\n        self.filt = butter(8, 8e-6, \"lowpass\", output=\"sos\")\n        self.data = np.arange(int(n_samples) * 3000).reshape(int(n_samples), 3000)\n        self.chunks = np.array_split(self.data, threads)",
        "min_run_count": 2,
        "name": "signal_filtering.ParallelSosfilt.time_sosfilt",
        "number": 0,
        "param_names": [
            "n_samples",
            "threads"
        ],
        "params": [
            [
                "1000.0",
                "10000.0"
            ],
            [
                "1",
                "2",
                "4"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 100,
        "type": "time",
        "unit": "seconds",
        "version": "f13929d19d7ccbc2e5176b5f1a89c329dcd83713060a4b13b2953e15f49036ee",
        "warmup_time": -1
    },
    "signal_filtering.Sosfilt.time_sosfilt_basic": {
        "code": "class Sosfilt:\n    def time_sosfilt_basic(self, n_samples, order):\n        sosfilt(self.sos, self.y)\n\n    def setup(self, n_samples, order):\n        self.sos = butter(order, [0.1575, 0.1625], 'band', output='sos')\n        self.y = np.random.RandomState(0).randn(n_samples)",
        "min_run_count": 2,
        "name": "signal_filtering.Sosfilt.time_sosfilt_basic",
        "number": 0,
        "param_names": [
            "n_samples",
            "order"
        ],
        "params": [
            [
                "1000",
                "1000000"
            ],
            [
                "6",
                "20"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e5fc1f17e52700fc1f517544303ef4a7ebe97ff269f30c6d020d86540f0ff93f",
        "warmup_time": -1
    },
    "sparse.Arithmetic.time_arithmetic": {
        "code": "class Arithmetic:\n    def time_arithmetic(self, format, XY, op):\n        self.fn(self.y)\n\n    def setup(self, format, XY, op):\n        matrices = dict(A=poisson2d(250, format=format),\n                        B=poisson2d(250, format=format)**2)\n    \n        x = matrices[XY[0]]\n        self.y = matrices[XY[1]]\n        self.fn = getattr(x, op)\n        self.fn(self.y)  # warmup",
        "min_run_count": 2,
        "name": "sparse.Arithmetic.time_arithmetic",
        "number": 0,
        "param_names": [
            "format",
            "XY",
            "op"
        ],
        "params": [
            [
                "'csr'"
            ],
            [
                "'AA'",
                "'AB'",
                "'BA'",
                "'BB'"
            ],
            [
                "'__add__'",
                "'__sub__'",
                "'multiply'",
                "'__mul__'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "83450868d03ffee8f8a2ee6f9f4232ba297f343516d53597fa4b8d544e8700ab",
        "warmup_time": -1
    },
    "sparse.BlockDiagDenseConstruction.time_block_diag": {
        "code": "class BlockDiagDenseConstruction:\n    def time_block_diag(self, num_matrices):\n        sparse.block_diag(self.matrices)\n\n    def setup(self, num_matrices):\n        self.matrices = []\n        for i in range(num_matrices):\n            rows = np.random.randint(1, 4)\n            columns = np.random.randint(1, 4)\n            mat = np.random.randint(0, 10, (rows, columns))\n            self.matrices.append(mat)",
        "min_run_count": 2,
        "name": "sparse.BlockDiagDenseConstruction.time_block_diag",
        "number": 0,
        "param_names": [
            "num_matrices"
        ],
        "params": [
            [
                "1000",
                "5000",
                "10000",
                "15000",
                "20000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7d89c60d3f9a3f896db0a137cec267e26b32073fb884c7286d8ccb64ac4cf2cc",
        "warmup_time": -1
    },
    "sparse.BlockDiagSparseConstruction.time_block_diag": {
        "code": "class BlockDiagSparseConstruction:\n    def time_block_diag(self, num_matrices):\n        sparse.block_diag(self.matrices)\n\n    def setup(self, num_matrices):\n        self.matrices = []\n        for i in range(num_matrices):\n            rows = np.random.randint(1, 20)\n            columns = np.random.randint(1, 20)\n            mat = np.random.randint(0, 10, (rows, columns))\n            self.matrices.append(mat)",
        "min_run_count": 2,
        "name": "sparse.BlockDiagSparseConstruction.time_block_diag",
        "number": 0,
        "param_names": [
            "num_matrices"
        ],
        "params": [
            [
                "100",
                "500",
                "1000",
                "1500",
                "2000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4a1e400ac75879f27f5430484625271ce5c67ad81ca2d26ce753d2c0e690d14d",
        "warmup_time": -1
    },
    "sparse.Construction.time_construction": {
        "code": "class Construction:\n    def time_construction(self, name, format):\n        T = self.cls(self.A.shape)\n        for i, j, v in zip(self.A.row, self.A.col, self.A.data):\n            T[i, j] = v\n\n    def setup(self, name, format):\n        if name == 'Empty':\n            self.A = coo_matrix((10000, 10000))\n        elif name == 'Identity':\n            self.A = sparse.eye(10000, format='coo')\n        else:\n            self.A = poisson2d(100, format='coo')\n    \n        formats = {'lil': lil_matrix, 'dok': dok_matrix}\n        self.cls = formats[format]",
        "min_run_count": 2,
        "name": "sparse.Construction.time_construction",
        "number": 0,
        "param_names": [
            "matrix",
            "format"
        ],
        "params": [
            [
                "'Empty'",
                "'Identity'",
                "'Poisson5pt'"
            ],
            [
                "'lil'",
                "'dok'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4051443d954b347f4100b6b10b48436673e8432d95dfcbe0a104249d96a3174f",
        "warmup_time": -1
    },
    "sparse.Conversion.time_conversion": {
        "code": "class Conversion:\n    def time_conversion(self, fromfmt, tofmt):\n        self.fn()\n\n    def setup(self, fromfmt, tofmt):\n        base = poisson2d(100, format=fromfmt)\n    \n        try:\n            self.fn = getattr(base, 'to' + tofmt)\n        except Exception:\n            def fn():\n                raise RuntimeError()\n            self.fn = fn",
        "min_run_count": 2,
        "name": "sparse.Conversion.time_conversion",
        "number": 0,
        "param_names": [
            "from_format",
            "to_format"
        ],
        "params": [
            [
                "'csr'",
                "'csc'",
                "'coo'",
                "'dia'",
                "'lil'",
                "'dok'",
                "'bsr'"
            ],
            [
                "'csr'",
                "'csc'",
                "'coo'",
                "'dia'",
                "'lil'",
                "'dok'",
                "'bsr'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "fb2157b5f6933e49f97c0545b2f85985bc912c4436d81538ead45e721ce9404e",
        "warmup_time": -1
    },
    "sparse.Densify.time_toarray": {
        "code": "class Densify:\n    def time_toarray(self, format, order):\n        self.X.toarray(order=order)\n\n    def setup(self, format, order):\n        warnings.simplefilter('ignore', SparseEfficiencyWarning)\n        self.X = sparse.rand(1000, 1000, format=format, density=0.01)",
        "min_run_count": 2,
        "name": "sparse.Densify.time_toarray",
        "number": 0,
        "param_names": [
            "format",
            "order"
        ],
        "params": [
            [
                "'dia'",
                "'csr'",
                "'csc'",
                "'dok'",
                "'lil'",
                "'coo'",
                "'bsr'"
            ],
            [
                "'C'",
                "'F'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "2fbf492ec800b982946a62785beda803460b913cc80080043a5d407025893b2b",
        "warmup_time": -1
    },
    "sparse.Diagonal.time_diagonal": {
        "code": "class Diagonal:\n    def time_diagonal(self, density, format):\n        self.X.diagonal()\n\n    def setup(self, density, format):\n        n = 1000\n        if format == 'dok' and n * density >= 500:\n            raise NotImplementedError()\n    \n        warnings.simplefilter('ignore', SparseEfficiencyWarning)\n    \n        self.X = sparse.rand(n, n, format=format, density=density)",
        "min_run_count": 2,
        "name": "sparse.Diagonal.time_diagonal",
        "number": 0,
        "param_names": [
            "density",
            "format"
        ],
        "params": [
            [
                "0.01",
                "0.1",
                "0.5"
            ],
            [
                "'csr'",
                "'csc'",
                "'coo'",
                "'lil'",
                "'dok'",
                "'dia'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d84f53fdc6abc208136c8ce48ca156370f6803562f6908eb6bd1424f50310cf1",
        "warmup_time": -1
    },
    "sparse.Getset.time_fancy_getitem": {
        "code": "class Getset:\n    def time_fancy_getitem(self, N, sparsity_pattern, format):\n        self.m[self.i, self.j]\n\n    def setup(self, N, sparsity_pattern, format):\n        if format == 'dok' and N > 500:\n            raise NotImplementedError()\n    \n        self.A = rand(1000, 1000, density=1e-5)\n    \n        A = self.A\n        N = int(N)\n    \n        # indices to assign to\n        i, j = [], []\n        while len(i) < N:\n            n = N - len(i)\n            ip = numpy.random.randint(0, A.shape[0], size=n)\n            jp = numpy.random.randint(0, A.shape[1], size=n)\n            i = numpy.r_[i, ip]\n            j = numpy.r_[j, jp]\n        v = numpy.random.rand(n)\n    \n        if N == 1:\n            i = int(i)\n            j = int(j)\n            v = float(v)\n    \n        base = A.asformat(format)\n    \n        self.m = base.copy()\n        self.i = i\n        self.j = j\n        self.v = v",
        "min_run_count": 2,
        "name": "sparse.Getset.time_fancy_getitem",
        "number": 0,
        "param_names": [
            "N",
            "sparsity pattern",
            "format"
        ],
        "params": [
            [
                "1",
                "10",
                "100",
                "1000",
                "10000"
            ],
            [
                "'different'",
                "'same'"
            ],
            [
                "'csr'",
                "'csc'",
                "'lil'",
                "'dok'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "db8f9fd8e5a7a1e507d59c8f0cca32bdfe0a50d43dde3bced0592759da801ea2",
        "warmup_time": -1
    },
    "sparse.Getset.track_fancy_setitem": {
        "code": "class Getset:\n    def track_fancy_setitem(self, N, sparsity_pattern, format):\n        def kernel(A, i, j, v):\n            A[i, j] = v\n    \n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore', SparseEfficiencyWarning)\n            return self._timeit(kernel, sparsity_pattern == 'different')\n\n    def setup(self, N, sparsity_pattern, format):\n        if format == 'dok' and N > 500:\n            raise NotImplementedError()\n    \n        self.A = rand(1000, 1000, density=1e-5)\n    \n        A = self.A\n        N = int(N)\n    \n        # indices to assign to\n        i, j = [], []\n        while len(i) < N:\n            n = N - len(i)\n            ip = numpy.random.randint(0, A.shape[0], size=n)\n            jp = numpy.random.randint(0, A.shape[1], size=n)\n            i = numpy.r_[i, ip]\n            j = numpy.r_[j, jp]\n        v = numpy.random.rand(n)\n    \n        if N == 1:\n            i = int(i)\n            j = int(j)\n            v = float(v)\n    \n        base = A.asformat(format)\n    \n        self.m = base.copy()\n        self.i = i\n        self.j = j\n        self.v = v",
        "name": "sparse.Getset.track_fancy_setitem",
        "param_names": [
            "N",
            "sparsity pattern",
            "format"
        ],
        "params": [
            [
                "1",
                "10",
                "100",
                "1000",
                "10000"
            ],
            [
                "'different'",
                "'same'"
            ],
            [
                "'csr'",
                "'csc'",
                "'lil'",
                "'dok'"
            ]
        ],
        "timeout": 60.0,
        "type": "track",
        "unit": "seconds",
        "version": "d0a713aadd72a514aeaa359421b2323d0781bf2626876b398b7c667ccebabffd"
    },
    "sparse.Iteration.time_iteration": {
        "code": "class Iteration:\n    def time_iteration(self, density, format):\n        for row in self.X:\n            pass\n\n    def setup(self, density, format):\n        n = 500\n        k = 1000\n        self.X = sparse.rand(n, k, format=format, density=density)",
        "min_run_count": 2,
        "name": "sparse.Iteration.time_iteration",
        "number": 0,
        "param_names": [
            "density",
            "format"
        ],
        "params": [
            [
                "0.05",
                "0.01"
            ],
            [
                "'csr'",
                "'csc'",
                "'lil'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "fbefcb7469069e5c8675880657b3349b1035a37fbda9ae186e6f9351967c2ee4",
        "warmup_time": -1
    },
    "sparse.Matmul.time_large": {
        "code": "class Matmul:\n    def time_large(self):\n        for i in range(100):\n            self.matrix1 * self.matrix2\n\n    def setup(self):\n        H1, W1 = 1, 100000\n        H2, W2 = W1, 1000\n        C1 = 10\n        C2 = 1000000\n    \n        random.seed(0)\n    \n        i = random.randint(H1, size=C1)\n        j = random.randint(W1, size=C1)\n        data = random.rand(C1)\n        self.matrix1 = coo_matrix((data, (i, j)), shape=(H1, W1)).tocsr()\n    \n        i = random.randint(H2, size=C2)\n        j = random.randint(W2, size=C2)\n        data = random.rand(C2)\n        self.matrix2 = coo_matrix((data, (i, j)), shape=(H2, W2)).tocsr()",
        "min_run_count": 2,
        "name": "sparse.Matmul.time_large",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "33aee08539377a7cb0fabaf0d9ff9d6d80079a428873f451b378c39f6ead48cb",
        "warmup_time": -1
    },
    "sparse.Matvec.time_matvec": {
        "code": "class Matvec:\n    def time_matvec(self, matrix, format):\n        self.A * self.x\n\n    def setup(self, matrix, format):\n        if matrix == 'Identity':\n            if format in ('lil', 'dok'):\n                raise NotImplementedError()\n            self.A = sparse.eye(10000, 10000, format=format)\n        elif matrix == 'Poisson5pt':\n            self.A = poisson2d(300, format=format)\n        elif matrix == 'Block2x2':\n            if format not in ('csr', 'bsr'):\n                raise NotImplementedError()\n            b = (2, 2)\n            self.A = sparse.kron(poisson2d(150),\n                                 ones(b)).tobsr(blocksize=b).asformat(format)\n        elif matrix == 'Block3x3':\n            if format not in ('csr', 'bsr'):\n                raise NotImplementedError()\n            b = (3, 3)\n            self.A = sparse.kron(poisson2d(100),\n                                 ones(b)).tobsr(blocksize=b).asformat(format)\n        else:\n            raise NotImplementedError()\n    \n        self.x = ones(self.A.shape[1], dtype=float)",
        "min_run_count": 2,
        "name": "sparse.Matvec.time_matvec",
        "number": 0,
        "param_names": [
            "matrix",
            "format"
        ],
        "params": [
            [
                "'Identity'",
                "'Poisson5pt'",
                "'Block2x2'",
                "'Block3x3'"
            ],
            [
                "'dia'",
                "'csr'",
                "'csc'",
                "'dok'",
                "'lil'",
                "'coo'",
                "'bsr'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8becb02aa64d32a3defee8b0229f7e63128c6ca3463a313a08af8448d05c017d",
        "warmup_time": -1
    },
    "sparse.Matvecs.time_matvecs": {
        "code": "class Matvecs:\n    def time_matvecs(self, format):\n        self.A * self.x\n\n    def setup(self, format):\n        self.A = poisson2d(300, format=format)\n        self.x = ones((self.A.shape[1], 10), dtype=self.A.dtype)",
        "min_run_count": 2,
        "name": "sparse.Matvecs.time_matvecs",
        "number": 0,
        "param_names": [
            "format"
        ],
        "params": [
            [
                "'dia'",
                "'coo'",
                "'csr'",
                "'csc'",
                "'bsr'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0e6c8e3b6d833c713ee6b32da28ca78fec9f77bb427c6f5db2956d2f3688d46c",
        "warmup_time": -1
    },
    "sparse.NullSlice.time_10000_rows": {
        "code": "class NullSlice:\n    def time_10000_rows(self, density, format):\n        self.X[np.arange(10000), :]\n\n    def setup(self, density, format):\n        # Unpickling is faster than computing the random matrix...\n        with open('{}-{}.pck'.format(density, format), 'rb') as f:\n            self.X = pickle.load(f)\n\n    def setup_cache(self):\n        for density in self.params[0]:\n            for fmt in self.params[1]:\n                self._setup(density, fmt)",
        "min_run_count": 2,
        "name": "sparse.NullSlice.time_10000_rows",
        "number": 0,
        "param_names": [
            "density",
            "format"
        ],
        "params": [
            [
                "0.05",
                "0.01"
            ],
            [
                "'csr'",
                "'csc'",
                "'lil'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "sparse:340",
        "setup_cache_timeout": 120,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "dc19210b894d5fd41d4563f85b7459ef5836cddaf77154b539df3ea91c5d5c1c",
        "warmup_time": -1
    },
    "sparse.NullSlice.time_100_cols": {
        "code": "class NullSlice:\n    def time_100_cols(self, density, format):\n        self.X[:, np.arange(100)]\n\n    def setup(self, density, format):\n        # Unpickling is faster than computing the random matrix...\n        with open('{}-{}.pck'.format(density, format), 'rb') as f:\n            self.X = pickle.load(f)\n\n    def setup_cache(self):\n        for density in self.params[0]:\n            for fmt in self.params[1]:\n                self._setup(density, fmt)",
        "min_run_count": 2,
        "name": "sparse.NullSlice.time_100_cols",
        "number": 0,
        "param_names": [
            "density",
            "format"
        ],
        "params": [
            [
                "0.05",
                "0.01"
            ],
            [
                "'csr'",
                "'csc'",
                "'lil'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "sparse:340",
        "setup_cache_timeout": 120,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8d43ed52084cdab150018eedb289a749a39f35d4dfa31f53280f1ef286a23046",
        "warmup_time": -1
    },
    "sparse.NullSlice.time_3_cols": {
        "code": "class NullSlice:\n    def time_3_cols(self, density, format):\n        self.X[:, [0, 100, 105]]\n\n    def setup(self, density, format):\n        # Unpickling is faster than computing the random matrix...\n        with open('{}-{}.pck'.format(density, format), 'rb') as f:\n            self.X = pickle.load(f)\n\n    def setup_cache(self):\n        for density in self.params[0]:\n            for fmt in self.params[1]:\n                self._setup(density, fmt)",
        "min_run_count": 2,
        "name": "sparse.NullSlice.time_3_cols",
        "number": 0,
        "param_names": [
            "density",
            "format"
        ],
        "params": [
            [
                "0.05",
                "0.01"
            ],
            [
                "'csr'",
                "'csc'",
                "'lil'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "sparse:340",
        "setup_cache_timeout": 120,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "93e5123910772d62b3f72abff56c2732f83d217221bce409b70e77b89c311d26",
        "warmup_time": -1
    },
    "sparse.NullSlice.time_3_rows": {
        "code": "class NullSlice:\n    def time_3_rows(self, density, format):\n        self.X[[0, 100, 105], :]\n\n    def setup(self, density, format):\n        # Unpickling is faster than computing the random matrix...\n        with open('{}-{}.pck'.format(density, format), 'rb') as f:\n            self.X = pickle.load(f)\n\n    def setup_cache(self):\n        for density in self.params[0]:\n            for fmt in self.params[1]:\n                self._setup(density, fmt)",
        "min_run_count": 2,
        "name": "sparse.NullSlice.time_3_rows",
        "number": 0,
        "param_names": [
            "density",
            "format"
        ],
        "params": [
            [
                "0.05",
                "0.01"
            ],
            [
                "'csr'",
                "'csc'",
                "'lil'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "sparse:340",
        "setup_cache_timeout": 120,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a9eac80863a0b2f4b510269955041930e5fdd15607238257eb78244f891ebfe6",
        "warmup_time": -1
    },
    "sparse.NullSlice.time_getcol": {
        "code": "class NullSlice:\n    def time_getcol(self, density, format):\n        self.X.getcol(100)\n\n    def setup(self, density, format):\n        # Unpickling is faster than computing the random matrix...\n        with open('{}-{}.pck'.format(density, format), 'rb') as f:\n            self.X = pickle.load(f)\n\n    def setup_cache(self):\n        for density in self.params[0]:\n            for fmt in self.params[1]:\n                self._setup(density, fmt)",
        "min_run_count": 2,
        "name": "sparse.NullSlice.time_getcol",
        "number": 0,
        "param_names": [
            "density",
            "format"
        ],
        "params": [
            [
                "0.05",
                "0.01"
            ],
            [
                "'csr'",
                "'csc'",
                "'lil'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "sparse:340",
        "setup_cache_timeout": 120,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "291388763b355f0f3935db9272a29965d14fa3f305d3306059381e15300e638b",
        "warmup_time": -1
    },
    "sparse.NullSlice.time_getrow": {
        "code": "class NullSlice:\n    def time_getrow(self, density, format):\n        self.X.getrow(100)\n\n    def setup(self, density, format):\n        # Unpickling is faster than computing the random matrix...\n        with open('{}-{}.pck'.format(density, format), 'rb') as f:\n            self.X = pickle.load(f)\n\n    def setup_cache(self):\n        for density in self.params[0]:\n            for fmt in self.params[1]:\n                self._setup(density, fmt)",
        "min_run_count": 2,
        "name": "sparse.NullSlice.time_getrow",
        "number": 0,
        "param_names": [
            "density",
            "format"
        ],
        "params": [
            [
                "0.05",
                "0.01"
            ],
            [
                "'csr'",
                "'csc'",
                "'lil'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "sparse:340",
        "setup_cache_timeout": 120,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "edb9e4291560d6ba8dd58ef371b3a343a333bc10744496adb3ff964762d33c68",
        "warmup_time": -1
    },
    "sparse.Random.time_rand": {
        "code": "class Random:\n    def time_rand(self, density):\n        sparse.rand(self.nrows, self.ncols,\n                    format=self.format, density=density)\n\n    def setup(self, density):\n        warnings.simplefilter('ignore', SparseEfficiencyWarning)\n        self.nrows = 1000\n        self.ncols = 1000\n        self.format = 'csr'",
        "min_run_count": 2,
        "name": "sparse.Random.time_rand",
        "number": 0,
        "param_names": [
            "density"
        ],
        "params": [
            [
                "0.0",
                "0.1",
                "0.2",
                "0.30000000000000004",
                "0.4",
                "0.5",
                "0.6000000000000001",
                "0.7000000000000001",
                "0.8",
                "0.9",
                "1.0"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "320c3719a0f95052ea0841c9f8a7026e494039067d3b02a6ab91774e5afbbcd5",
        "warmup_time": -1
    },
    "sparse.Sort.time_sort": {
        "code": "class Sort:\n    def time_sort(self, matrix):\n        \"\"\"sort CSR column indices\"\"\"\n        self.A.sort_indices()\n\n    def setup(self, matrix):\n        n = 10000\n        if matrix.startswith('Rand'):\n            k = int(matrix[4:])\n            self.A = random_sparse(n, n, k)\n            self.A.has_sorted_indices = False\n            self.A.indices[:2] = 2, 1\n        else:\n            raise NotImplementedError()",
        "min_run_count": 2,
        "name": "sparse.Sort.time_sort",
        "number": 0,
        "param_names": [
            "matrix"
        ],
        "params": [
            [
                "'Rand10'",
                "'Rand25'",
                "'Rand50'",
                "'Rand100'",
                "'Rand200'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4268949f8dfc20462c34ad9701546d2d0354296a0031229c0dcf602f5b745973",
        "warmup_time": -1
    },
    "sparse.Sum.time_sum": {
        "code": "class Sum:\n    def time_sum(self, density, format):\n        self.X.sum()\n\n    def setup(self, density, format):\n        n = 1000\n        if format == 'dok' and n * density >= 500:\n            raise NotImplementedError()\n    \n        warnings.simplefilter('ignore', SparseEfficiencyWarning)\n        self.X = sparse.rand(n, n, format=format, density=density)",
        "min_run_count": 2,
        "name": "sparse.Sum.time_sum",
        "number": 0,
        "param_names": [
            "density",
            "format"
        ],
        "params": [
            [
                "0.01",
                "0.1",
                "0.5"
            ],
            [
                "'csr'",
                "'csc'",
                "'coo'",
                "'lil'",
                "'dok'",
                "'dia'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "05c305857e771024535e546360203b17f5aca2b39b023a49ab296bd746d6cdd3",
        "warmup_time": -1
    },
    "sparse.Sum.time_sum_axis0": {
        "code": "class Sum:\n    def time_sum_axis0(self, density, format):\n        self.X.sum(axis=0)\n\n    def setup(self, density, format):\n        n = 1000\n        if format == 'dok' and n * density >= 500:\n            raise NotImplementedError()\n    \n        warnings.simplefilter('ignore', SparseEfficiencyWarning)\n        self.X = sparse.rand(n, n, format=format, density=density)",
        "min_run_count": 2,
        "name": "sparse.Sum.time_sum_axis0",
        "number": 0,
        "param_names": [
            "density",
            "format"
        ],
        "params": [
            [
                "0.01",
                "0.1",
                "0.5"
            ],
            [
                "'csr'",
                "'csc'",
                "'coo'",
                "'lil'",
                "'dok'",
                "'dia'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8aca682fd69aa140c69c028679826bdf43c717589b1961b4702d744ed72effc6",
        "warmup_time": -1
    },
    "sparse.Sum.time_sum_axis1": {
        "code": "class Sum:\n    def time_sum_axis1(self, density, format):\n        self.X.sum(axis=1)\n\n    def setup(self, density, format):\n        n = 1000\n        if format == 'dok' and n * density >= 500:\n            raise NotImplementedError()\n    \n        warnings.simplefilter('ignore', SparseEfficiencyWarning)\n        self.X = sparse.rand(n, n, format=format, density=density)",
        "min_run_count": 2,
        "name": "sparse.Sum.time_sum_axis1",
        "number": 0,
        "param_names": [
            "density",
            "format"
        ],
        "params": [
            [
                "0.01",
                "0.1",
                "0.5"
            ],
            [
                "'csr'",
                "'csc'",
                "'coo'",
                "'lil'",
                "'dok'",
                "'dia'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1a6e05244b77f857c61f8ee09ca3abd006a10ba07eff10b1c5f9e0ac20f331b2",
        "warmup_time": -1
    },
    "sparse_csgraph.Laplacian.time_laplacian": {
        "code": "class Laplacian:\n    def time_laplacian(self, n, format, normed):\n        laplacian(self.A, normed=normed)\n\n    def setup(self, n, format, normed):\n        data = scipy.sparse.rand(9, n, density=0.5, random_state=42).toarray()\n        data = np.vstack((data, data))\n        diags = list(range(-9, 0)) + list(range(1, 10))\n        A = scipy.sparse.spdiags(data, diags, n, n)\n        if format == 'dense':\n            self.A = A.toarray()\n        else:\n            self.A = A.asformat(format)",
        "min_run_count": 2,
        "name": "sparse_csgraph.Laplacian.time_laplacian",
        "number": 0,
        "param_names": [
            "n",
            "format",
            "normed"
        ],
        "params": [
            [
                "30",
                "300",
                "900"
            ],
            [
                "'dense'",
                "'coo'",
                "'csc'",
                "'csr'",
                "'dia'"
            ],
            [
                "True",
                "False"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b92e9b88ee4c528c25ebb2cfe70b49009ea6137919484946765b5321b04dc79e",
        "warmup_time": -1
    },
    "sparse_csgraph_djisktra.Dijkstra.time_dijkstra_multi": {
        "code": "class Dijkstra:\n    def time_dijkstra_multi(self, n, min_only):\n        dijkstra(self.data,\n                 directed=False,\n                 indices=self.indices,\n                 min_only=min_only)\n\n    def setup(self, n, min_only):\n        np.random.seed(1234)\n        # make a random connectivity matrix\n        data = scipy.sparse.rand(n, n, density=0.2, format='csc',\n                                 random_state=42, dtype=np.bool_)\n        data.setdiag(np.zeros(n, dtype=np.bool_))\n        self.data = data\n        # choose some random vertices\n        v = np.arange(n)\n        np.random.shuffle(v)\n        self.indices = v[:int(n*.1)]",
        "min_run_count": 2,
        "name": "sparse_csgraph_djisktra.Dijkstra.time_dijkstra_multi",
        "number": 0,
        "param_names": [
            "n",
            "min_only"
        ],
        "params": [
            [
                "30",
                "300",
                "900"
            ],
            [
                "True",
                "False"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ab81d663c1daaefb5d54aa8576a74ed64b3171460f71a3ec86353fc15fa142e7",
        "warmup_time": -1
    },
    "sparse_csgraph_matching.MaximumBipartiteMatching.time_maximum_bipartite_matching": {
        "code": "class MaximumBipartiteMatching:\n    def time_maximum_bipartite_matching(self, n, density):\n        maximum_bipartite_matching(self.graph)\n\n    def setup(self, n, density):\n        # Create random sparse matrices. Note that we could use\n        # scipy.sparse.rand for this purpose, but simply using np.random and\n        # disregarding duplicates is quite a bit faster.\n        np.random.seed(42)\n        d = np.random.randint(0, n, size=(int(n*n*density), 2))\n        graph = scipy.sparse.csr_matrix((np.ones(len(d)), (d[:, 0], d[:, 1])),\n                                        shape=(n, n))\n        self.graph = graph",
        "min_run_count": 2,
        "name": "sparse_csgraph_matching.MaximumBipartiteMatching.time_maximum_bipartite_matching",
        "number": 0,
        "param_names": [
            "n",
            "density"
        ],
        "params": [
            [
                "5000",
                "7500",
                "10000"
            ],
            [
                "0.0001",
                "0.0005",
                "0.001"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0788007ee6966be5e5b57ec419c15b566b95cd90fa1075382a88397b9fd1a7d5",
        "warmup_time": -1
    },
    "sparse_csgraph_matching.MinWeightFullBipartiteMatching.time_evaluation": {
        "code": "class MinWeightFullBipartiteMatching:\n    def time_evaluation(self, *args):\n        min_weight_full_bipartite_matching(self.biadjacency_matrix)\n\n    def setup(self, shape, input_type):\n        np.random.seed(42)\n        input_func = {'random_uniform': random_uniform,\n                      'random_uniform_sparse': random_uniform_sparse,\n                      'random_uniform_integer': random_uniform_integer,\n                      'random_geometric': random_geometric,\n                      'random_two_cost': random_two_cost,\n                      'machol_wien': machol_wien}[input_type]\n    \n        self.biadjacency_matrix = input_func(shape)",
        "min_run_count": 2,
        "name": "sparse_csgraph_matching.MinWeightFullBipartiteMatching.time_evaluation",
        "number": 0,
        "param_names": [
            "shapes",
            "input_type"
        ],
        "params": [
            [
                "(100, 100)",
                "(200, 200)",
                "(300, 300)",
                "(400, 400)",
                "(100, 200)",
                "(200, 400)",
                "(300, 600)",
                "(400, 800)"
            ],
            [
                "'random_uniform'",
                "'random_uniform_sparse'",
                "'random_uniform_integer'",
                "'random_geometric'",
                "'random_two_cost'",
                "'machol_wien'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "630730e566726d7e16025f85f46f439cf8c66b5fafe68c8d9189d82a667e8df3",
        "warmup_time": -1
    },
    "sparse_csgraph_maxflow.MaximumFlow.time_maximum_flow": {
        "code": "class MaximumFlow:\n    def time_maximum_flow(self, n, density):\n        maximum_flow(self.data, 0, n - 1)\n\n    def setup(self, n, density):\n        # Create random matrices whose values are integers between 0 and 100.\n        data = (scipy.sparse.rand(n, n, density=density, format='lil',\n                                  random_state=42)*100).astype(np.int32)\n        data.setdiag(np.zeros(n, dtype=np.int32))\n        self.data = scipy.sparse.csr_matrix(data)",
        "min_run_count": 2,
        "name": "sparse_csgraph_maxflow.MaximumFlow.time_maximum_flow",
        "number": 0,
        "param_names": [
            "n",
            "density"
        ],
        "params": [
            [
                "200",
                "500",
                "1500"
            ],
            [
                "0.1",
                "0.3",
                "0.5"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8ca0245768f27e9a1347d85875c05e5413e3759ddd8bdc4d1027f3aa901fd708",
        "warmup_time": -1
    },
    "sparse_linalg_expm.Expm.time_expm": {
        "code": "class Expm:\n    def time_expm(self, n, format):\n        if format == 'sparse':\n            scipy.linalg.expm(self.A_sparse)\n        elif format == 'dense':\n            scipy.linalg.expm(self.A_dense)\n\n    def setup(self, n, format):\n        np.random.seed(1234)\n    \n        # Let the number of nonzero entries per row\n        # scale like the log of the order of the matrix.\n        nnz_per_row = int(math.ceil(math.log(n)))\n    \n        # time the sampling of a random sparse matrix\n        self.A_sparse = random_sparse_csc(n, n, nnz_per_row)\n    \n        # first format conversion\n        self.A_dense = self.A_sparse.toarray()",
        "min_run_count": 2,
        "name": "sparse_linalg_expm.Expm.time_expm",
        "number": 0,
        "param_names": [
            "n",
            "format"
        ],
        "params": [
            [
                "30",
                "100",
                "300"
            ],
            [
                "'sparse'",
                "'dense'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5b030fdc90211e607b049fdc2559bc5c21dae416c78149ccdf5084f8d8b863b0",
        "warmup_time": -1
    },
    "sparse_linalg_expm.ExpmMultiply.time_expm_multiply": {
        "code": "class ExpmMultiply:\n    def time_expm_multiply(self):\n        # computing only column', j, 'of expm of the sparse matrix\n        v = np.zeros(self.n, dtype=float)\n        v[self.j] = 1\n        A_expm_col_j = expm_multiply(self.A, v)\n        A_expm_col_j[self.i]\n\n    def setup(self):\n        self.n = 2000\n        self.i = 100\n        self.j = 200\n        nnz_per_row = 25\n        self.A = random_sparse_csr(self.n, self.n, nnz_per_row)",
        "min_run_count": 2,
        "name": "sparse_linalg_expm.ExpmMultiply.time_expm_multiply",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e68511899de027ba6015238b1432f49ad0ef12cea66db1f175eec005a2991c58",
        "warmup_time": -1
    },
    "sparse_linalg_lobpcg.Bench.time_mikota": {
        "code": "class Bench:\n    def time_mikota(self, n, solver):\n        m = 10\n        if solver == 'lobpcg':\n            X = rand(n, m)\n            X = orth(X)\n            LorU, lower = cho_factor(self.A, lower=0, overwrite_a=0)\n            M = LinearOperator(self.shape,\n                               matvec=partial(_precond, LorU, lower),\n                               matmat=partial(_precond, LorU, lower))\n            eigs, vecs = lobpcg(self.A, X, self.B, M, tol=1e-4, maxiter=40)\n        else:\n            eigh(self.A, self.B, eigvals_only=True, eigvals=(0, m - 1))\n\n    def setup_mikota(self, n, solver):\n        self.shape = (n, n)\n        self.A, self.B = _mikota_pair(n)\n    \n        if solver == 'eigh' and n >= 512:\n            # skip: slow, and not useful to benchmark\n            raise NotImplementedError()",
        "min_run_count": 2,
        "name": "sparse_linalg_lobpcg.Bench.time_mikota",
        "number": 0,
        "param_names": [
            "n",
            "solver"
        ],
        "params": [
            [
                "128",
                "256",
                "512",
                "1024",
                "2048"
            ],
            [
                "'lobpcg'",
                "'eigh'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a1fb679758f7e5cf79d18cc4930afdff999fccc142fe7a4f63e73b39ab1f58bb",
        "warmup_time": -1
    },
    "sparse_linalg_lobpcg.Bench.time_sakurai": {
        "code": "class Bench:\n    def time_sakurai(self, n, solver):\n        m = 3\n        if solver == 'lobpcg':\n            X = rand(n, m)\n            eigs, vecs, resnh = lobpcg(self.A, X, self.B, tol=1e-6, maxiter=500,\n                                       retResidualNormsHistory=1)\n        else:\n            eigh(self.A_dense, self.B_dense, eigvals_only=True, eigvals=(0, m - 1))\n\n    def setup_sakurai(self, n, solver):\n        self.shape = (n, n)\n        self.A, self.B, all_eigenvalues = _sakurai(n)\n        self.A_dense = self.A.A\n        self.B_dense = self.B.A",
        "min_run_count": 2,
        "name": "sparse_linalg_lobpcg.Bench.time_sakurai",
        "number": 0,
        "param_names": [
            "n",
            "solver"
        ],
        "params": [
            [
                "50",
                "400"
            ],
            [
                "'lobpcg'",
                "'eigh'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7c38d449924fb71f777bd408072ecc883b8b05e53a6544e97da3887fbc10b235",
        "warmup_time": -1
    },
    "sparse_linalg_onenormest.BenchmarkOneNormEst.time_onenormest": {
        "code": "class BenchmarkOneNormEst:\n    def time_onenormest(self, n, solver):\n        if solver == 'exact':\n            # Get the exact values of one-norms of squares.\n            for M in self.matrices:\n                M.dot(M)\n                scipy.sparse.linalg.matfuncs._onenorm(M)\n        elif solver == 'onenormest':\n            # Get the estimates of one-norms of squares.\n            for M in self.matrices:\n                scipy.sparse.linalg.matfuncs._onenormest_matrix_power(M, 2)\n\n    def setup(self, n, solver):\n        np.random.seed(1234)\n        nrepeats = 100\n        shape = (int(n), int(n))\n    \n        if solver == 'exact' and n >= 300:\n            # skip: slow, and not useful to benchmark\n            raise NotImplementedError()\n    \n        if n <= 1000:\n            # Sample the matrices.\n            self.matrices = []\n            for i in range(nrepeats):\n                M = np.random.randn(*shape)\n                self.matrices.append(M)\n        else:\n            max_nnz = 100000\n            nrepeats = 1\n    \n            self.matrices = []\n            for i in range(nrepeats):\n                M = scipy.sparse.rand(shape[0], shape[1], min(max_nnz/(shape[0]*shape[1]), 1e-5))\n                self.matrices.append(M)",
        "min_run_count": 2,
        "name": "sparse_linalg_onenormest.BenchmarkOneNormEst.time_onenormest",
        "number": 0,
        "param_names": [
            "n",
            "solver"
        ],
        "params": [
            [
                "2",
                "3",
                "5",
                "10",
                "30",
                "100",
                "300",
                "500",
                "1000",
                "10000.0",
                "100000.0",
                "1000000.0"
            ],
            [
                "'exact'",
                "'onenormest'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f7b31b4bf5caa50d435465e78dab6e133f3c263a52c4523eec785446185fdb6f",
        "warmup_time": -1
    },
    "sparse_linalg_solve.Bench.time_solve": {
        "code": "class Bench:\n    def time_solve(self, n, solver):\n        if solver == 'dense':\n            linalg.solve(self.P_dense, self.b)\n        elif solver == 'cg':\n            cg(self.P_sparse, self.b)\n        elif solver == 'minres':\n            minres(self.P_sparse, self.b)\n        elif solver == 'gmres':\n            gmres(self.P_sparse, self.b)\n        elif solver == 'lgmres':\n            lgmres(self.P_sparse, self.b)\n        elif solver == 'gcrotmk':\n            gcrotmk(self.P_sparse, self.b)\n        elif solver == 'spsolve':\n            spsolve(self.P_sparse, self.b)\n        else:\n            raise ValueError('Unknown solver: %r' % solver)\n\n    def setup(self, n, solver):\n        if solver == 'dense' and n >= 25:\n            raise NotImplementedError()\n    \n        self.b = np.ones(n*n)\n        self.P_sparse = _create_sparse_poisson2d(n)\n    \n        if solver == 'dense':\n            self.P_dense = self.P_sparse.A",
        "min_run_count": 2,
        "name": "sparse_linalg_solve.Bench.time_solve",
        "number": 0,
        "param_names": [
            "(n,n)",
            "solver"
        ],
        "params": [
            [
                "4",
                "6",
                "10",
                "16",
                "25",
                "40",
                "64",
                "100"
            ],
            [
                "'dense'",
                "'spsolve'",
                "'cg'",
                "'minres'",
                "'gmres'",
                "'lgmres'",
                "'gcrotmk'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "31a8ef9e4f642dff8bf29be4a8d79e1d3c776514bd30682b111a56e70ed7f6da",
        "warmup_time": -1
    },
    "sparse_linalg_solve.Lgmres.time_inner": {
        "code": "class Lgmres:\n    def time_inner(self, n, m):\n        lgmres(self.A, self.b, inner_m=m, maxiter=1)\n\n    def setup(self, n, m):\n        np.random.seed(1234)\n        self.A = sparse.eye(n, n) + sparse.rand(n, n, density=0.01)\n        self.b = np.ones(n)",
        "min_run_count": 2,
        "name": "sparse_linalg_solve.Lgmres.time_inner",
        "number": 0,
        "param_names": [
            "n",
            "m"
        ],
        "params": [
            [
                "10",
                "50",
                "100",
                "1000",
                "10000"
            ],
            [
                "10",
                "30",
                "60",
                "90",
                "180"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7a87045c1ddaa5704fb262800ad4c1dde101dc556a9445db9dd76c4029193f2d",
        "warmup_time": -1
    },
    "spatial.Build.time_build": {
        "code": "class Build:\n    def time_build(self, mnr, cls_name):\n        \"\"\"\n        Constructing kd-tree\n        =======================\n        dim | # points |  time\n        \"\"\"\n        m, n, r = mnr\n        if cls_name == 'cKDTree_flat':\n            self.T = self.cls(self.data, leafsize=n)\n        else:\n            self.cls(self.data)\n\n    def setup(self, mnr, cls_name):\n        self.cls = KDTree if cls_name == 'KDTree' else cKDTree\n        m, n, r = mnr\n    \n        np.random.seed(1234)\n        self.data = np.concatenate((np.random.randn(n//2,m),\n                                    np.random.randn(n-n//2,m)+np.ones(m)))\n    \n        self.queries = np.concatenate((np.random.randn(r//2,m),\n                                       np.random.randn(r-r//2,m)+np.ones(m)))",
        "min_run_count": 2,
        "name": "spatial.Build.time_build",
        "number": 0,
        "param_names": [
            "(m, n, r)",
            "class"
        ],
        "params": [
            [
                "(3, 10000, 1000)",
                "(8, 10000, 1000)",
                "(16, 10000, 1000)"
            ],
            [
                "'KDTree'",
                "'cKDTree'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4ba4812dbaf8d690c45fa276a5f1b3b65d132471009316c8554e20445e8c7924",
        "warmup_time": -1
    },
    "spatial.BuildUnbalanced.time_build": {
        "code": "class BuildUnbalanced:\n    def time_build(self, mnr, balanced, order):\n        cKDTree(self.data.get(order), balanced_tree=balanced)\n\n    def setup(self, *args):\n        super().setup(*args, None)",
        "min_run_count": 2,
        "name": "spatial.BuildUnbalanced.time_build",
        "number": 0,
        "param_names": [
            "(m, n, r)",
            "balanced",
            "order"
        ],
        "params": [
            [
                "(3, 10000, 1000)",
                "(8, 10000, 1000)",
                "(16, 10000, 1000)"
            ],
            [
                "True",
                "False"
            ],
            [
                "'random'",
                "'sorted'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b3f85876bde4578b41fe30a91936b5b252967ef1f73ab7022d1cde83f0b13fc4",
        "warmup_time": -1
    },
    "spatial.CNeighbors.time_count_neighbors_deep": {
        "code": "class CNeighbors:\n    def time_count_neighbors_deep(self, mn1n2, Nr):\n        \"\"\"\n        Count neighbors for a very deep kd-tree\n        dim | # points T1 | # points T2 | Nr\n        \"\"\"\n        self.T1d.count_neighbors(self.T2d, self.r)\n\n    def setup(self, mn1n2, Nr):\n        m, n1, n2 = mn1n2\n    \n        data1 = np.random.uniform(size=(n1, m))\n        data2 = np.random.uniform(size=(n2, m))\n        self.w1 = np.ones(len(data1))\n        self.w2 = np.ones(len(data2))\n    \n        self.T1d = cKDTree(data1, leafsize=1)\n        self.T2d = cKDTree(data2, leafsize=1)\n        self.T1s = cKDTree(data1, leafsize=8)\n        self.T2s = cKDTree(data2, leafsize=8)\n        self.r = np.linspace(0, 0.5, Nr)",
        "min_run_count": 2,
        "name": "spatial.CNeighbors.time_count_neighbors_deep",
        "number": 0,
        "param_names": [
            "(m, n1, n2)",
            "Nr"
        ],
        "params": [
            [
                "(2, 1000, 1000)",
                "(8, 1000, 1000)",
                "(16, 1000, 1000)"
            ],
            [
                "2",
                "10",
                "100",
                "400",
                "1000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "898c532420fe54ed2c5c8ac138c47fb2c526cc6068b1af36f4bb77fe14cbc921",
        "warmup_time": -1
    },
    "spatial.CNeighbors.time_count_neighbors_shallow": {
        "code": "class CNeighbors:\n    def time_count_neighbors_shallow(self, mn1n2, Nr):\n        \"\"\"\n        Count neighbors for a shallow kd-tree\n        dim | # points T1 | # points T2 | Nr\n        \"\"\"\n        self.T1s.count_neighbors(self.T2s, self.r)\n\n    def setup(self, mn1n2, Nr):\n        m, n1, n2 = mn1n2\n    \n        data1 = np.random.uniform(size=(n1, m))\n        data2 = np.random.uniform(size=(n2, m))\n        self.w1 = np.ones(len(data1))\n        self.w2 = np.ones(len(data2))\n    \n        self.T1d = cKDTree(data1, leafsize=1)\n        self.T2d = cKDTree(data2, leafsize=1)\n        self.T1s = cKDTree(data1, leafsize=8)\n        self.T2s = cKDTree(data2, leafsize=8)\n        self.r = np.linspace(0, 0.5, Nr)",
        "min_run_count": 2,
        "name": "spatial.CNeighbors.time_count_neighbors_shallow",
        "number": 0,
        "param_names": [
            "(m, n1, n2)",
            "Nr"
        ],
        "params": [
            [
                "(2, 1000, 1000)",
                "(8, 1000, 1000)",
                "(16, 1000, 1000)"
            ],
            [
                "2",
                "10",
                "100",
                "400",
                "1000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "77ff53b15a90b2222e3a224e25ae752587a0a69b3899f04a8689193cda97f368",
        "warmup_time": -1
    },
    "spatial.ConvexHullBench.time_convex_hull": {
        "code": "class ConvexHullBench:\n    def time_convex_hull(self, num_points, incremental):\n        \"\"\"Time scipy.spatial.ConvexHull over a range of input data sizes\n        and settings.\n        \"\"\"\n        ConvexHull(self.points, incremental)\n\n    def setup(self, num_points, incremental):\n        np.random.seed(123)\n        self.points = np.random.random_sample((num_points, 3))",
        "min_run_count": 2,
        "name": "spatial.ConvexHullBench.time_convex_hull",
        "number": 0,
        "param_names": [
            "num_points",
            "incremental"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "5000"
            ],
            [
                "True",
                "False"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "64fda6560789a5a6261b84ec4eaa9f416b469f162f374ee0bfda0ecff981f12a",
        "warmup_time": -1
    },
    "spatial.GeometricSlerpBench.time_geometric_slerp_3d": {
        "code": "class GeometricSlerpBench:\n    def time_geometric_slerp_3d(self, num_points):\n        # time geometric_slerp() for 3D interpolation\n        geometric_slerp(start=self.start,\n                        end=self.end,\n                        t=self.t)\n\n    def setup(self, num_points):\n        points = generate_spherical_points(50)\n        # any two points from the random spherical points\n        # will suffice for the interpolation bounds:\n        self.start = points[0]\n        self.end = points[-1]\n        self.t = np.linspace(0, 1, num_points)",
        "min_run_count": 2,
        "name": "spatial.GeometricSlerpBench.time_geometric_slerp_3d",
        "number": 0,
        "param_names": [
            "num_points"
        ],
        "params": [
            [
                "10",
                "1000",
                "10000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "24e5a4b637081cea96f06a0e1ad72ac25282b6954c01f6bf387635de0ffe28ec",
        "warmup_time": -1
    },
    "spatial.Hausdorff.time_directed_hausdorff": {
        "code": "class Hausdorff:\n    def time_directed_hausdorff(self, num_points):\n        # time directed_hausdorff code in 3 D\n        distance.directed_hausdorff(self.points1, self.points2)\n\n    def setup(self, num_points):\n        np.random.seed(123)\n        self.points1 = np.random.random_sample((num_points, 3))\n        np.random.seed(71890)\n        self.points2 = np.random.random_sample((num_points, 3))",
        "min_run_count": 2,
        "name": "spatial.Hausdorff.time_directed_hausdorff",
        "number": 0,
        "param_names": [
            "num_points"
        ],
        "params": [
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4c3ada8182e009f3f38b3468aebf2a21211aa46f4b9468985624a9b89a17f539",
        "warmup_time": -1
    },
    "spatial.Neighbors.time_count_neighbors": {
        "code": "class Neighbors:\n    def time_count_neighbors(self, mn1n2, p, probe_radius, boxsize, leafsize, cls):\n        \"\"\"\n        Count neighbors kd-tree\n        dim | # points T1 | # points T2 | p | probe radius |  BoxSize | LeafSize | cls\n        \"\"\"\n    \n        if cls != 'cKDTree_weighted':\n            self.T1.count_neighbors(self.T2, probe_radius, p=p)\n        else:\n            self.T1.count_neighbors(self.T2, probe_radius, weights=(self.w1, self.w2), p=p)\n\n    def setup(self, mn1n2, p, probe_radius, boxsize, leafsize, cls):\n        LimitedParamBenchmark.setup(self, mn1n2, p, probe_radius, boxsize, leafsize, cls)\n    \n        m, n1, n2 = mn1n2\n    \n        self.data1 = np.random.uniform(size=(n1, m))\n        self.data2 = np.random.uniform(size=(n2, m))\n    \n        self.w1 = np.ones(n1)\n        self.w2 = np.ones(n2)\n    \n        self.T1 = cKDTree(self.data1, boxsize=boxsize, leafsize=leafsize)\n        self.T2 = cKDTree(self.data2, boxsize=boxsize, leafsize=leafsize)",
        "min_run_count": 2,
        "name": "spatial.Neighbors.time_count_neighbors",
        "number": 0,
        "param_names": [
            "(m, n1, n2)",
            "p",
            "probe radius",
            "boxsize",
            "leafsize",
            "cls"
        ],
        "params": [
            [
                "(3, 1000, 1000)",
                "(8, 1000, 1000)",
                "(16, 1000, 1000)"
            ],
            [
                "1",
                "2",
                "inf"
            ],
            [
                "0.2",
                "0.5"
            ],
            [
                "None",
                "0.0",
                "1.0"
            ],
            [
                "8",
                "128"
            ],
            [
                "'cKDTree'",
                "'cKDTree_weighted'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "830287f1cf51fa6ba21854a60b03b2a6c70b2f2485c3cdcfb19a360e0a7e2ca2",
        "warmup_time": -1
    },
    "spatial.Neighbors.time_sparse_distance_matrix": {
        "code": "class Neighbors:\n    def time_sparse_distance_matrix(self, mn1n2, p, probe_radius, boxsize, leafsize, cls):\n        self.T1.sparse_distance_matrix(self.T2, probe_radius, p=p)\n\n    def setup(self, mn1n2, p, probe_radius, boxsize, leafsize, cls):\n        LimitedParamBenchmark.setup(self, mn1n2, p, probe_radius, boxsize, leafsize, cls)\n    \n        m, n1, n2 = mn1n2\n    \n        self.data1 = np.random.uniform(size=(n1, m))\n        self.data2 = np.random.uniform(size=(n2, m))\n    \n        self.w1 = np.ones(n1)\n        self.w2 = np.ones(n2)\n    \n        self.T1 = cKDTree(self.data1, boxsize=boxsize, leafsize=leafsize)\n        self.T2 = cKDTree(self.data2, boxsize=boxsize, leafsize=leafsize)",
        "min_run_count": 2,
        "name": "spatial.Neighbors.time_sparse_distance_matrix",
        "number": 0,
        "param_names": [
            "(m, n1, n2)",
            "p",
            "probe radius",
            "boxsize",
            "leafsize",
            "cls"
        ],
        "params": [
            [
                "(3, 1000, 1000)",
                "(8, 1000, 1000)",
                "(16, 1000, 1000)"
            ],
            [
                "1",
                "2",
                "inf"
            ],
            [
                "0.2",
                "0.5"
            ],
            [
                "None",
                "0.0",
                "1.0"
            ],
            [
                "8",
                "128"
            ],
            [
                "'cKDTree'",
                "'cKDTree_weighted'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9aa921dce6da78394ab29d949be27953484613dcf9c9632c01ae3973d4b29596",
        "warmup_time": -1
    },
    "spatial.Query.time_query": {
        "code": "class Query:\n    def time_query(self, mnr, p, boxsize, leafsize):\n        \"\"\"\n        Querying kd-tree\n        dim | # points | # queries |  KDTree  | cKDTree | flat cKDTree\n        \"\"\"\n        self.T.query(self.queries, p=p)\n\n    def setup(self, mnr, p, boxsize, leafsize):\n        LimitedParamBenchmark.setup(self, mnr, p, boxsize, leafsize)\n        Query.do_setup(self, mnr, p, boxsize, leafsize)",
        "min_run_count": 2,
        "name": "spatial.Query.time_query",
        "number": 0,
        "param_names": [
            "(m, n, r)",
            "p",
            "boxsize",
            "leafsize"
        ],
        "params": [
            [
                "(3, 10000, 1000)",
                "(8, 10000, 1000)",
                "(16, 10000, 1000)"
            ],
            [
                "1",
                "2",
                "inf"
            ],
            [
                "None",
                "0.0",
                "1.0"
            ],
            [
                "8",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "327bc0627d5387347e9cdcf4c52a550c813bb80a859eeb0f3e5bfe6650a8a1db",
        "warmup_time": -1
    },
    "spatial.QueryUnbalanced.time_query": {
        "code": "class QueryUnbalanced:\n    def time_query(self, mnr, balanced, order):\n        self.T.query(self.queries)\n\n    def setup(self, *args):\n        super().setup(*args, None)",
        "min_run_count": 2,
        "name": "spatial.QueryUnbalanced.time_query",
        "number": 0,
        "param_names": [
            "(m, n, r)",
            "balanced",
            "order"
        ],
        "params": [
            [
                "(3, 10000, 1000)",
                "(8, 10000, 1000)",
                "(16, 10000, 1000)"
            ],
            [
                "True",
                "False"
            ],
            [
                "'random'",
                "'sorted'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a9d431feadb762330179e442072bf26158cb5969d79b1beae251b28526278f1b",
        "warmup_time": -1
    },
    "spatial.Radius.time_query_ball_point": {
        "code": "class Radius:\n    def time_query_ball_point(self, mnr, p, probe_radius, boxsize, leafsize):\n        self.T.query_ball_point(self.queries, probe_radius, p=p)\n\n    def setup(self, *args):\n        pass\n\n    def setup_query_ball_point(self, mnr, p, probe_radius, boxsize, leafsize):\n        LimitedParamBenchmark.setup(self, mnr, p, probe_radius, boxsize, leafsize,\n                                    param_seed=3)\n        Query.do_setup(self, mnr, p, boxsize, leafsize)",
        "min_run_count": 2,
        "name": "spatial.Radius.time_query_ball_point",
        "number": 0,
        "param_names": [
            "(m, n, r)",
            "p",
            "probe radius",
            "boxsize",
            "leafsize"
        ],
        "params": [
            [
                "(3, 10000, 1000)"
            ],
            [
                "1",
                "2",
                "inf"
            ],
            [
                "0.2",
                "0.5"
            ],
            [
                "None",
                "0.0",
                "1.0"
            ],
            [
                "8",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e0c2074b35db7e5fca01a43b0fba8ab33a15ed73d8573871ea6feb57b3df4168",
        "warmup_time": -1
    },
    "spatial.Radius.time_query_ball_point_nosort": {
        "code": "class Radius:\n    def time_query_ball_point_nosort(self, mnr, p, probe_radius, boxsize, leafsize):\n        self.T.query_ball_point(self.queries, probe_radius, p=p,\n                                return_sorted=False)\n\n    def setup(self, *args):\n        pass\n\n    def setup_query_ball_point(self, mnr, p, probe_radius, boxsize, leafsize):\n        LimitedParamBenchmark.setup(self, mnr, p, probe_radius, boxsize, leafsize,\n                                    param_seed=3)\n        Query.do_setup(self, mnr, p, boxsize, leafsize)",
        "min_run_count": 2,
        "name": "spatial.Radius.time_query_ball_point_nosort",
        "number": 0,
        "param_names": [
            "(m, n, r)",
            "p",
            "probe radius",
            "boxsize",
            "leafsize"
        ],
        "params": [
            [
                "(3, 10000, 1000)"
            ],
            [
                "1",
                "2",
                "inf"
            ],
            [
                "0.2",
                "0.5"
            ],
            [
                "None",
                "0.0",
                "1.0"
            ],
            [
                "8",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3b4af3fb728a8ddede3db373ad84acf4e35a28f8732e03553b45ee4486485380",
        "warmup_time": -1
    },
    "spatial.Radius.time_query_pairs": {
        "code": "class Radius:\n    def time_query_pairs(self, mnr, p, probe_radius, boxsize, leafsize):\n        self.T.query_pairs(probe_radius, p=p)\n\n    def setup(self, *args):\n        pass\n\n    def setup_query_pairs(self, mnr, p, probe_radius, boxsize, leafsize):\n        # query_pairs is fast enough so we can run all parameter combinations\n        Query.do_setup(self, mnr, p, boxsize, leafsize)",
        "min_run_count": 2,
        "name": "spatial.Radius.time_query_pairs",
        "number": 0,
        "param_names": [
            "(m, n, r)",
            "p",
            "probe radius",
            "boxsize",
            "leafsize"
        ],
        "params": [
            [
                "(3, 1000, 30)",
                "(8, 1000, 30)",
                "(16, 1000, 30)"
            ],
            [
                "1",
                "2",
                "inf"
            ],
            [
                "0.2",
                "0.5"
            ],
            [
                "None",
                "0.0",
                "1.0"
            ],
            [
                "8",
                "128"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "cf669f7d619e81e4a09b28bb3fceaefbdd316d30faf01524ab33d41661a53f56",
        "warmup_time": -1
    },
    "spatial.RadiusUnbalanced.time_query_ball_point": {
        "code": "class RadiusUnbalanced:\n    def time_query_ball_point(self, mnr, balanced, order, radius):\n        self.T.query_ball_point(self.queries, radius)\n\nclass PresortedDataSetup:\n    def setup(self, mnr, balanced, order, radius):\n        m, n, r = mnr\n    \n        np.random.seed(1234)\n        self.data = {\n            'random': np.random.uniform(size=(n, m)),\n            'sorted': np.repeat(np.arange(n, 0, -1)[:, np.newaxis],\n                                m,\n                                axis=1) / n\n        }\n    \n        self.queries = np.random.uniform(size=(r, m))\n        self.T = cKDTree(self.data.get(order), balanced_tree=balanced)",
        "min_run_count": 2,
        "name": "spatial.RadiusUnbalanced.time_query_ball_point",
        "number": 0,
        "param_names": [
            "(m, n, r)",
            "balanced",
            "order",
            "radius"
        ],
        "params": [
            [
                "(3, 1000, 30)",
                "(8, 1000, 30)",
                "(16, 1000, 30)"
            ],
            [
                "True",
                "False"
            ],
            [
                "'random'",
                "'sorted'"
            ],
            [
                "0.5"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "da28f9379cb1b682fd9c936b07b975e58228704248cadc7c80c8fe28684bb15e",
        "warmup_time": -1
    },
    "spatial.RadiusUnbalanced.time_query_pairs": {
        "code": "class RadiusUnbalanced:\n    def time_query_pairs(self, mnr, balanced, order, radius):\n        self.T.query_pairs(radius)\n\nclass PresortedDataSetup:\n    def setup(self, mnr, balanced, order, radius):\n        m, n, r = mnr\n    \n        np.random.seed(1234)\n        self.data = {\n            'random': np.random.uniform(size=(n, m)),\n            'sorted': np.repeat(np.arange(n, 0, -1)[:, np.newaxis],\n                                m,\n                                axis=1) / n\n        }\n    \n        self.queries = np.random.uniform(size=(r, m))\n        self.T = cKDTree(self.data.get(order), balanced_tree=balanced)",
        "min_run_count": 2,
        "name": "spatial.RadiusUnbalanced.time_query_pairs",
        "number": 0,
        "param_names": [
            "(m, n, r)",
            "balanced",
            "order",
            "radius"
        ],
        "params": [
            [
                "(3, 1000, 30)",
                "(8, 1000, 30)",
                "(16, 1000, 30)"
            ],
            [
                "True",
                "False"
            ],
            [
                "'random'",
                "'sorted'"
            ],
            [
                "0.5"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a1412769a2db340629a8514a5a4a62f8172a727ef44ad268aaa8fc5d75df0b1b",
        "warmup_time": -1
    },
    "spatial.RotationBench.time_euler_conversion": {
        "code": "class RotationBench:\n    def time_euler_conversion(self, num_rotations):\n        '''Time converting rotation from and to euler angles'''\n        Rotation.from_euler(\"XYZ\", self.rotations.as_euler(\"XYZ\"))\n\n    def setup(self, num_rotations):\n        np.random.seed(1234)\n        self.rotations = Rotation.random(num_rotations)",
        "min_run_count": 2,
        "name": "spatial.RotationBench.time_euler_conversion",
        "number": 0,
        "param_names": [
            "num_rotations"
        ],
        "params": [
            [
                "1",
                "10",
                "1000",
                "10000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "30d442063d9f255b3c601d66fed0dc3eb750b89eb9253e1290f0532541875c3c",
        "warmup_time": -1
    },
    "spatial.RotationBench.time_matrix_conversion": {
        "code": "class RotationBench:\n    def time_matrix_conversion(self, num_rotations):\n        '''Time converting rotation from and to matrices'''\n        Rotation.from_matrix(self.rotations.as_matrix())\n\n    def setup(self, num_rotations):\n        np.random.seed(1234)\n        self.rotations = Rotation.random(num_rotations)",
        "min_run_count": 2,
        "name": "spatial.RotationBench.time_matrix_conversion",
        "number": 0,
        "param_names": [
            "num_rotations"
        ],
        "params": [
            [
                "1",
                "10",
                "1000",
                "10000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ebb37912ff93ea6b2dfa4dd3e8da6585adcb19a26384b0d88b4d7b0bd6da9738",
        "warmup_time": -1
    },
    "spatial.RotationBench.time_mrp_conversion": {
        "code": "class RotationBench:\n    def time_mrp_conversion(self, num_rotations):\n        '''Time converting rotation from and to Modified Rodrigues Parameters'''\n        Rotation.from_mrp(self.rotations.as_mrp())\n\n    def setup(self, num_rotations):\n        np.random.seed(1234)\n        self.rotations = Rotation.random(num_rotations)",
        "min_run_count": 2,
        "name": "spatial.RotationBench.time_mrp_conversion",
        "number": 0,
        "param_names": [
            "num_rotations"
        ],
        "params": [
            [
                "1",
                "10",
                "1000",
                "10000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1351f3f2284b2e53067f0f7c39d47f59f91cc79745a128fe6e6b13a2d236a6c8",
        "warmup_time": -1
    },
    "spatial.RotationBench.time_mul_inv": {
        "code": "class RotationBench:\n    def time_mul_inv(self, num_rotations):\n        '''Time multiplication and inverse of rotations'''\n        self.rotations * self.rotations.inv()\n\n    def setup(self, num_rotations):\n        np.random.seed(1234)\n        self.rotations = Rotation.random(num_rotations)",
        "min_run_count": 2,
        "name": "spatial.RotationBench.time_mul_inv",
        "number": 0,
        "param_names": [
            "num_rotations"
        ],
        "params": [
            [
                "1",
                "10",
                "1000",
                "10000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a687eea14caff3b7c4380ba889eb8e8dc50f63702557c45d95015cbe7c07f8fa",
        "warmup_time": -1
    },
    "spatial.RotationBench.time_rotvec_conversion": {
        "code": "class RotationBench:\n    def time_rotvec_conversion(self, num_rotations):\n        '''Time converting rotation from and to rotation vectors'''\n        Rotation.from_rotvec(self.rotations.as_rotvec())\n\n    def setup(self, num_rotations):\n        np.random.seed(1234)\n        self.rotations = Rotation.random(num_rotations)",
        "min_run_count": 2,
        "name": "spatial.RotationBench.time_rotvec_conversion",
        "number": 0,
        "param_names": [
            "num_rotations"
        ],
        "params": [
            [
                "1",
                "10",
                "1000",
                "10000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a31fbee9db63d0359bd6e006ad67a6cc457435a2e37c3c2004c1cc25200b5ca7",
        "warmup_time": -1
    },
    "spatial.SphericalVor.time_spherical_voronoi_calculation": {
        "code": "class SphericalVor:\n    def time_spherical_voronoi_calculation(self, num_points):\n        \"\"\"Perform spherical Voronoi calculation, but not the sorting of\n        vertices in the Voronoi polygons.\n        \"\"\"\n        SphericalVoronoi(self.points, radius=1, center=np.zeros(3))\n\n    def setup(self, num_points):\n        self.points = generate_spherical_points(num_points)",
        "min_run_count": 2,
        "name": "spatial.SphericalVor.time_spherical_voronoi_calculation",
        "number": 0,
        "param_names": [
            "num_points"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "5000",
                "10000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "108f4b104274b35e6ca904743fa9210c9aa3d2ca795577921ed22ab709f57684",
        "warmup_time": -1
    },
    "spatial.SphericalVorAreas.time_spherical_polygon_area_calculation": {
        "code": "class SphericalVorAreas:\n    def time_spherical_polygon_area_calculation(self, num_points):\n        \"\"\"Time the area calculation in the Spherical Voronoi code.\"\"\"\n        self.sv.calculate_areas()\n\n    def setup(self, num_points):\n        self.points = generate_spherical_points(num_points)\n        self.sv = SphericalVoronoi(self.points, radius=1,\n                                   center=np.zeros(3))",
        "min_run_count": 2,
        "name": "spatial.SphericalVorAreas.time_spherical_polygon_area_calculation",
        "number": 0,
        "param_names": [
            "num_points"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "5000",
                "10000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "88caac659e86b94c166b03a7f78598dcd94d06f476f1f551f098a82095dc12e2",
        "warmup_time": -1
    },
    "spatial.SphericalVorSort.time_spherical_polygon_vertex_sorting": {
        "code": "class SphericalVorSort:\n    def time_spherical_polygon_vertex_sorting(self, num_points):\n        \"\"\"Time the vertex sorting operation in the Spherical Voronoi\n        code.\n        \"\"\"\n        self.sv.sort_vertices_of_regions()\n\n    def setup(self, num_points):\n        self.points = generate_spherical_points(num_points)\n        self.sv = SphericalVoronoi(self.points, radius=1,\n                                   center=np.zeros(3))",
        "min_run_count": 2,
        "name": "spatial.SphericalVorSort.time_spherical_polygon_vertex_sorting",
        "number": 0,
        "param_names": [
            "num_points"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "5000",
                "10000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0f28dddb4c82c668099fe3a69f65ab059cfb4b7614a4444f0fd6d7c0d8dd7799",
        "warmup_time": -1
    },
    "spatial.VoronoiBench.time_voronoi_calculation": {
        "code": "class VoronoiBench:\n    def time_voronoi_calculation(self, num_points, furthest_site):\n        \"\"\"Time conventional Voronoi diagram calculation.\"\"\"\n        Voronoi(self.points, furthest_site=furthest_site)\n\n    def setup(self, num_points, furthest_site):\n        np.random.seed(123)\n        self.points = np.random.random_sample((num_points, 3))",
        "min_run_count": 2,
        "name": "spatial.VoronoiBench.time_voronoi_calculation",
        "number": 0,
        "param_names": [
            "num_points",
            "furthest_site"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "5000",
                "10000"
            ],
            [
                "False",
                "True"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "dd0e842221e4a0436f3010524f8b9d77200b59940ad82fcd5509ac808b6f8c9c",
        "warmup_time": -1
    },
    "spatial.Xdist.time_cdist": {
        "code": "class Xdist:\n    def time_cdist(self, num_points, metric):\n        \"\"\"Time scipy.spatial.distance.cdist over a range of input data\n        sizes and metrics.\n        \"\"\"\n        distance.cdist(self.points, self.points, self.metric, **self.kwargs)\n\n    def setup(self, num_points, metric):\n        np.random.seed(123)\n        self.points = np.random.random_sample((num_points, 3))\n        self.metric = metric\n        if metric == 'minkowski-P3':\n            # p=2 is just the euclidean metric, try another p value as well\n            self.kwargs = {'p': 3.0}\n            self.metric = 'minkowski'\n        elif metric == 'wminkowski':\n            # use an equal weight vector since weights are required\n            self.kwargs = {'w': np.ones(3)}\n        else:\n            self.kwargs = {}",
        "min_run_count": 2,
        "name": "spatial.Xdist.time_cdist",
        "number": 0,
        "param_names": [
            "num_points",
            "metric"
        ],
        "params": [
            [
                "10",
                "100",
                "1000"
            ],
            [
                "'euclidean'",
                "'minkowski'",
                "'cityblock'",
                "'seuclidean'",
                "'sqeuclidean'",
                "'cosine'",
                "'correlation'",
                "'hamming'",
                "'jaccard'",
                "'jensenshannon'",
                "'chebyshev'",
                "'canberra'",
                "'braycurtis'",
                "'mahalanobis'",
                "'yule'",
                "'dice'",
                "'kulsinski'",
                "'rogerstanimoto'",
                "'russellrao'",
                "'sokalmichener'",
                "'sokalsneath'",
                "'wminkowski'",
                "'minkowski-P3'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "95b5ad291484978e2ab873dda35a7e2168e0380554d8e427997c9c2dbf3a31e4",
        "warmup_time": -1
    },
    "spatial.Xdist.time_pdist": {
        "code": "class Xdist:\n    def time_pdist(self, num_points, metric):\n        \"\"\"Time scipy.spatial.distance.pdist over a range of input data\n        sizes and metrics.\n        \"\"\"\n        distance.pdist(self.points, self.metric, **self.kwargs)\n\n    def setup(self, num_points, metric):\n        np.random.seed(123)\n        self.points = np.random.random_sample((num_points, 3))\n        self.metric = metric\n        if metric == 'minkowski-P3':\n            # p=2 is just the euclidean metric, try another p value as well\n            self.kwargs = {'p': 3.0}\n            self.metric = 'minkowski'\n        elif metric == 'wminkowski':\n            # use an equal weight vector since weights are required\n            self.kwargs = {'w': np.ones(3)}\n        else:\n            self.kwargs = {}",
        "min_run_count": 2,
        "name": "spatial.Xdist.time_pdist",
        "number": 0,
        "param_names": [
            "num_points",
            "metric"
        ],
        "params": [
            [
                "10",
                "100",
                "1000"
            ],
            [
                "'euclidean'",
                "'minkowski'",
                "'cityblock'",
                "'seuclidean'",
                "'sqeuclidean'",
                "'cosine'",
                "'correlation'",
                "'hamming'",
                "'jaccard'",
                "'jensenshannon'",
                "'chebyshev'",
                "'canberra'",
                "'braycurtis'",
                "'mahalanobis'",
                "'yule'",
                "'dice'",
                "'kulsinski'",
                "'rogerstanimoto'",
                "'russellrao'",
                "'sokalmichener'",
                "'sokalsneath'",
                "'wminkowski'",
                "'minkowski-P3'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d24e650df51666111bf1500a4f410bd98412634afdc8096e9a85006c6dbfe4b8",
        "warmup_time": -1
    },
    "spatial.XdistWeighted.time_cdist": {
        "code": "class XdistWeighted:\n    def time_cdist(self, num_points, metric):\n        \"\"\"Time scipy.spatial.distance.cdist for weighted distance metrics.\"\"\"\n        distance.cdist(self.points, self.points, self.metric, w=self.weights,\n                       **self.kwargs)\n\n    def setup(self, num_points, metric):\n        np.random.seed(123)\n        self.points = np.random.random_sample((num_points, 3))\n        self.metric = metric\n        if metric == 'minkowski-P3':\n            # p=2 is just the euclidean metric, try another p value as well\n            self.kwargs = {'p': 3.0}\n            self.metric = 'minkowski'\n        else:\n            self.kwargs = {}\n        self.weights = np.ones(3)",
        "min_run_count": 2,
        "name": "spatial.XdistWeighted.time_cdist",
        "number": 0,
        "param_names": [
            "num_points",
            "metric"
        ],
        "params": [
            [
                "10",
                "20",
                "100"
            ],
            [
                "'euclidean'",
                "'minkowski'",
                "'cityblock'",
                "'sqeuclidean'",
                "'cosine'",
                "'correlation'",
                "'hamming'",
                "'jaccard'",
                "'chebyshev'",
                "'canberra'",
                "'braycurtis'",
                "'yule'",
                "'dice'",
                "'kulsinski'",
                "'rogerstanimoto'",
                "'russellrao'",
                "'sokalmichener'",
                "'sokalsneath'",
                "'minkowski-P3'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f7f4fdf9bf006826f7c45b90c61e0b28c25ec9f7d1bde27eebc07e549e15fe05",
        "warmup_time": -1
    },
    "spatial.XdistWeighted.time_pdist": {
        "code": "class XdistWeighted:\n    def time_pdist(self, num_points, metric):\n        \"\"\"Time scipy.spatial.distance.pdist for weighted distance metrics.\"\"\"\n        distance.pdist(self.points, self.metric, w=self.weights, **self.kwargs)\n\n    def setup(self, num_points, metric):\n        np.random.seed(123)\n        self.points = np.random.random_sample((num_points, 3))\n        self.metric = metric\n        if metric == 'minkowski-P3':\n            # p=2 is just the euclidean metric, try another p value as well\n            self.kwargs = {'p': 3.0}\n            self.metric = 'minkowski'\n        else:\n            self.kwargs = {}\n        self.weights = np.ones(3)",
        "min_run_count": 2,
        "name": "spatial.XdistWeighted.time_pdist",
        "number": 0,
        "param_names": [
            "num_points",
            "metric"
        ],
        "params": [
            [
                "10",
                "20",
                "100"
            ],
            [
                "'euclidean'",
                "'minkowski'",
                "'cityblock'",
                "'sqeuclidean'",
                "'cosine'",
                "'correlation'",
                "'hamming'",
                "'jaccard'",
                "'chebyshev'",
                "'canberra'",
                "'braycurtis'",
                "'yule'",
                "'dice'",
                "'kulsinski'",
                "'rogerstanimoto'",
                "'russellrao'",
                "'sokalmichener'",
                "'sokalsneath'",
                "'minkowski-P3'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "58c4158224dc6b16f09b66905db84b25ccf489c1706f048dbb2aa98de601b9c7",
        "warmup_time": -1
    },
    "special.Airy.time_ai_zeros": {
        "code": "class Airy:\n    def time_ai_zeros(self):\n        ai_zeros(100000)",
        "min_run_count": 2,
        "name": "special.Airy.time_ai_zeros",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9dcceb9408571060b6f02873fc4072f931f718ea2f5236772dddfc22332775d9",
        "warmup_time": -1
    },
    "special.Airy.time_bi_zeros": {
        "code": "class Airy:\n    def time_bi_zeros(self):\n        bi_zeros(100000)",
        "min_run_count": 2,
        "name": "special.Airy.time_bi_zeros",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5a9724705235ef858c333ec7dae598b7e1557a4ecb55bf8608e91b5d3def7fc5",
        "warmup_time": -1
    },
    "special.Comb.time_comb_exact": {
        "code": "class Comb:\n    @with_attributes(params=[(10, 100, 1000, 10000), (1, 10, 100)],\n                     param_names=['N', 'k'])\n    def time_comb_exact(self, N, k):\n        comb(N, k, exact=True)\n\n    def setup(self, *args):\n        self.N = np.arange(1, 1000, 50)\n        self.k = np.arange(1, 1000, 50)",
        "min_run_count": 2,
        "name": "special.Comb.time_comb_exact",
        "number": 0,
        "param_names": [
            "N",
            "k"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ],
            [
                "1",
                "10",
                "100"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "640e03cb54bf500a9bb17a4558953841df67530fcc79cc6e256cff86801d934d",
        "warmup_time": -1
    },
    "special.Comb.time_comb_float": {
        "code": "class Comb:\n    def time_comb_float(self):\n        comb(self.N[:,None], self.k[None,:])\n\n    def setup(self, *args):\n        self.N = np.arange(1, 1000, 50)\n        self.k = np.arange(1, 1000, 50)",
        "min_run_count": 2,
        "name": "special.Comb.time_comb_float",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "eaba845dac64e3a2ba0e5f67ff1bead19bcf0c033840ec965fc4d85582db711b",
        "warmup_time": -1
    },
    "special.Erf.time_real": {
        "code": "class Erf:\n    def time_real(self, offset):\n        erf(self.rand + offset)\n\n    def setup(self, *args):\n        self.rand = np.random.rand(100000)",
        "min_run_count": 2,
        "name": "special.Erf.time_real",
        "number": 0,
        "param_names": [
            "offset"
        ],
        "params": [
            [
                "0.0",
                "2.0"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c985228bb6ecc680410d024c8c4ab56fa00a95b155e405c029044b487e93ab3a",
        "warmup_time": -1
    },
    "special.Expn.time_expn_large_n": {
        "code": "class Expn:\n    def time_expn_large_n(self):\n        expn(self.n, self.x)\n\n    def setup(self):\n        n, x = np.arange(50, 500), np.logspace(0, 20, 100)\n        n, x = np.meshgrid(n, x)\n        self.n, self.x = n, x",
        "min_run_count": 2,
        "name": "special.Expn.time_expn_large_n",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1579c9226a7e0ebb2047466a04620c619f219cd514361ff859b0381365c498ab",
        "warmup_time": -1
    },
    "special.Loggamma.time_loggamma_asymptotic": {
        "code": "class Loggamma:\n    def time_loggamma_asymptotic(self):\n        loggamma(self.large_z)\n\n    def setup(self):\n        x, y = np.logspace(3, 5, 10), np.logspace(3, 5, 10)\n        x, y = np.meshgrid(x, y)\n        self.large_z = x + 1j*y",
        "min_run_count": 2,
        "name": "special.Loggamma.time_loggamma_asymptotic",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "fc273c10f60175c84fce376754825356457225e1b78d83e3beabbf886352585a",
        "warmup_time": -1
    },
    "stats.Anderson_KSamp.time_anderson_ksamp": {
        "code": "class Anderson_KSamp:\n    def time_anderson_ksamp(self):\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore', UserWarning)\n            stats.anderson_ksamp(self.rand)\n\n    def setup(self, *args):\n        self.rand = [np.random.normal(loc=i, size=1000) for i in range(3)]",
        "min_run_count": 2,
        "name": "stats.Anderson_KSamp.time_anderson_ksamp",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "339fc253c3add6deadbc1edc1112cf1b1fff85f70f57aeb9dd81e0ea23de9384",
        "warmup_time": -1
    },
    "stats.BenchMoment.time_moment": {
        "code": "class BenchMoment:\n    def time_moment(self, order, size):\n        stats.moment(self.x, order)\n\n    def setup(self, order, size):\n        np.random.random(1234)\n        self.x = np.random.random(size)",
        "min_run_count": 2,
        "name": "stats.BenchMoment.time_moment",
        "number": 0,
        "param_names": [
            "order",
            "size"
        ],
        "params": [
            [
                "1",
                "2",
                "3",
                "8"
            ],
            [
                "100",
                "1000",
                "10000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "10b78316c2b4c34d35f14269b05b4a47ecc2cb83dd5c864d6d19ea7d660fe3ea",
        "warmup_time": -1
    },
    "stats.BenchQMCDiscrepancy.time_discrepancy": {
        "code": "class BenchQMCDiscrepancy:\n    def time_discrepancy(self, method):\n        disc = stats.qmc.discrepancy(self.sample, method=method)\n\n    def setup(self, method):\n        np.random.seed(1234)\n        sample = np.random.random_sample((1000, 10))\n        self.sample = sample",
        "min_run_count": 2,
        "name": "stats.BenchQMCDiscrepancy.time_discrepancy",
        "number": 0,
        "param_names": [
            "method"
        ],
        "params": [
            [
                "'CD'",
                "'WD'",
                "'MD'",
                "'L2-star'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8cb7bdfdf1a15abab7c4dc762b0de68377f24c45e8e4a2ac2b1e5f16c85b10d4",
        "warmup_time": -1
    },
    "stats.BenchSkewKurtosis.time_kurtosis": {
        "code": "class BenchSkewKurtosis:\n    def time_kurtosis(self, order, size, bias):\n        stats.kurtosis(self.x, bias=bias)\n\n    def setup(self, order, size, bias):\n        np.random.random(1234)\n        self.x = np.random.random(size)",
        "min_run_count": 2,
        "name": "stats.BenchSkewKurtosis.time_kurtosis",
        "number": 0,
        "param_names": [
            "order",
            "size",
            "bias"
        ],
        "params": [
            [
                "1",
                "2",
                "3",
                "8"
            ],
            [
                "100",
                "1000",
                "10000"
            ],
            [
                "False",
                "True"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "404e2f215122985b9853a3c8c9d11a8b7e2299624fc7ae4542663780f2fbacca",
        "warmup_time": -1
    },
    "stats.BenchSkewKurtosis.time_skew": {
        "code": "class BenchSkewKurtosis:\n    def time_skew(self, order, size, bias):\n        stats.skew(self.x, bias=bias)\n\n    def setup(self, order, size, bias):\n        np.random.random(1234)\n        self.x = np.random.random(size)",
        "min_run_count": 2,
        "name": "stats.BenchSkewKurtosis.time_skew",
        "number": 0,
        "param_names": [
            "order",
            "size",
            "bias"
        ],
        "params": [
            [
                "1",
                "2",
                "3",
                "8"
            ],
            [
                "100",
                "1000",
                "10000"
            ],
            [
                "False",
                "True"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7ba4ed309da2b86678985696e2619be245f9c103916d1a9bd457cafc7ed9b3e9",
        "warmup_time": -1
    },
    "stats.BinnedStatisticDD.time_binned_statistic_dd": {
        "code": "class BinnedStatisticDD:\n    def time_binned_statistic_dd(self, statistic):\n        stats.binned_statistic_dd(\n            [self.inp[0], self.inp[1]], self.inp[2], statistic=statistic,\n            bins=[self.subbin_x_edges, self.subbin_y_edges])\n\n    def setup(self, statistic):\n        np.random.seed(12345678)\n        self.inp = np.random.rand(9999).reshape(3, 3333) * 200\n        self.subbin_x_edges = np.arange(0, 200, dtype=np.float32)\n        self.subbin_y_edges = np.arange(0, 200, dtype=np.float64)\n        self.ret = stats.binned_statistic_dd(\n            [self.inp[0], self.inp[1]], self.inp[2], statistic=statistic,\n            bins=[self.subbin_x_edges, self.subbin_y_edges])",
        "min_run_count": 2,
        "name": "stats.BinnedStatisticDD.time_binned_statistic_dd",
        "number": 0,
        "param_names": [
            "param1"
        ],
        "params": [
            [
                "'count'",
                "'sum'",
                "'mean'",
                "'min'",
                "'max'",
                "'median'",
                "'std'",
                "<function std>"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "508fc7144f1106311d19bb4521c02150c5dbf081379349da5a53c8258fde4505",
        "warmup_time": -1
    },
    "stats.BinnedStatisticDD.time_binned_statistic_dd_reuse_bin": {
        "code": "class BinnedStatisticDD:\n    def time_binned_statistic_dd_reuse_bin(self, statistic):\n        stats.binned_statistic_dd(\n            [self.inp[0], self.inp[1]], self.inp[2], statistic=statistic,\n            binned_statistic_result=self.ret)\n\n    def setup(self, statistic):\n        np.random.seed(12345678)\n        self.inp = np.random.rand(9999).reshape(3, 3333) * 200\n        self.subbin_x_edges = np.arange(0, 200, dtype=np.float32)\n        self.subbin_y_edges = np.arange(0, 200, dtype=np.float64)\n        self.ret = stats.binned_statistic_dd(\n            [self.inp[0], self.inp[1]], self.inp[2], statistic=statistic,\n            bins=[self.subbin_x_edges, self.subbin_y_edges])",
        "min_run_count": 2,
        "name": "stats.BinnedStatisticDD.time_binned_statistic_dd_reuse_bin",
        "number": 0,
        "param_names": [
            "param1"
        ],
        "params": [
            [
                "'count'",
                "'sum'",
                "'mean'",
                "'min'",
                "'max'",
                "'median'",
                "'std'",
                "<function std>"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "155a7d0aa43d42f6338e8078e753af03fd6e71246897babe3e3dfea6950ef95d",
        "warmup_time": -1
    },
    "stats.ContinuousFitAnalyticalMLEOverride.time_fit": {
        "code": "class ContinuousFitAnalyticalMLEOverride:\n    def time_fit(self, dist_name, loc_fixed, scale_fixed, shape1_fixed,\n                 shape2_fixed, shape3_fixed):\n        self.distn.fit(self.data, **self.fixed)\n\n    def setup(self, dist_name, loc_fixed, scale_fixed, shape1_fixed,\n              shape2_fixed, shape3_fixed):\n        self.distn = eval(\"stats.\" + dist_name)\n    \n        # default `loc` and `scale` are .834 and 4.342, and shapes are from\n        # `_distr_params.py`\n        default_shapes = self.distcont[dist_name]\n        param_values = self.custom_input.get(dist_name, [.834, 4.342,\n                                                         *default_shapes])\n        # separate relevant and non-relevant parameters for this distribution\n        # based on the number of shapes\n        nparam = len(param_values)\n        all_parameters = [loc_fixed, scale_fixed, shape1_fixed, shape2_fixed,\n                          shape3_fixed]\n        relevant_parameters = all_parameters[:nparam]\n        nonrelevant_parameters = all_parameters[nparam:]\n    \n        # skip if all parameters are fixed or if non relevant parameters are\n        # not all false\n        if True in nonrelevant_parameters or False not in relevant_parameters:\n            raise NotImplementedError(\"skip non-relevant case\")\n    \n        # add fixed values if fixed in relevant_parameters to self.fixed\n        # with keys from self.fnames and values from parameter_values\n        self.fixed = dict(zip(compress(self.fnames, relevant_parameters),\n                          compress(param_values, relevant_parameters)))\n        self.data = self.distn.rvs(*param_values, size=1000)",
        "min_run_count": 2,
        "name": "stats.ContinuousFitAnalyticalMLEOverride.time_fit",
        "number": 0,
        "param_names": [
            "distribution",
            "loc_fixed",
            "scale_fixed",
            "shape1_fixed",
            "shape2_fixed",
            "shape3_fixed"
        ],
        "params": [
            [
                "'pareto'",
                "'laplace'",
                "'rayleigh'",
                "'invgauss'",
                "'gumbel_r'",
                "'gumbel_l'"
            ],
            [
                "True",
                "False"
            ],
            [
                "True",
                "False"
            ],
            [
                "True",
                "False"
            ],
            [
                "True",
                "False"
            ],
            [
                "True",
                "False"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "00ab390e8376de544acfcdfc3079f96a3d213a37c576fa752ffdd93d6711bc75",
        "warmup_time": -1
    },
    "stats.CorrelationFunctions.time_barnard_exact": {
        "code": "class CorrelationFunctions:\n    def time_barnard_exact(self, alternative):\n        resBarnard = stats.barnard_exact(self.a, alternative=alternative)\n\n    def setup(self, mode):\n        a = np.random.rand(2,2) * 10\n        self.a = a",
        "min_run_count": 2,
        "name": "stats.CorrelationFunctions.time_barnard_exact",
        "number": 0,
        "param_names": [
            "alternative"
        ],
        "params": [
            [
                "'two-sided'",
                "'less'",
                "'greater'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8bfd6a8e8c9d0499c4e863e7fbe337dc69ecf2d0f4cc46f2c8ec2da49a01693c",
        "warmup_time": -1
    },
    "stats.CorrelationFunctions.time_fisher_exact": {
        "code": "class CorrelationFunctions:\n    def time_fisher_exact(self, alternative):\n        oddsratio, pvalue = stats.fisher_exact(self.a, alternative=alternative)\n\n    def setup(self, mode):\n        a = np.random.rand(2,2) * 10\n        self.a = a",
        "min_run_count": 2,
        "name": "stats.CorrelationFunctions.time_fisher_exact",
        "number": 0,
        "param_names": [
            "alternative"
        ],
        "params": [
            [
                "'two-sided'",
                "'less'",
                "'greater'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1b6fbd666591799952616c1c2b9786a0098344fa0a5e28a5b5cdb0df0b62f92a",
        "warmup_time": -1
    },
    "stats.DescriptiveStats.time_mode": {
        "code": "class DescriptiveStats:\n    def time_mode(self, n_levels):\n        stats.mode(self.levels, axis=0)\n\n    def setup(self, n_levels):\n        np.random.seed(12345678)\n        self.levels = np.random.randint(n_levels, size=(1000, 10))",
        "min_run_count": 2,
        "name": "stats.DescriptiveStats.time_mode",
        "number": 0,
        "param_names": [
            "n_levels"
        ],
        "params": [
            [
                "10",
                "1000"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "41bd0acf96a81da25d1dedf655e86fe988a6a5943f04e5e2103aa2b36d427338",
        "warmup_time": -1
    },
    "stats.Distribution.time_distribution": {
        "code": "class Distribution:\n    def time_distribution(self, distribution, properties):\n        if distribution == 'gamma':\n            if properties == 'pdf':\n                stats.gamma.pdf(self.x, a=5, loc=4, scale=10)\n            elif properties == 'cdf':\n                stats.gamma.cdf(self.x, a=5, loc=4, scale=10)\n            elif properties == 'rvs':\n                stats.gamma.rvs(size=1000, a=5, loc=4, scale=10)\n            elif properties == 'fit':\n                stats.gamma.fit(self.x, loc=4, scale=10)\n        elif distribution == 'cauchy':\n            if properties == 'pdf':\n                stats.cauchy.pdf(self.x, loc=4, scale=10)\n            elif properties == 'cdf':\n                stats.cauchy.cdf(self.x, loc=4, scale=10)\n            elif properties == 'rvs':\n                stats.cauchy.rvs(size=1000, loc=4, scale=10)\n            elif properties == 'fit':\n                stats.cauchy.fit(self.x, loc=4, scale=10)\n        elif distribution == 'beta':\n            if properties == 'pdf':\n                stats.beta.pdf(self.x, a=5, b=3, loc=4, scale=10)\n            elif properties == 'cdf':\n                stats.beta.cdf(self.x, a=5, b=3, loc=4, scale=10)\n            elif properties == 'rvs':\n                stats.beta.rvs(size=1000, a=5, b=3, loc=4, scale=10)\n            elif properties == 'fit':\n                stats.beta.fit(self.x, loc=4, scale=10)\n\n    def setup(self, distribution, properties):\n        np.random.seed(12345678)\n        self.x = np.random.rand(100)",
        "min_run_count": 2,
        "name": "stats.Distribution.time_distribution",
        "number": 0,
        "param_names": [
            "distribution",
            "properties"
        ],
        "params": [
            [
                "'cauchy'",
                "'gamma'",
                "'beta'"
            ],
            [
                "'pdf'",
                "'cdf'",
                "'rvs'",
                "'fit'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "fb22ae5386501008d945783921fe44aef3f82c1dafc40cddfaccaeec38b792b0",
        "warmup_time": -1
    },
    "stats.DistributionsAll.time_distribution": {
        "code": "class DistributionsAll:\n    def time_distribution(self, dist_name, method):\n        self.method(*self.args, **self.kwds)\n\n    def setup(self, dist_name, method):\n        if not is_xslow() and (dist_name in self.slow_dists\n                               or method in self.slow_methods):\n            raise NotImplementedError(\"Skipped\")\n    \n        self.dist = getattr(stats, dist_name)\n    \n        dist_shapes = self.dist_data[dist_name]\n    \n        if isinstance(self.dist, stats.rv_discrete):\n            # discrete distributions only use location\n            self.isCont = False\n            kwds = {'loc': 4}\n        else:\n            # continuous distributions use location and scale\n            self.isCont = True\n            kwds = {'loc': 4, 'scale': 10}\n    \n        bounds = self.dist.interval(.99, *dist_shapes, **kwds)\n        x = np.linspace(*bounds, 100)\n        args = [x, *self.custom_input.get(dist_name, dist_shapes)]\n        self.args = args\n        self.kwds = kwds\n        if method == 'fit':\n            # there are no fit methods for discrete distributions\n            if isinstance(self.dist, stats.rv_discrete):\n                raise NotImplementedError(\"This attribute is not a member \"\n                                          \"of the distribution\")\n            # the only positional argument is the data to be fitted\n            self.args = [self.dist.rvs(*dist_shapes, size=100, random_state=0, **kwds)]\n        elif method == 'rvs':\n            # add size keyword argument for data creation\n            kwds['size'] = 1000\n            kwds['random_state'] = 0\n            # keep shapes as positional arguments, omit linearly spaced data\n            self.args = args[1:]\n        elif method == 'pdf/pmf':\n            method = ('pmf' if isinstance(self.dist, stats.rv_discrete)\n                      else 'pdf')\n        elif method == 'logpdf/logpmf':\n            method = ('logpmf' if isinstance(self.dist, stats.rv_discrete)\n                      else 'logpdf')\n        elif method in ['ppf', 'isf']:\n            self.args = [np.linspace((0, 1), 100), *args[1:]]\n        elif method == 'moment':\n            # the first four moments may be optimized, so compute the fifth\n            self.args = [5, *args[1:]]\n        elif method.startswith('stats_'):\n            kwds['moments'] = method[6:]\n            method = 'stats'\n            self.args = args[1:]\n        elif method == 'entropy':\n            self.args = args[1:]\n    \n        self.method = getattr(self.dist, method)",
        "min_run_count": 2,
        "name": "stats.DistributionsAll.time_distribution",
        "number": 0,
        "param_names": [
            "dist_name",
            "method"
        ],
        "params": [
            [
                "'alpha'",
                "'anglit'",
                "'arcsine'",
                "'argus'",
                "'bernoulli'",
                "'beta'",
                "'betabinom'",
                "'betaprime'",
                "'binom'",
                "'boltzmann'",
                "'bradford'",
                "'burr'",
                "'burr12'",
                "'cauchy'",
                "'chi'",
                "'chi2'",
                "'cosine'",
                "'crystalball'",
                "'dgamma'",
                "'dlaplace'",
                "'dweibull'",
                "'erlang'",
                "'expon'",
                "'exponnorm'",
                "'exponpow'",
                "'exponweib'",
                "'f'",
                "'fatiguelife'",
                "'fisk'",
                "'foldcauchy'",
                "'foldnorm'",
                "'gamma'",
                "'gausshyper'",
                "'genexpon'",
                "'genextreme'",
                "'gengamma'",
                "'genhalflogistic'",
                "'geninvgauss'",
                "'genlogistic'",
                "'gennorm'",
                "'genpareto'",
                "'geom'",
                "'gilbrat'",
                "'gompertz'",
                "'gumbel_l'",
                "'gumbel_r'",
                "'halfcauchy'",
                "'halfgennorm'",
                "'halflogistic'",
                "'halfnorm'",
                "'hypergeom'",
                "'hypsecant'",
                "'invgamma'",
                "'invgauss'",
                "'invweibull'",
                "'johnsonsb'",
                "'johnsonsu'",
                "'kappa3'",
                "'kappa4'",
                "'ksone'",
                "'kstwo'",
                "'kstwobign'",
                "'laplace'",
                "'laplace_asymmetric'",
                "'levy'",
                "'levy_l'",
                "'levy_stable'",
                "'loggamma'",
                "'logistic'",
                "'loglaplace'",
                "'lognorm'",
                "'logser'",
                "'loguniform'",
                "'lomax'",
                "'maxwell'",
                "'mielke'",
                "'moyal'",
                "'nakagami'",
                "'nbinom'",
                "'ncf'",
                "'nchypergeom_fisher'",
                "'nchypergeom_wallenius'",
                "'nct'",
                "'ncx2'",
                "'nhypergeom'",
                "'norm'",
                "'norminvgauss'",
                "'pareto'",
                "'pearson3'",
                "'planck'",
                "'poisson'",
                "'powerlaw'",
                "'powerlognorm'",
                "'powernorm'",
                "'randint'",
                "'rayleigh'",
                "'rdist'",
                "'recipinvgauss'",
                "'reciprocal'",
                "'rice'",
                "'semicircular'",
                "'skellam'",
                "'skewcauchy'",
                "'skewnorm'",
                "'t'",
                "'trapezoid'",
                "'triang'",
                "'truncexpon'",
                "'truncnorm'",
                "'tukeylambda'",
                "'uniform'",
                "'vonmises'",
                "'vonmises_line'",
                "'wald'",
                "'weibull_max'",
                "'weibull_min'",
                "'wrapcauchy'",
                "'yulesimon'",
                "'zipf'",
                "'zipfian'"
            ],
            [
                "'pdf/pmf'",
                "'logpdf/logpmf'",
                "'cdf'",
                "'logcdf'",
                "'rvs'",
                "'fit'",
                "'sf'",
                "'logsf'",
                "'ppf'",
                "'isf'",
                "'moment'",
                "'stats_s'",
                "'stats_v'",
                "'stats_m'",
                "'stats_k'",
                "'stats_mvsk'",
                "'entropy'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f25ead4e627cf3167961e84504bc57749793d87f7ae5fdeef86ead5b79f761b7",
        "warmup_time": -1
    },
    "stats.GaussianKDE.time_gaussian_kde_evaluate_few_points": {
        "code": "class GaussianKDE:\n    def time_gaussian_kde_evaluate_few_points(self):\n        # test gaussian_kde evaluate on a small number of points\n        self.kernel(self.positions[:, :10])\n\n    def setup(self):\n        np.random.seed(12345678)\n        n = 2000\n        m1 = np.random.normal(size=n)\n        m2 = np.random.normal(scale=0.5, size=n)\n    \n        xmin = m1.min()\n        xmax = m1.max()\n        ymin = m2.min()\n        ymax = m2.max()\n    \n        X, Y = np.mgrid[xmin:xmax:200j, ymin:ymax:200j]\n        self.positions = np.vstack([X.ravel(), Y.ravel()])\n        values = np.vstack([m1, m2])\n        self.kernel = stats.gaussian_kde(values)",
        "min_run_count": 2,
        "name": "stats.GaussianKDE.time_gaussian_kde_evaluate_few_points",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e26a6406fba75b6323177dc436e67bdc94d81f0e5a2494b243ab16348dfaaa04",
        "warmup_time": -1
    },
    "stats.GaussianKDE.time_gaussian_kde_evaluate_many_points": {
        "code": "class GaussianKDE:\n    def time_gaussian_kde_evaluate_many_points(self):\n        # test gaussian_kde evaluate on many points\n        self.kernel(self.positions)\n\n    def setup(self):\n        np.random.seed(12345678)\n        n = 2000\n        m1 = np.random.normal(size=n)\n        m2 = np.random.normal(scale=0.5, size=n)\n    \n        xmin = m1.min()\n        xmax = m1.max()\n        ymin = m2.min()\n        ymax = m2.max()\n    \n        X, Y = np.mgrid[xmin:xmax:200j, ymin:ymax:200j]\n        self.positions = np.vstack([X.ravel(), Y.ravel()])\n        values = np.vstack([m1, m2])\n        self.kernel = stats.gaussian_kde(values)",
        "min_run_count": 2,
        "name": "stats.GaussianKDE.time_gaussian_kde_evaluate_many_points",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "020ca2c74779542e651854a57f96d06d52ca4d7f69c9238c982915bae56e70f6",
        "warmup_time": -1
    },
    "stats.GroupSampling.time_ortho_group": {
        "code": "class GroupSampling:\n    def time_ortho_group(self, dim):\n        stats.ortho_group.rvs(dim)\n\n    def setup(self, dim):\n        np.random.seed(12345678)",
        "min_run_count": 2,
        "name": "stats.GroupSampling.time_ortho_group",
        "number": 0,
        "param_names": [
            "dim"
        ],
        "params": [
            [
                "3",
                "10",
                "50",
                "200"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3bd7721ff032c5ca603db78ac629399c68cfeec09af5277ced816a307a6382d5",
        "warmup_time": -1
    },
    "stats.GroupSampling.time_special_ortho_group": {
        "code": "class GroupSampling:\n    def time_special_ortho_group(self, dim):\n        stats.special_ortho_group.rvs(dim)\n\n    def setup(self, dim):\n        np.random.seed(12345678)",
        "min_run_count": 2,
        "name": "stats.GroupSampling.time_special_ortho_group",
        "number": 0,
        "param_names": [
            "dim"
        ],
        "params": [
            [
                "3",
                "10",
                "50",
                "200"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5e6521ac414a671bf64d2a85f95777a39808e2882554394c0e5cf5ed9b3cdcd2",
        "warmup_time": -1
    },
    "stats.GroupSampling.time_unitary_group": {
        "code": "class GroupSampling:\n    def time_unitary_group(self, dim):\n        stats.unitary_group.rvs(dim)\n\n    def setup(self, dim):\n        np.random.seed(12345678)",
        "min_run_count": 2,
        "name": "stats.GroupSampling.time_unitary_group",
        "number": 0,
        "param_names": [
            "dim"
        ],
        "params": [
            [
                "3",
                "10",
                "50",
                "200"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a390c30a4e37f262ab3307d490460144a446aa60a4046c828a1605bc444932ca",
        "warmup_time": -1
    },
    "stats.InferentialStats.time_ttest_ind_diff_var": {
        "code": "class InferentialStats:\n    def time_ttest_ind_diff_var(self):\n        # test different sized sample with different variances\n        stats.ttest_ind(self.a, self.c)\n        stats.ttest_ind(self.a, self.c, equal_var=False)\n\n    def setup(self):\n        np.random.seed(12345678)\n        self.a = stats.norm.rvs(loc=5, scale=10, size=500)\n        self.b = stats.norm.rvs(loc=8, scale=10, size=20)\n        self.c = stats.norm.rvs(loc=8, scale=20, size=20)",
        "min_run_count": 2,
        "name": "stats.InferentialStats.time_ttest_ind_diff_var",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6cc7d8eef7288a17bea3b1690475da91b002d18c849985591137bba64ec99438",
        "warmup_time": -1
    },
    "stats.InferentialStats.time_ttest_ind_same_var": {
        "code": "class InferentialStats:\n    def time_ttest_ind_same_var(self):\n        # test different sized sample with variances\n        stats.ttest_ind(self.a, self.b)\n        stats.ttest_ind(self.a, self.b, equal_var=False)\n\n    def setup(self):\n        np.random.seed(12345678)\n        self.a = stats.norm.rvs(loc=5, scale=10, size=500)\n        self.b = stats.norm.rvs(loc=8, scale=10, size=20)\n        self.c = stats.norm.rvs(loc=8, scale=20, size=20)",
        "min_run_count": 2,
        "name": "stats.InferentialStats.time_ttest_ind_same_var",
        "number": 0,
        "param_names": [],
        "params": [],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "462d2cc05dd76e27f79702bef4899c50a49040a7355fb2872e64decfe9e5f1ec",
        "warmup_time": -1
    },
    "stats.Kendalltau.time_kendalltau": {
        "code": "class Kendalltau:\n    def time_kendalltau(self, nan_policy, method, variant):\n        tau, p_value = stats.kendalltau(self.a, self.b, nan_policy=nan_policy, method=method, variant=variant)\n\n    def setup(self, nan_policy, method, variant):\n        np.random.seed(12345678)\n        a = np.arange(200)\n        np.random.shuffle(a)\n        b = np.arange(200)\n        np.random.shuffle(b)\n        self.a = a\n        self.b = b",
        "min_run_count": 2,
        "name": "stats.Kendalltau.time_kendalltau",
        "number": 0,
        "param_names": [
            "nan_policy",
            "method",
            "variant"
        ],
        "params": [
            [
                "'propagate'",
                "'raise'",
                "'omit'"
            ],
            [
                "'auto'",
                "'asymptotic'",
                "'exact'"
            ],
            [
                "'b'",
                "'c'"
            ]
        ],
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "127e9378d41c5eb26027f153752cd6bacb3e083918b55a1e8c4dce8329fedbe6",
        "warmup_time": -1
    },
    "version": 2
}