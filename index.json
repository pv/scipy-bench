{"project": "scipy", "project_url": "https://scipy.org/scipylib/", "show_commit_url": "http://github.com/scipy/scipy/commit/", "hash_length": 8, "revision_to_hash": {"163": "53b4f5dcaf5c0417fc7ce9faf1b0579d162d6476", "165": "661356a3647cd5880ce7ccf335d9e9dd8640c3de", "814": "f7d2eb7e77a5338594d98398f895b01c268796ed", "962": "9646d5d97f5ebff100dcea543965e437563c333e", "998": "ed1680d2a3e79777c0176e6884f73417f2793cfc", "1117": "3672ce29a2872e66a95021266cafd3bf5c3f505e", "1407": "c73d4f61ca7042006fe6b954fda35131f98a9c16", "1439": "3bcec41a2dd9d5a43ce4d51379783d5f398f7571", "1521": "07b1fda7bac85f23d99533c0f3fce5a256e90cac", "1581": "c80602f9f8e8b5b35bbb86ca0761c9606847955d", "1699": "9707cbf05787b84b93e1b0049160aa48eff4418f", "1840": "1acaecf673d4b642ac254ad507dd12c5c22498bf", "2062": "e31b2fa8e58f52c4770e3f9241597967418b4217", "2114": "6a31f8fc214e5ea8c6cb38e07890f8573f4760d9", "2287": "d0c82520ae9337b4dd25599e52593f655b55c308", "3158": "8124f93fa21104b4bd4d8d5be8eefa42630b4a05", "3258": "30174bd2812627b4535bb8f3da05a28d1702c91b", "4726": "4becfc9e88bff7c26cb6eea13f8503a885947ffa", "5014": "d4f321a0c95d1802cb518b0a8bedbd024a87a05a", "5053": "8b569d34c71df8df89b1fe1213b76a5c539ae340", "5103": "f6aa9042a45e1b553b056f45cbc7dabe7aa34159", "5331": "e141a1e2844d58a555d5dafafc0e897372010b34", "5348": "898d1308a9f60f9226cc1a70eb7400a8889ff825", "5360": "7adc03e9966c11d4f4e2c434b5087d107faade30", "5433": "e96e5f71f33acf8cdae6b9ddf5087a71cd7c979a", "5728": "cdcb54a9c8b0130a7fe79525f7f7c519a49ec2d0", "5742": "e56406ff2f56be55a51877101483c10b93f59d33", "5746": "d026bb38bbf2fdd5bd3dfedcd7edf4f4bddbc817", "5747": "ef32daef5fc38963339c7f064d24a94fb892ef19", "5892": "689bde5476871d1f94edc5e2b1a7c37a137dac02", "5996": "e96c9dfb2d0b8ba6833b7844961ae8d5536a7a2d", "6001": "e33d27743fb59a09b9b2456f48e90306e29a4b3e", "6015": "7cd43653fd629517dd8dc8a79e6c8cf4e0f2aa56", "6041": "6f97786be33ee8e14249a05c8b1d8a523267f750", "6406": "887bddc96af76acf6e765a31c6e0c0f559aec979", "6478": "06046a5cd5a7569b601a32294bc37adc0072122d", "6502": "f7acac113f7b17bf3b95425940a1da1dfccef235", "6533": "a6e1f7ccbc7d5be2ca5caf2d08b06dab5cacbf01", "6547": "05504a21641dd2ca6dfcff22e2e3f4aa2c2542d1", "6553": "f356ab6a72a7707fb954e54d6419b0a575d54593", "6567": "89763337877c0f63fd26e4175edeba1b8e663a25", "6894": "7483939faa34272c102c59a7dc7b5d301ed71c74", "6915": "8edbea5375f1a561e224c6fbd9ca878b976ebff9", "7024": "549a7fed175493391dc554647affc7bef9f638da", "7046": "c82deecb7c99af5c775a710974761896d623f155", "7247": "7f7343ea6369edd44448341ad89be0381062d849", "7306": "4aa031063e85dfd927396cb1d37193835c651908", "7336": "772893ff951c61f15a710b3b773ac12e69254fa4", "7742": "51e320670ce9ce0c5a8120b0ea136cf6d447bba9", "7806": "61e42709d8e624b977a0ac6cc906f99b59fae696", "7863": "ffd7eba9d230f7008d73e22904d37862c91ff5c7", "8015": "827679b6f0149abb2c0e121749887012946b99c3", "8684": "f46008831247e3e1e8e2902dfbcf6c29e9545bf7", "8939": "1977dc37439d35b44289b650f0ca65bb66dd2827", "9003": "cdd6b32233bbecc3e8cbc82531905b74f3ea66eb", "10009": "3cd80e90db89e9c817c4408be2b29b17c0bb796f", "10483": "4b569aec3033c28b5bf3c432a0e7e8a9dce2ff1a", "10492": "6768fa51963f90d009e2dc8cb10fc818dd94beda", "10569": "1cc8beed5362ed290f5a8ddf4e99db49b4de6286", "10704": "f0cff311a8f397ec525db019d6f4758f29b51882", "10845": "f3ebcf8b4f1e559feb3e2db8aa2f2f433bcff0f3", "11142": "af356f42d6f32fc16d906e732533e48ebd8f4596", "11580": "9dc196c81e82551884d8d7adc8ac5b0de80c3ea4", "11679": "e4a767c015b9c7c5e3acb94dfd96f69b951d80f3", "11741": "e64e518c085a8528052a704c99e2b03c13fadcc1", "11791": "f2ec91c4908f9d67b5445fbfacce7f47518b35d1", "12717": "d53d3de97e2ddb10c245a291cf03b81b7b48a6bd", "12841": "62713a05bfabde98fbd9a5142ecff9d7a61e145d", "12859": "c5ded87e95d3e67f4aae7ab30c28cee5177869f9", "12991": "f9fbd6ccdbfb26698dbaa55bff3b00022ca6d31d", "13101": "88fc9b098c4e9604b280f16f7c5530b81ab1d45c", "13179": "fcdc3d7b7c1b950d874ac3e890cccde3e2de1c6c", "13996": "e153b5d374f888a4e22e7c2edf8b533ea6c0281a", "14034": "51ff6695fed7b4ff37ee38b545593bc907d40371", "14186": "9a73d7f15ba15896a3ec3b7ab0f10038338fe662", "14253": "3ab16af4cdbed03a8287701d4c2f518683354607", "14947": "a9fb36bc44bad4bbd2c1a41cb43c6f10925b38ae", "15200": "7f208fa57f6470e2c428b91bbfc38ed86a7d5269", "15298": "fe0b49ae3672d1a834abfb4c724187eeb5a3333e", "15389": "9f6581091932068900e7e21af2d5ecfbe0a6f344", "15406": "4d98200ed0db99418ffeb28e9927095cfdb3d100", "15505": "4b17e2bcbed2ef65cd14923a1ed5d1ccb6d8f8aa", "15524": "59f339e0fedf81df0f3368114344ed9499663315", "15688": "23fceb5f79394b59cf671a3fe4174b0c03983d66", "15930": "65df4865d14d3b1f631ae952d7d52b2f3c9b7937", "16030": "3a57f507b2c6bf95e34cea01587b6dc394824593", "16125": "fa3bfb902099b1a465b82c71b5bdca34e04c6b00", "16231": "35703c9a3aa58e5d84120fac049c4d09231890f3", "16259": "0c44e977973b4c92dc1a5c235b9380f5b11ec45d", "16290": "9bc28e1e8220ee06dcc1ca9166100267ce1b231d", "16470": "1d58ca44506f77bc4ea13e1a802e7c3232172c8a", "16524": "7f7214a9c492bfe4226918a9db4378628f325627", "16594": "90dd54e58da86323452a150f34481419e334b7bf", "16596": "d75a274abf13507a538a13b014acfd9cf4efeeeb", "16651": "0a09577fecfeaeae0806c2c27a2af6ac7865f4fa", "16656": "901ea9f3f206ffd98696e8290b4fa9dea798489c", "16788": "220d0bf072bdb191797e064631b70857bfd13a15", "16869": "fd7af6d2ec716d67026b9621119ef90e65504771", "16931": "f238270111976d00615686395df0986847c25132", "16975": "b240ba90d9edf38f37fca306d9851d870bc96b40", "17152": "995e4c452d45370d8fe93c234cedb2ffab083650", "17265": "7252c1f3bc0643daa81ff27b2b615181906cfc99", "17369": "4b77de5d43bbdf1d46ffc6c4725dc509f5bf24e0", "17478": "6c5c194581232ee7c530d67c62788e835eceffab", "17615": "a9f0bc8fb4109cfbc135e704d8d1dfdb4fd21fd7", "17692": "8813be3691e943390720bf1b47d4763317dbd3c5", "17746": "789989def56b274155a8cff456a98a93c75ef388", "17815": "be670a9d7fac8d5556b905fabca65d89e5366d7a", "17838": "05844c334c6dca983f4644e8acdef70d91f0131a", "17861": "29dbc361056df93fe659dcb7362fa2c0e647a14b", "17999": "46cbf563f5010b27017324ca66e1daffb6d21c47", "18132": "760a369e67b31b68a965f61f09f654077dab327c", "18152": "29d5fd86a55859ea032fd6d523ccbe02b4a91396", "18207": "4eccaeaa804a4d670413ee26de7006d19aad7243", "18289": "fa5b1cf3c2852d551c35d1972e9ba21f77fded73", "18296": "03b1092cf0e0bdebcbe98a44d289208a1e597416", "18355": "f3dd9cba8af8d3614c88561712c967a9c67c2b50", "18535": "93bf1a6a494fef15b383831529543c7c17635f24", "18778": "df8e1cd1169d761ef7e803ae5abf11adeceac187", "19028": "ac3d5a49a4aae16fa083b47028bb78a6103483d0", "19142": "dfe9a1f433ab555579d203c7307a4c608ef16fba", "19160": "60280a77377f3e8c7f4b484fb4b7cea30c6343eb", "19208": "4f57a98d143da67323058bc94af64f406a12879a", "19304": "1854f457ebd40179fe7dc7d9d2c99cfca5b650c5", "19344": "9bcaf3f6c5b9e936d6ed95bd6e189f40e89f8898", "19376": "11509c4a98edded6c59423ac44ca1b7f28fba1fd", "19413": "c99bf46cbbfa66823aa93ea29804fdd8f3c5a63d", "19479": "cce665baf3de85750bb84a532609aeb133df7223", "19505": "e6279ce7616436e5ebefd84d0a2bfae03a82b4ff", "19529": "b646ff4d221ad6ed1df3c4975ca9e6c7d30a39bd", "19587": "2e9cf89977676fcdac1206909e8999089d026780", "19676": "1fc6f171c1f5fec9eef6a74127b3cf4858cb632a", "19787": "6a5b55a80b3ee53d3022d0ec8b3284cba3d43821", "19853": "83eb32d32f9a4d8fcb03dc75478f39c8f1cb7686", "19993": "4e695a7065a18ae0ac9b16cf2301e0770abd9bd4", "20098": "4b50fdea8ec841106f071c368802ccc4a9cc2d54", "20133": "61efbf03d23fd3c4117f210becf6153c1cd6ddd9", "20145": "14142ff70d84a6ce74044a27919c850e893648f7", "20172": "5d6a88374a59863ac161c25a5949519587393879", "20232": "d8533b692315bf74e1bf9ac572ebdc83b4c958f4", "20350": "ce3eb0497d4d2efb515b8f57e03206cb0e2afb0e", "20532": "ba8fc0b8ab4e03273ec463b9eb20f326243e750e", "20605": "5ec16ca135fcc588ca3daa7b60ef7ee5bf330343", "20704": "7dfac8bd2a75b25874450f5fc0355393b34e5462", "20786": "f0f87ef022c49de377b19577ff36fd016ef41ec7", "20890": "3de8ba66a488e378cfc1a3387bb6c1e061dfa1d2", "20960": "98e28806dc0985fdb8749fdbbe3d78700f29fbe4", "21102": "368dbad596a0bd0d5a88a7aec381fdc912440ee1", "21142": "3488be84f0284be7fa501aba5bf0cfbe1673414d", "21178": "c5f8abc38167f03d27c2c90c87710f63cadf5ee6", "21185": "8de30ea433d6f2fb20497620b49d23097cb080c5", "21213": "722bfc3f2cb4884c7ef3eb87cefcb91ff7479208", "21290": "771e04aa0cc7333f9bdf3fa6ea197d93cd78153d", "21362": "a00b0572e14ce4923f64f72e9aca6c16895dff33", "21433": "c3fa90dcfcaef71658744c73578e9e7d915c81e9", "21463": "6229c5772aa2bfb9d243afc205e9a6b534c8c629", "21584": "657d86093b136e12116a735551c37c25d14afd78", "21684": "14864abbef7ced86f417c74c40c516c181bb22e6", "21953": "7baba41fb27f70416b64efc4bd6aba142797a25c", "22050": "333c7d170602157aff2eab6a68430bf46c4bba01", "22084": "b0f980a288a4f9332b0e9368125933106f6c220e", "22103": "80b786a4573d665d75ace51c75345a523c5788dd", "22134": "e1e44d12637997606b1bcc0c6de232349e11eee0", "22183": "d3c898ae07b4620e9442cd5deabda3f28e34c807", "22210": "600e7f576a1165026b1879ce708d8efb7cbc8109", "22273": "287a30728ea05c30c12b152ea5d2f3ba9a523043", "22451": "0d10fea581d5044bbecc8b4fbe8c11fc102f6592", "22520": "f05047763b7995f396c61355f08a9766785743d2", "22598": "dc072e7fbaf9967e789ae1198b0726376bbdef2b", "22668": "4bfc152f6ee1ca48c73c06e27f7ef021d729f496", "22812": "4c465bd7cad3355b72a12ac935927605819ce495", "23008": "f9e0c5548350828fc169878cc353721dc52eaa3f", "23095": "65733d06fcc3b5c2cef4a215170828e01f29f16d", "23247": "8741e6ce8dace87d24c9d6112b7bea1148cdd46d", "23355": "78904d646f6fea3736aa7698394aebd2872e2638", "23438": "0fcc74f0bc99a560ae731bf7a4796bfdd0e4cfce", "23513": "af73030cf76c40c4745503149917c54d3b3ff91f", "23519": "802f4eac0eadd6c1372b0cf6c04d97ea26c00c57", "23585": "893935170da083d5d354a3df39cb02b9d8861d17", "23619": "1a4463e21b9b9fb6f7ba2e9505d3cd192681cc76", "23650": "f533e9103e249ac56654626621aca3ec1bffff0e", "23670": "adc4f4f7bab120ccfab9383aba272954a0a12fb0", "23690": "76da841e41090c77f682afd77a951da455abed91", "23824": "e53897db8416c0165b32883396023009d47cff22", "23846": "16116d1b4699b86ee57eefc7477f723628409790", "23871": "0d4e1e800329ac948fce732766e829b4e89c21bd", "23910": "bc29b5bf5f8a1f5370407a4e33005277a53ef40b", "23915": "c9255cdc063ba1cf4424fab1cfcdfb3a6057211b", "23933": "04c59ef48e66675f9902e88163506f3843fccdfb", "23948": "3c3122f315c8ee37256f7dba181600bceefdd1b7", "23962": "24c3e04e67644ca60682999914e6a32fb4917daf", "23967": "ff8b9d9e87a585a820846d7f459d6156ba621c4d", "23971": "928a6d51e207a16777a8d7995aa445515e2e23cc", "23972": "0452b50c40a1dc9022a3c02f7b41e69db3f41d66", "23973": "a418cbd23d8fabbd18a47e1e898bf53d20645685", "23977": "f614064f35d00b626b20fc1c3bcda3decb483466", "23979": "1bee17531da6cc2c9b49785bf4f9359e5d74b645", "24006": "d77be984a2fc3ca8dab8aa1c502377dfb0b98e05", "24007": "787906970256257f187c3578a61f4a39ea56b459", "24008": "5e05af617d2b85f95fb10f1549b4905e48f18d3f", "24010": "53fac7a1d8a81d48be757632ad285b6fc76529ba", "24019": "52757d273bab9071a833bdef564f258cc0346d04", "24022": "da3bb089245b0b0a5f56213b09bf1639f3f2b4cb", "24023": "68f980bc6dc0839492bf0917075ba25ab9cbab24", "24028": "815d96b11fb32dd027d038501a901ddc4485b234", "24033": "73bc7e38909d302d4bb1f025d9d1f41bcafcdf7b", "24034": "49924cfc57dca960924fdf2d5fb064853c0b75b4", "24035": "6bb954d3ce5c743b008bc9036dc29e6f34640b80", "24037": "d63e15bf9dd33e156edbab0d4f63113d03ab9b04", "24038": "566ce19b81478df7418f6bf73641491a7b8937cb", "24043": "ef277bf9e812c95e65cc8d5a88d2b1647d6ecb05", "24044": "8fe52e3ca02ce7015733443838243017d7ba55d6", "24049": "fbaec455a36368156405f45dfb6317ea83f9a1c7", "24068": "6042a15236b91f3c21393fdbf4eb86428f3d6bd0", "24069": "b6d570d42bac988539e3b972a7ab3f0656e19d28", "24070": "6f0b508ca5354157f113f4ab416e8dfeacb27321", "24085": "f089f2c1ac91dc1265546cb95c787418333a7c82", "24088": "ebfd1487dc5187610992eea66aefa30b767a6e59", "24091": "2aba7032ae9b6ed8fcee497cb94571745f9b0d46", "24100": "5b9726bdf4812b23c206641145d16e80fd8e4bd4", "24102": "ecfc1810900dad11dd3c36f59d61f8c04a102cad", "24104": "f231b645f2ff94f5739c5a39adcab6e79d426a8b", "24109": "495631ee49c296bac2bd86be8e70e204f029b41b", "24110": "9beb4c56e3fb66c53246dabf5044b034fee72790", "24116": "c236d0fca6ee46b8c7b6b536d2c3c73426a76ad3", "24119": "1e161716a5e5c827573b9b88aa790af1864dfb1d", "24120": "4d15ee3e32d53a8bad00c0cf7d465ec27a5b876d", "24130": "f743bbea79e61890460992ecd95c222744dd8e1b", "24133": "5b5446f10c7b9fa9390c4313179e35a03c45c46c", "24134": "248bf1f6b892647b1a082beb5eddcd3a89500846", "24135": "f2177e4fc471ab209456f3b76abc9e15cbfb92d9", "24137": "30ff2fe96d3cadd53d87234e504b41f942528f16", "24138": "92bc9d550a731e05bb4eb6e8ca275cb981b70e5a", "24143": "a4532138aa617d3a1d1b8e43867687fc3a9ea205", "24145": "fead97bf26b0e0459acd8933959cdfeab3736e36", "24147": "9a1969cbae3e1fa045d9f66bce6c73cbd5054a9f", "24150": "425a317d4f089ae0fe3a9c9dabf129d9f3041456", "24152": "a03f15fe43cb68c132192af22deb73b69ef201bf", "24158": "e27a9c136d070dd3cdc38a539cc8ddb0269fff43", "24159": "e8f396b55bd2ef2ca31b4453fc1cb37fe7cd5b05", "24160": "8675d6e3bb84c813b4ab9bbad7a493e3c51d101c", "24173": "0538284d657a9a4538fc50525dc640cc419cd83d", "24178": "5bd4bfce8b8a84ef63f9b67b20429f5ef6aace72", "24179": "3921588a4944ba41bef1bbf78f6d888cfe7b0372", "24185": "9d7e827360eb82aef813e0a0cee4d5c1a1760163", "24187": "2903045e910cfb1eaafda8a6e4bcdf1d459ea8c1", "24192": "0c7545e7097b33c8e3290306e3370010357c1225", "24197": "c5b9f5e095fa895e7d2c80457d5ff535d4af08e5", "24199": "e3bf555a1a36441e735fd43c99e4517b9401bdb7", "24200": "f8f8ce1b1197b21443e0a31f28c1176ab12c4b85", "24201": "5c7a576039058531e70974a6e522470625db80be", "24202": "2774bec15e3cc3d62617c501404c09ad5f27ae1a", "24204": "06a436fb28bb51a2ec55edaba7695d20c20e8acd", "24208": "eefd95fc48862923956cab99388476aae1bf4df4", "24210": "8c82e688f467a31ad60de878aa73236bccce25b5", "24211": "4d2d14486e4591fac4875336fe8cacbdd019ceff", "24213": "c1372d8aa90a73d8a52f135529293ff4edb98fc8", "24216": "0e33004fc890c4352e75ae957215c66997de8ebf", "24217": "3a042050828b2dd42ed4a0cfd936e58fdec840d5", "24221": "07cb70ae23825fb4f5a3029dfaf75b2358d9ee9f", "24225": "ec358dd349d288298d76f968e8bed55ad7d539c8", "24226": "7aa886ef404087a0887ac61ddfe9b1d89c67f927", "24244": "ce0e23ecd77a772d56f4ab2252f9c4d25be30013", "24247": "27a5729600854d8ed05cbbd6c68d70f9451c1793", "24248": "fc85c265d3f79a0011c7b988ac2cbd25d757550a", "24254": "d6de7edb0316b52402d583a292a3c86d3324f189", "24256": "13cf23a09d88dfee81f8df6e79b194aa762c32cf", "24264": "a20ca9c3c825f56b9487737ca14f7ce7ea7ed71e", "24265": "3bc158b7053beac94e7f19efa52013ddfa0f0c25", "24270": "6aec34540bc0cee3edbb8cf5b4c293c31f41007c", "24271": "22af7baa3d60cf93c1f552294b8804837a842622", "24274": "56e6e7fdbea8bb34ecc9a1eb10ba088238d1237e", "24282": "01654ad120af2c62e343c4cf0daf8e896bc2c493", "24284": "a1931e932e8003a8dde254b9508a8d9a9c83e13c", "24286": "837df49f6fa3e940210dce456f7a86ddf515f00c", "24288": "55c5f093c8ac622b31711326fc2d49cfe337fda8", "24292": "6b6f068b9c8baae3a0858595a3c67a2ed5e9f92a", "24293": "30e33c24a1f76c31f04362817e7e92ca0cfd7a6c", "24294": "4838c04cc12191e3ad0b9fa166c1b442a655637e", "24295": "ae34ce4835949a8310d7c3d7bcb4a55aafd11f4f", "24298": "69f44c0b6b542abc85bc5100d17c6156df1a9972", "24301": "1f9cd42f99e1da60af70a9d8bda3692f92ae219b", "24302": "37d42b371c9936f728a68697497e850b0545b9fd", "24304": "66348b0fd5d71441ab590b3cb5081c63d27d61e5", "24305": "451b09fd56100f76c68c81a6bde07fdc41a5d09c", "24307": "9a686fa84b08fbf098bdfd9822157b9f5145ad25", "24309": "616effe80a3218da8d85db5d2865836b72119f7e", "24310": "b5fe88f9a8f95c2c0510d0d425566d9b9ae0b4c4", "24313": "24bc27b6f03f410eb014f00cfe5f2a6f6fd593e3", "24315": "e71cff75c439ed9aad75b110a141c94030fa6a8d", "24316": "f323585c7f64b6b2ea4ee676bc0f7056b7093fa6", "24325": "31ceb9fd38cc7d7276beca34c57b407c48ab50df", "24326": "a09b5feb24d24b8749b9a618f2a5b4e6a786555b", "24329": "a432f6dbb1f4a9c0810a1644bf82ff45976b04a3", "24331": "1150c4c033899a5a4556b7d34d6b137352b36b9e", "24335": "f9215eb1f0a8a3fe4807de6fc97fc6a710986577", "24337": "65a4247615bfb25285ce838599bb919fc3a52854", "24338": "3de0d580948bea50d820c1854254d9f75d32414d", "24341": "b818978f3580e05a3885006cae337f28bd2aaf7d", "24343": "e70b1af29bb5edc18dcf67fde60b775144121898", "24348": "eba29d69846ab1299976ff4af71c106188397ccc", "24353": "5f32c7e88c23cce430ff562b8020237c5dbb1419", "24354": "7ac26a178f385e4fa88d5c22951797a32ec8f38f", "24362": "bf3fdf2be0296c5a23c46f1bef04c86fd355d913", "24366": "ab2c51ca7d9eaf2ee93f89a9dd00ed67546999f4", "24374": "fef7d622f9754d0a8de5d67425913eda97338dab", "24376": "6143bb8f6428a4b6d64f4032d180c028c9c746df", "24380": "02a8b1288b311605265bc8473fed5822aeab55f8", "24381": "665d9b372b3c31f0eac4f2de4cff4ffe66f10b25", "24383": "9d47b6a552bc135c3fbbb4c5821d93c0159d57ff", "24386": "b7516f08d26de62f21d14c6a17cff25a7db7502a", "24388": "2342f3a5aefbac7a6f35f2e13fc4b68860d90c09", "24390": "d4035d1e05f2407029c047a93362d8537f2b6443", "24391": "a5e81e5e377529327cb3c098593fd78ae1562f00", "24392": "9eb4f55c619addc6ce29318e076c2481ecdfc909", "24393": "d047ff1abb57ffc5d2a7fdee57d0a2f21c061b99", "24394": "3fc8aec56d5378fd191dbcea294219147bd93ccc", "24400": "b225fd7a650c5beee18f26d98bd08d358f23a5d9", "24402": "6314c1c7d789d3a8323178cd91f581b589b2f11c", "24410": "ccd2362de84860cf5d823938dba06b563d86ef42", "24422": "1f873512f22596637f1d3758de823f61cc5b2869", "24423": "bb32270e7e9ef803aa6776122a01e45b83714371", "24425": "8727fbeba4603b5d0994ab9bd988f7b9fe3b8432", "24430": "ea05b4c4da48db7ae1241649c24fdd23e4e19b60", "24438": "0a782da3bf8c23daf20f15864b970116e65a5d73", "24443": "96ef0a8400e285664d6d713958129cc262ecc72e", "24450": "5b256648e3b190f9f9b79ca33afba579e1d96d38", "24458": "fef17e48f3caf55848ae6ef521060dbc8a483780", "24470": "13085782c84ddc5703c310211750179ab881d105", "24471": "a5641f9558ecf3bacd1051a85b47849f81a83820", "24473": "ac061394a703167df8fe7fe90ac298654ec939e6", "24480": "2190a7427a8d10a3a506294e87ff1330c426cb63", "24481": "78ee73123f27da225438b9f8b62e3d4ba9a91643", "24484": "035624f51b47693e7785062a5904cbe823f05015", "24485": "f6d8ce6ffb4585fd7cad2d1e3b5ff7861de58143", "24486": "fb0cd77669129bbb45f915f70b709bfcaa4bcae9", "24490": "7c82a105aa1a73a763c0c9abb0809ec7d20f8af5", "24491": "eccb1bb34b5d0986c49faea81efecf175d472793", "24492": "c102dc8bc1b2985077e5cd904c0752855995892c", "24493": "9092027b1df4183fb4df72e01363cfc292a4fa80", "24494": "a0746c90a9a8aa21ec2511809e85cf32dcc729cc", "24495": "b249da19591b12372a4289efe920db514700fa1a", "24510": "4774d47f38fa2a3d708132c92f55df761f11f90e", "24512": "1995688ac9d11db8b842371b7ac256fcc3decc45", "24519": "9340d8be8576c319f9c855c03f6080c29f0052e7", "24525": "4acec6897a6d8e1b79b040de14dede8eb34f940b", "24526": "882a911462ae4614752f3bc274227f8dcdf2fb68", "24529": "755b9b2cbeff03babf515b8b3831b8f83a831e8a", "24534": "e9ec381d90ad7121207e1dd91a68e94a9b363834", "24540": "f7cde3988169b158a01156c97fdf676d69e2974d", "24541": "d0a431ac40a47fa849a9db5884b5e5b88069f5ee", "24551": "27b4a183e90122ae2e454d9c719e22539c371e2b", "24556": "5b45e2f5becdf214fed593ea1986121f30c5ac96", "24557": "38ad9239970b9e995fdb9c0a81cda30635b6c642", "24558": "bf0189f742417483a8a0ed13024dce672a237a93", "24563": "a49499b23b6cb5ee61f30cfd11064f9a0ba70e73", "24564": "9a478e373e4ee63e62a6b012ca30261a6d969bd2", "24566": "83e5dea4ae4462540cbd7a50286ccb1714512891", "24569": "1fb8fcd07eda000711589c5012af535d9375baa8", "24571": "caee402971d02785a9efca04dc5796bcafc54fca", "24575": "c5afd4611e64051de6aab1cf4530d073e82dd0f6", "24578": "8ab8a383c418f4caee155b9e0ce57fde6ca4aadd", "24579": "adce65a80c6e58e7f62b1cbf66a2676babf8b8a8", "24583": "af138a0031c73bc75160229f858c983e299f669e", "24585": "1b2be4ddee19fe5cbc33da6a8930bd0dbcf1e003", "24587": "f571305357c5a70dcf973e306b4a9f39aac00c1c", "24589": "bbfb637eae929f34a5752fa5d42d5e58c8a48147", "24591": "28ef03ebf9ba8e8d35c2d4f0f954cd634c1e0d48", "24595": "363ec4e97fc22633c8ec967ecdacf1e7305cf642", "24597": "88b9e702d9fad080a40040e61b75e964a7df5c80", "24600": "6b198df6c99d930cb8da715a65c3981461e448af", "24602": "027de2edbaaaeb9526f50114751079c1a80cbf43", "24604": "663f70d5be1dc639ed24fe902e89265b4cb8c71f", "24606": "4b3eac2db65f3cfaf831b18be584545e1ff294b0", "24607": "43778443125f89e6dea54c36f5494c95f42a597b", "24609": "93214f36fe328925d2bcc34721e16f3d2fb9157d", "24611": "dc01670533ba0921a8fdcf208749707172ceb026", "24619": "6d0724aa2fe33d1584262654293caed7d909980c", "24621": "dc01ddada76e06f7e0dd979de28facfdbb38eaec", "24623": "7df0d1c092cef7537d9a375a8e662dff7e1f3afe", "24625": "8ec2e9e62ed977adcfef5103715bbbfe0a5a3caa", "24627": "5bb917770070401e62202e111284fcc7ce87f251", "24630": "3284c95cd53811cb55d908f89ce3ecf336cfaae8", "24632": "e4cfcbf4b7994278186d4537f5c1edd8fa93e609", "24635": "7e59317a864d8e380b7655ab9f1518d3e1e44a94", "24639": "517850bb4d204a1551e5d8a239230e7d18bbfb52", "24650": "3cd91b323556a8d27aa495f9f7325e865a69f7c4", "24651": "dc70c68d4fd9452befbf529414f8dd11209193ca", "24657": "5c5e1351c08d04d6c51e3268a3ea0c7220466f0c", "24660": "c04e6c986c2fbf3179ec283adf86d34395eadc62", "24661": "32c89ab962fef8676b2aff11b8149e952dcb98c4", "24662": "2fa34a4d63b2d1986cac87fdec27f402e9fa4129", "24667": "30678e8d45ca2d67a0307e77a353cb6e23be13b0", "24668": "fe625f213a35950935698027365efc4d03b7ab97", "24670": "16e2f3472d936d04f52bd8ff7acc6359d6aff72c", "24673": "8d91c76e04c44fc6112087a93d522d1f05405a1c", "24682": "32812c2fedf54b5fc44916e9d4b7b907c10703e4", "24683": "134270be9b4a1d4a3d1127af86dddb1ceeeab9df", "24684": "f0e54ac8e5326fb51ce1fb3b01b5a540112d1437", "24686": "48bce0fcd9c099c9e6621f3a0145bfbb6a7ff0dd", "24691": "d3376979f1a7afc54815a074383d0edccab11e53", "24697": "0cae03b559b3459787b5c3a6aea727aeb3890b93", "24701": "cee1e3ea4e374491809785c78756ec50f8e4cb21", "24703": "fb728f7356f38d4332bdef27c26e990af51e9c6e", "24705": "107d1ee3e33a029f2fb1f5ece9d6d373e5570d47", "24710": "787efe4d2829a1f9c177aa368e9d73202ee044e4", "24717": "b887d9e084b09e0761954d26eec2e571ca6f10f1", "24718": "8b58ac0e9e057e805d1d7aca876d777c0edf4d77", "24719": "567892ee39ccf8e0e5918803ddcd192b44fde338", "24720": "fa612823f2d8b27f495192a77859c664c7f8a811", "24721": "9cee79f04684292c62e5322e96669a022f707d60", "24722": "2ba739d33715ac583857fa7d0ad7ca8687294759", "24729": "4301df4731244ae0f68e6af7babd877a894777fd", "24730": "9ec86720814075bf2433f3bbf4108d45781b298a", "24731": "a67177d1b126ac34a5f298721b82cf55b8dfe491", "24732": "1d6a0b6750a674a6d17abf42a6cc12cb694b7501", "24752": "b44883d7196fd017a428876e0dea1d2b2ec1e2b8", "24753": "f7173d1267cc9692f1429ebe2b9e8ba6fff29858", "24754": "a7381173710d333feaafb1ce6407e5e739a21213", "24757": "47d6700e9993f1e17c54c184360638db3fe7d627", "24759": "6326f4d27d9ae2283374b9894fdccb82bca86738", "24760": "649e90cc758559a85149525ed728ba420c639fda", "24775": "ba70c8d2cee700e477b2048bdb43f416a811fec1", "24776": "abb010ee0e9aba3a6706f3cb18fdb9fb873eed5c", "24778": "4733a1c6850273135a51d8910428eef2b12effbe", "24780": "3d60d76dc0a4bbbd063110f3271bffdafb01f232", "24782": "8362125fb9d35e1bf3f221ff7c7bace3ba92e76d", "24787": "7cb3d751756907238996502b92709dc45e1c6596", "24791": "1854617570302fc593da9002dd13be65e5ba3ee2", "24792": "d62ab82a8103fc2f39f5e82f559a8a7d1df8a58d", "24793": "83a1a2e6db69cdfc1e9716dd5381a1a4e78265b2", "24802": "9f3b36b07e1036ca8d23e101b3abf92940698ae0", "24805": "2570d24738d48cabb93c58936a110bbe5b3b0963", "24809": "286ca06b80eeb21b934a34a30af42446d637db62", "24811": "86ffae01f4d0ea15fa99b0d29af95e32cb79c137", "24813": "be591d5472f69dc47d971d1c69c73ae164034808", "24818": "2ddbe387f666d196e62df87439fe659a1955b5ec", "24827": "7eae53224c1b49a719597b7c9f2cdded68534427", "24829": "b35a1b5c811ef09cfb77ac9a45bb887e26de01e4", "24835": "3f397061b5b9ed34c75a358fb4bda0172e58711c", "24839": "61efe689723231d72f2e5ba6d01924cb97c5240e", "24841": "fa6ed8b44d8ed1650e94a80490a76b4d2d44945f", "24842": "7646f10e0f1adca2a27aa3a7c2cb9766bbb4265e", "24849": "19b6f84d94076541260ba005431839e8deda6fc4", "24850": "11aa950d4f1c43270ca725ca0dee9430d9865f31", "24852": "8067648fcc8d55f858c7accaf0e631e850fd321f", "24853": "e6c3b720c9c05dd9066b45bdecf61d5e3d7e71b2", "24854": "5e44f9f62179a9f619998cc858355821b6549a90", "24857": "8a6ac2cfb353dcd5be3edca9645ecf4bd32a9c23", "24860": "15225f9e6f11a228aa9e9c693ab797841e427ad6", "24861": "d0e41268ec96f872225c72b0b79f457f08b46a92", "24863": "0eb654773f5f1ddc9af920f0698cb452d4cb7a9c", "24866": "4640731c6816b430a2a6bb29ec25a076d9fcacf3", "24869": "6855358b88b5d2a074c0d8c8aab961ebefef829b", "24870": "9f1adddb15a0b7a1a1d80e4cc971b6af4e6f906b", "24871": "a4c74a59b047b359d7f4871d89c496594fd07217", "24872": "9754d19e14dcb3d6dd87314570968f94f0a2e2ab", "24875": "be3078bd3fcac7a74dfd61f1291c4169d2798b97", "24877": "ec16ddc696cf4858b7e12e81b557f95b2cca83fd", "24879": "79db34afd921895e91c69379fc27a64bfd047dc9", "24881": "31f9800b4a5734bb703200e6ed959370b21ee0d8", "24882": "d06791710acae119e099829087f8e1aedc4e1bd7", "24885": "411fbbda0f942fcce3e4b314efb11c4553baaa7c", "24889": "d4441f3fc2a98b63330441fb622c7694626a6bf9", "24890": "e2a85dddd8addb7c4904d22d96c66c540319e658", "24891": "118f1c2abebb2e713898eac3c27f40bff9716066", "24901": "eddc8385b89a09e6ed48bafaaae444c1c93d5a76", "24902": "8040f6706acf43f4cbdc4705fe507cd459a60fdc", "24906": "bf4e01b5862a8f20dd79f799ac2330f40cb93897", "24908": "9f61c6530c994d020e51fc176f67c93ffb4e07a8", "24910": "ebb98bc570bb33a12049d58d2b4f58b676cd6e2e", "24913": "8ba0b8ec7701b10fe6396bb4282bb4ec3b66dd34", "24914": "01c65a73a4d7dd1153ec16b1deb85d548e0e2e6d", "24916": "6fd30525983b853a58461ff81355ca1df51c9acd", "24920": "0bd2b3fe014ab53873f23e74bbf8e075ee854e92", "24921": "7d760dd4da7677c963b98c57d1db81d10be7e845", "24923": "392c14311811d7891d2fdd54527e774481d849f8", "24924": "0befca4e52fd3df050aae05ebfbe80e6ff96c1c2", "24927": "09a001e2bdfa3cf604dd5f15f2a20bd48274fa35", "24928": "0f71d23d1c4e30a9f62d311fa713c8446d5c914b", "24929": "1c3ca9f3fbb2fa418f5388971be25399ab29bfba", "24931": "5c2bef4c8cdd8dcd4594088a80382a19a2d42034", "24932": "4801476b7002cea14d35ac8dde27c45baae93456", "24935": "23b61913311eb9e57f9c7afe317838667348cd78", "24939": "0d4934675df5b88ef21691a8a40d7e9e70af3370", "24941": "6d69fc8496774bbc4b0ba5dea6df3be803b0f489", "24942": "0d464eba2692666f43e3a23c9662515ffa9d6f96", "24944": "72f1fa497c66c83ab754021026af74492f150ef4", "24951": "523b71495d2ed79616b2757e8ab94538d9667e7f", "24952": "297e602eb956090e451bc614ab09abdad1ffd2bd", "24982": "88c496f72e76b30936c37eacd9d95ec30568aed4", "25012": "061aca619504e198509969fbe5908d1085966889", "25030": "ff72ef8d8ef64e9a125d3fca0dec1c0cb5b6c38d", "25040": "f4b5605031f738bc87ae4e193d614d525b98ffba", "25063": "c5db5e291624c4d5ef4960ed7da3d4a413d8bcb1", "25073": "37cfd40366c6c15a714d53567ed0e3617a14f02f", "25111": "ddbd9ce3890c774d720c78d9b3befc8eff00365e", "25113": "a7131faf68a0e11f70ad4bc2db25876d0665d4ef", "25127": "b2ce6b179b7419d43dce74f85d02c5c425991c99", "25129": "5e04d0f44fc142c9f00131ef6eb3231251eecce1", "25131": "dbc91c1032c1f7df9cc4c3dd8caa03ba8a34b67f", "25135": "0e593891786b3ebeec4a9fa4812d35018b36ff6d", "25136": "0a7bc723d105288f4b728305733ed8cb3c8feeb5", "25139": "4c0fd79391e3b2ec2738bf85bb5dab366dcd12e4", "25151": "ac49c61d92fc11719b4a6a1ad09145ee607dd76f", "25159": "655ce1bd180e2554a12d501fea0f24a0c6e8123a", "25164": "4bf5b9ffb96d361f134f71a1566065fe4a68d87c", "25172": "8cb50e850c387346cce36c30ee31655cded3da12", "25181": "a9b51c8368910378218ac67709a3890eda986d07", "25185": "fd6f6d670909681127be0e545bc1a116d6b74a79", "25189": "fb7127c5d60184eeb49a45a72fb8779a35217adf", "25190": "2ea67057b1bbce3a253af89a92ee93ffc9c97525", "25193": "393a19294279e33a6422a96f4bfbbaef17cd008b", "25195": "589c9afe41774ee96ec121f1867361146add8276", "25206": "4c7b25e4816f6246f30bdfbe5cd7d258f4f107e6", "25208": "74061585a07df61633efb106f775e4cac9dbad4e", "25209": "f94fe298f3bb15f78a29e178b090e01389e2e175", "25213": "6a950ef61871e05d3618628ab2052db5682f3dfb", "25214": "3ff5aaea8b84a8df751b92087656cebe1df2441e", "25216": "95704c3bda7ce1d2623e603ea19073139579f291", "25217": "ce849776691e3ffa69eb729f14ff8d126f809663", "25218": "609450c6e7a421c519512746f4d1cc25e7fbb304", "25220": "db37f96da8a5a1356e28948340e65958d105ce3f", "25223": "9c0baa55198a8256155c7643078368b3ae8a1256", "25224": "3f11e32f3d07e6035b46f77eafec4359875a0416", "25225": "970e3f827dcc678fd363329aa1577bfa52f1509f", "25226": "6309b089eaca106954896418ac27da92c5ff7ff8", "25227": "9aa7e98f207784aff465d1ad2eb83fb6f2e480b2", "25228": "289ae46ae4b3e1abbf135e204c62908aeadc7d85", "25239": "241ec3de7a2e2511e9e8d6a7e873d6715efb551e", "25240": "e777eb9e4a4cd9844629a3c37b3e94902328ad0b", "25241": "0b273b09519f4a38415a6d6904ae60b801108ec2", "25244": "c41e7e977bb56564dd6b059007b6edbe39a9dcb6", "25249": "f2f10b043aa4042bf0db833cc30448bb4e1f8d00", "25254": "8a12382e17dc902d64e5980f5060d3ac59c86075", "25258": "312b706c1d98980ed140adae943d41f9f7dc08f5", "25261": "dda28ffa4ae3386d8ee2640419ec82d4c0180096", "25264": "f79de4bd5616ee8d9ad9a6cc5f28d9d3fc910dda", "25267": "b7b3520c8d5de4580426ee95a561657130f414cf", "25268": "36611b8ea3142f4d98be28ceb16bf75f8988f5a0", "25269": "3325ce1bc29a300b563388718a1fd629eccd805a", "25271": "ca59fa9e86a0bf294772a3bd968e7b2f0423e956", "25272": "8beb2c37f497aea9be869626b50e2d246dbba866", "25273": "7022ef5dd4935a7664f230b6af17bdb4f834e1eb", "25274": "4fab4fdf8013ad9cc0d90e47eb0b183cd7ba6705", "25289": "1d8b34b47d2b881ea904f4c9bf4c49b3fa36b29a", "25293": "31766cb43648b27089167d6b84db9f2a8543d80c", "25294": "57dd16364968d2ec9d85f929465e151d0d880fa2", "25295": "816bdcfb90d2b6d8c90ec438d497e35abb5ecf59", "25296": "4e3d82268eae3c89e94ff5f3c3774bb12c12982a", "25301": "01ba9632e3333c0666070742d346a696d992a965", "25303": "30ed8723d0c32617f2368688f6b0e1dbdbe9b8ed", "25304": "6bd8975294ec0d66d159195d3ffb50d336eb6410", "25308": "07aee7809422f87bd4d6ace5fd5541ec1f29d859", "25309": "50370731758eabbccefa2a968dcf59ab1ed2303b", "25310": "4169c49cf8e50ba0fea7e2061e413fa3a8091795", "25311": "e2d9a94bb24744e6ce7158f5c3a48a0f8178930e", "25320": "e13278e712ac33c6110b5d48a8da0acfa7768b71", "25323": "62cda72a2b69ff519a70ac0c725880012d44b6f8", "25330": "99fb38788fec372422a695a5e4694edcd01d851f", "25334": "e0df4d39e96c06556bd8cfbf3bfd764786668a03", "25366": "4ba94791e4b0f81f76cc8901f238c7607f9f1192", "25368": "8b3eab39f8c7ceac5f2206339722204ab6db4317", "25369": "29fc32814af6dec485e352388b69152dba5dda5a", "25370": "8bc35a85e8d495d337314409f033359cb59f87b5", "25373": "d3370bfab97453e3266f3e8ef43f95bf98dbee43", "25383": "505dd90d3ec5972b0e825ecf2a4204aff86e3537", "25384": "9e3e86dd8f809e279d4a7f1695bc8ed07294deab", "25385": "283cdbb3fc48a4a874f14b13c25b4c11ad543cb5", "25387": "f4fb3a1c1daa0b57f6801f2cdbe56dfc5040689c", "25388": "614d3d90adb1034a5380751019052e18463596fe", "25389": "eea0ccc80d0f4e10423b25a2e2e33473a74a4720", "25396": "ac5a064efc4500e25d5c6106ce8bacf770a9e765", "25397": "102cfa6cc55ece537fe5b0b72a7aae63c877b3b2", "25398": "0765482e9a7cd7a7975f6161d2ab91994762ac8e", "25399": "01d8bfb6f239df4ce70c799b9b485b53733c9911", "25404": "4b5fa6b17bd69d0a82e6c98db3e8bb281bbe0147", "25405": "ebc0c581c2fd695d4a4c6ec1b235b7bef2cb1eb5", "25407": "3c120b1e87ca52f246de5fb9d48fff9b0a1edd85", "25408": "b1189c9f3676d24a2bbf38ce107b5a7bb1237f22", "25410": "063ab48565019880d614492fe7f866728ea45e79", "25411": "44d5bd646e1bcdf8e511ad9ac8d4c1594828916b", "25412": "3bf0af5312f6b6b82bef5fbc8ce1b802522b2d21", "25415": "4f0f0cf9db7e26c1b521dc9ecea161dcffec5bd1", "25416": "1885c4d45bfb9e702aa31e3e4d670d533b479f41", "25417": "44c74d263ee3d665054fce06f865ca972dfc0809", "25418": "8692c887ac341ace4183f115c55290ec9daf470b", "25425": "f3a629990a7254e81a72f7a2c111855dd9d8c50d", "25426": "a1fbf06eca4b7c7a9293fbeb8b37f7c3bddbd838", "25427": "2cd82eaf7ea85dd5c14466b7efc7a8132d60c842", "25433": "08480de7dcd099d738ebfa9200c4264d4e139b90", "25436": "4ff8b13b27db34c73f9b48e1203e05a86744250e", "25438": "5e6afeef48d9ec2d0dd7baaa3108545b999039ed", "25439": "c436918f8a6e9a65dea67072d5423cb3a1af68cf", "25440": "688295d11b2c9c571243537216b8a152fc7ce258", "25444": "1eaaae30b5daac8c5e54fd821b07558b3a3c9b25", "25446": "034b1d3103b18d34565b8d8d9f32bf2fcf6b94d5", "25448": "f7f31b4574c9665afd87068fb466f78a7bc37dd6", "25454": "40a47a7ee1d62ac3ef6caf9abf19f9df7a3c76cb", "25455": "01d6a8b4eae49021d3689e9cb916a96a2bda3562", "25456": "bf3ea59982a552e65f0388d4dd17b256b962adbb", "25466": "21e64bb1a88d46d0ad3407b9fe6d92bb0f71c55f", "25468": "00229c863c39e7d16127674c31b89dcc6c08b435", "25472": "96caa9dab5b6921c2c85899d198c9503d3c6c652", "25474": "cfd571a9d584635ac7b3c0515cd0823f06fdecf9", "25475": "b8eb3b349a997a04e5cdb19dfca0e6b0ddac1580", "25476": "21558645a039ad0d042c5825baea83a306a55794", "25477": "8ea3fe392772ad49c294e48f1e71c5b1e7201f36", "25479": "5309179c4e2c8d436a82e19470218f756120b509", "25480": "28d4244b6f5c1543755e586f27f9261d0f84153b", "25483": "fafb338b2c93e18d2faa8109bc9834933a7e25f9", "25484": "8c7973148c5dea4a28e0e082f8c1f182313b72c1", "25488": "3f4396e7c8e21ea0c432c1747b221e64c162b6f5", "25489": "6249af4be5a62e6fcf8d4b3e57f27649b284179f", "25491": "3af12341854f9f9a6ef0a3a9c853e80bcc5e8002", "25493": "2335c2025d535d0ef48949bef7e4b39077c0ea05", "25495": "b285d269decb8ed11079c9d4e450391eda26e9ad", "25496": "2ed8169c5c4c9181cd38a52db614c692eb802c15", "25498": "1948a0b2c16389f6a70531c9c788592ed3c8b468", "25501": "7dd0cd0365b2eda4484efed798000309e7649c77", "25503": "2ee38a57e2fd7604beb2eef0e042fa3ff7e0317c", "25504": "047ab37380584cdb6ac30cd01109c21923368dca", "25505": "5076928fc94720e7a711d07b02ceec4b7235cec9", "25506": "a534a56910233707cbfa4962f9c268d388e9379a", "25507": "55ba7c8432b8908f32632f8c3c1887b1af43425e", "25510": "1344d041754a897eed7fd14da57196294b73d7db", "25519": "72419c6db34782c498399c6fa5062a4a402cd386", "25520": "1a10291e02a88853c8a378148b4c876d250a323c", "25521": "0be14294c1346f45b0366aca6a97cf0a8e4b94b6", "25526": "da02c95d594ad260a30942bfa6d4ec49671c1ee8", "25530": "b89e2806b0ecd48e128767ab60973fecc69f1f1c", "25532": "d866f8342a1c0f1fb8175460e520ea264bca1ca5", "25535": "25cfc7d91ba3f3964b0d6a79efa7eb465d252bb4", "25537": "686c054ba86197fd8965a66b0daef6fe13db7201", "25538": "d3416c7675d45c81bd19dfed36267832ddc453b9", "25541": "1eae2ea615d9298e938a335ff2bc86ce345cd247", "25542": "3b4a30cbf580a1ea07bf48abf4bbea708b2018dd", "25544": "9e459bc4a69b711ab19bed3e312a3a6002bc1560", "25546": "196756b275aeb16b699bff245f2070e421c4e134", "25547": "47e6df13d31ded358ab5dbd6c5fa316fea8c56e5", "25555": "feeccfb6845184869525c9135aecb0ef9bd6a82e", "25556": "7752f9611ccc272df013d469a61e9da8e85ae71a", "25557": "51fc6cfd128d17aa22a8972e0adfb65d63a7268d", "25559": "30e9c92eb89cfc92d6988fb77402475c24f90758", "25561": "d9ff9a0f6a18d19c60545f998271ec331025df12", "25564": "fadab68044339b8d2fa194e1c71a907a6ecf0051", "25566": "1ca2eb245ca1bcf649dfda6922341a0bb9ad9326", "25568": "424a47cb05ec7a08f248502fa8b027f6d8769893", "25569": "e93a717d92f3ef1b126861554dfeb8df09bf594c", "25570": "b9945be833ad0c01410d26faab5c69a40371a8b8", "25573": "c734dacd61c5962a86ab3cc4bf2891fc94b720a6", "25575": "bc3e7d7bd3927d23bf94b081fc43a550c07082fc", "25576": "b15fe7785da0efa637c281d0fbc2535d250e86fa", "25579": "353f2563896ba3d077f4a4a19b938a7ff101db21", "25583": "1d017125a0e721a72edd65d261da057bd15d4e37", "25584": "48a876262d95fafbc44e7cbc7baa1ffd685ad659", "25589": "875418c12ea77df792fe61be2f2471c883a7a36c", "25592": "27ac968691b3aa677571d8e950cffd8404dfac58", "25593": "08b0b8d870eddd1cbe4d94037dcc76fcc1af0271", "25598": "dda87ae6cea67284d26f427c0dbc1f74a36cd17f", "25599": "0cb7ab309e291e431fc919c1fa8a6809aefd93fe", "25600": "914523af3bc03fe7bf61f621363fca27e97ca1d6", "25601": "445147c2326c88f98a600652d40553560d5efb1e", "25605": "8e30f7797bd1ee442f4f1a25172e4402521c1e16", "25615": "2850365e2e447b8e4c1d5ede5193afa5bc682804", "25616": "7815f954c05edf745cc5d1c55bca83c7811f98b9", "25619": "4378d86a62befa716691dcc9a66682482ba4b3c1", "25620": "67c30a5edf68f5d182b8919b8bd226cc98de4e47", "25621": "bd7124e5afaa7ccb76b0af851554842c473b61d2", "25623": "a240c178a3f80461d9aef7daf3d4d9de5bdbdfcb", "25624": "c2ed45da7aa3716a864e176f2f41be9f7f93dfd6", "25627": "5f4c4d802e5a56708d86909af6e5685cd95e6e66", "25628": "b20293fabec764aa7316ef718da906a531591aa4", "25629": "12fa74e97d3d18ca3a4e6991327663e88462f238", "25651": "28d62bca3f5344ce6bbabaadfbfe2c2880746fa0", "25653": "e4e3b89a95babcbd07e85670f0b67cb16af0b84a", "25656": "bf230f80923c6503dfcbabcf230ecf810fde13d5", "25657": "02563b2c873f042f377ec19b08ac6c681b826897", "25662": "8de4fa75b126416627978baaf137c05cb00f847e", "25667": "7a7843bc1b54968ee99796333743c73608c0638d", "25669": "9ad1a8056eb3a12d5c4cdb136de6570b51969c05", "25670": "9c0d08d7d11fc33311a96d2ac3ad73c8f6e3df00", "25671": "a2ae3e64c6858ba4899e5e21fa4c0a65c2661cfa", "25673": "882849f81e4eda89008261b691206c5ae7795d26", "25676": "37b650e04f3bf49bc11cfcd18f2848ad4f957a0d", "25683": "6500f43abe71070b3b037d52ad91dfbcc3e5ba7c", "25684": "1fdadbeb84b88364730f013c19fe4b0c7b394e92", "25685": "79a8241bad347955bb3bbec8074402be40a52969", "25686": "5621f933e8434ebc6123dcb485e9836bf43e7be1", "25687": "d286f8525c16b2cd4e179dea2c77b6b09622aff9", "25688": "1caf2339491aa8a1f9d018d1b202228ea85b022c", "25693": "d6a9dc725d6a770da5504027969bd43d5264a014", "25694": "db8d87070274fb40ce3a3512d9ef186a38853b1a", "25701": "2ed761eaada04535b573aeb826559cb374e67390", "25704": "43b0699d5d33ae56e0c1267e6f822e0c1cfe070b", "25705": "fece9d4f861eb43c7bbb5d8cc268d510719ca168", "25706": "d1432f182fbbe8a57264ca7d6388ffd46bbbfbd5", "25708": "aa3a12dc0bfd4b636d57bfd1f4baf8117496b988", "25709": "9d60a26ed35dbab302daf4e23545f29a56a6d453", "25713": "61b3db413601b6ed3e5fe352b689026e860c3fd6", "25714": "79e64c140a518bc85d9105718301509f43e51444", "25716": "35326cf10bdc3b19a42e2746401796e0fb49f473", "25720": "d4789babc26abcf09130b411df10eb72f8401d54", "25723": "e04c172ab20810a79e15949a1b1a061e540b780c", "25724": "a8b66ec40e007cf230761305fa483370328b5f09", "25729": "e31707abb2d296f638b9ca4158554bd76a67f470", "25730": "fc4a0e862169481a962900dc5e0bfed243906e33", "25733": "2eeed791ce100fd2bf127967ec41759ad3b4598c", "25736": "14a4def5e5887d5e0224a5d00dea989e8a958af7", "25737": "11b5bf59df3af412103829b2b80efd64cddce0e9", "25740": "be31b6ffb6046af6d5708fce49abc71c7257b2ac", "25746": "297b569a1d0a1e85a53094a1c40c9b6356a24eb8", "25748": "b827a81821d459b12224b2e24db5d365c309abeb", "25751": "43b2133fc3295124d96bc9b8121c7652e267f3f5", "25753": "7fbdc7f5f24f153d043f26b030d7d9f72dd11b13", "25758": "67719363984c3ab81b5ef43a96eb5ffb1b53ede1", "25760": "224b221f5da51bb9d8bb8ae239287c89d0d8e25a", "25773": "49d033cc579d1a5b06bde224fd8595239d7d49c6", "25776": "c0bd7f444df2b62f3f3b891de69a84a46b39808f", "25777": "9bf988462388c4eeb82c36c5cbdea59e9005c017", "25778": "f59666fe6cbdc7631e19fe2ae38ae135449c3fd2", "25781": "19acfed431060aafaa963f7e530c95e70cd4b85c", "25784": "3a0513efb4c1803d83fc949164c342a46d2b915d", "25785": "d4230a93c77b5bf1cf312e78907f66b7c09b8707", "25790": "57c1ec253d01a6b8f609477eed74b3c83f533e12", "25793": "389b2e0a53efc2bcd6b46203bae62638ffefe2d8", "25806": "4c5004294aad55a9233b26d78866c05936ff52f5", "25825": "93b864bd66f3f05de8746564d67a0fd8926b5da5", "25828": "2af2d98da57add13019836ae4ec5abdff4ebdad1", "25834": "e198e0a819a0ae89e9d161076ad5bdc8466a40bc", "25837": "8e2c06f0a0f363c7141a432ca7cd479d38efa9ef", "25840": "383ce6bf894a8ed38f508cf8293b002efeba7d0e", "25843": "de3d5abcd7aac1c2067a68cc831634a1a46aeb58", "25844": "2a9e4923aa2be5cd54ccf2196fc0da32fe459e76", "25853": "3aec550bcf88af745873444140c028f4cb586883", "25854": "0ac4b6bd502d82a46bf2e0958e17e1234bd6bd07", "25855": "982fe8ce52b97621d69d79847e6c51626c351175", "25856": "d7ad9b3410bd7cdd1091553e8855e01c5870755c", "25857": "1d6d7b86d21185f3b75b735bdbc4ea5e2b6aaf48", "25859": "47b132c5d07b445a13a0c5ab0d51d9371974cb9f", "25860": "232092afebf7a59949dca5595aaac3446814293c", "25863": "46b359bfb54072dae61882731bb2e766e38ba393", "25866": "4741d4d430453d6ddc0f1ddadee8175801732657", "25867": "a18ffca5b2b83c02632c6768ab6929d9027515b0", "25869": "52d1f689130ef66aab63f5c6185daa786302ff1f", "25870": "ab9e9f17e0b7b2d618c4d4d8402cd4c0c200d6c0", "25879": "2a1dc2ae8d2c944209f3053d1285dbe5edaff6cc", "25899": "803588eae04af71d88e92253b698edc0f09d0ccc", "25907": "5bd7a6a8477badd6bdc718c4b38837d08e0413c7", "25913": "076116065ae74462a003fdd26620db712a05999a", "25914": "3a8a3a1d4657254a6611e77e9c28feafa26e6645", "25917": "1ba7570a9d337fee524d055950e01b23c909792c", "25921": "9d3bcca4485b648febacfb4570ea16b11c9de031", "25926": "7d1c5b7466097d14eb175086fd5ebdb7510f6a7b", "25927": "06f51e32837b4f78f2630701091cd98ff4c6ddf7", "25934": "04265ba99afd70d42fd643a63958981b652ddec5", "25936": "d756d73d00d3f5f15b7c6d239e3a0384751392ec", "25937": "4d14ae536e49604f677873169be73c13b8b2c665", "25951": "d975f641b22738d7c06f7310563e0289ca04aa18", "25953": "436370bb949c666e97289cb568022991351894b5", "25955": "3e741b94408c18c65c3195ca320d5a09491202dd", "25957": "73e5f8f655110a5174fd8de0d391fa52c7c9b82b", "25962": "f85b3ee543ef46e4183cc1f649b59dfa821323e6", "25964": "97c42a65b4233ad51e4d88156fda9ac169c0f284", "25972": "c24906859ccddf09d90450c62bc4f05c5e1a25e5", "25973": "8fa4b7364d98659dd8fe28727f60d99a14b95850", "25974": "3c4b980d1f347f2fcbf836c7bf61d546a764cb5c", "25976": "3625e8da6331509faa075ad90876782300dfe976", "25977": "f7eb3d82f3aa1fb55875a98d18b5b1a8a4b635cb", "25979": "b679fad988d1192f07778b144c216b898944815e", "25981": "8bb5fa9a2143ff865a421895c3ab504ea2e6124c", "25986": "d988989c3b6cb17e5107de00b524e681ebfe4211", "25987": "88ac4f5c12749c7c7e55821404723849499d1695", "25988": "853b5a21a49fb3751fc6c9059139674318e6e0fe", "25989": "0fdfe6ea96b905528fbfede240f12e9b656ff49a", "25990": "75df04600672bbf62e310f8931cc3957b9a120a2", "25997": "70e0669d577b4356e78e66bfaeefe4ae307df612", "26003": "ff177d92b79167eb5de593c9de41d3ceb97ab189", "26004": "60dc9730d5652f0632cd43caef437f01a734e374", "26006": "c3e640c13c58bffa127eb8d3d4cae220d9c99c33", "26009": "6d43f64ec3920d78215dcfcacdabce96793cb25b", "26012": "4f5faa333ee0c52326fcd9cbe35c577e488613c9", "26014": "45b6d4d987b1e1bae97ae0fdacc8e7c377ab1485", "26020": "73f718e4575dfad1ad9de4a18e5bdf806b9580d0", "26023": "b20b9b6ccf6d1b237f904edcc342794fe3f01111", "26024": "12892b9a5c3be11686ff14dddf58b553717b3303", "26025": "e177ccfc31862b824feac491bb1fc0d2877587b1", "26029": "c6feac70a06309e118e7f0283632ef6a71db80fa", "26030": "ed41fb292c449441152242757fb6b518a80a05f0", "26032": "aa8ebbc3fc0e8057ae2cbd3255a702dd8f0ab94d", "26033": "d9e6442ed83cb9c08f09185f1a102155ba04e88d", "26035": "6ada1a2e125f9b40bc38f9d6b69c60e4fe3b7f4e", "26037": "a00997e7c7d6b957395fd647d90acf7c8784c3ec", "26040": "31505666f70421a3d85e37147a0e70c9f39979fe", "26042": "10c8c8de491a607378d6dca7602b0a3ed440a4b4", "26047": "f77f880218cc5a5111a952b3b63bbf3243910002", "26048": "77b491b11a5e111f5851025baf185d6e6870cc74", "26049": "55cf5c301e58f24092639c01e48c2bd139807906", "26054": "2886c7f860cc2da867b30ca346d88d15fc0d2fc5", "26064": "ec0541e314785cbfe94a8f8be6d1a17f7116db39", "26065": "55ee33b0aa0232a3e7b5ef6354c7f16c2fd7fd0b", "26066": "8b2614581fe68c272479d153ac5358aad8fc3e9d", "26067": "6148b7c8efa685d114fad5b563e3235279d133a6", "26069": "b495da64d8a5d280c632d1f61b5e857419c3bd07", "26070": "37b7e0081157433f10e9310985c95bd57289f15a", "26074": "a08a3e38bbfe6718283d0bfe4f6092201617fba3", "26077": "6e15c52a40370d629dfa4951eb58e7f2b267ed61", "26086": "463f8a427b0ec04805be5665a533590fef1c1385", "26091": "d8aab0f803117fa419fa8ec143d193ccf74b19ce", "26092": "c2fa6570360674246030feae1ad9c299c2c70902", "26098": "f24fe62646d0acec61d9d90c79cec144a6215daa", "26103": "3cc683418c30b00f2d4af242d010d969b3527ba1", "26106": "ec22ace5448e033dcf8c843c11f6753151ea3281", "26108": "5c5516a72dc41efb8f308f384eb79df57cd87af8", "26110": "4329a5af00d991c2fc105f27e6e8fdca7a2c7bd0", "26111": "347c5d11a9c6f9c7ff59ed5a0aa32df78d17e5b9", "26114": "84db7d2e42fec88bca523a72b6b2c87b0b774260", "26115": "5fb232730b41b60a79f822db7fd47909dd5f6947", "26116": "648a32eae454e6e72b5241485060b6e235ffc751", "26118": "624fd766e2886c458012d98e3c6ec85551ab2916", "26168": "86ba0d0585dfbc3d9af79655fcc2cc5983a6444e", "26171": "c7d1ecacd38afffb5b62b7ca6305bfa6303b8228", "26173": "bba69e41350eb5116a6d7ce91ce750087f272751", "26178": "b1e8c54ff3d2f643d4771ba201f14eebd83c3154", "26187": "d09db02b05f4f30ac1235ed6d2fddca67dfa6a4c", "26188": "71c291649aec80e1fbe762c7a81ea2c5925bfeb9", "26189": "20d8272289e23a16fe5fac2fc58760d6e2d248e9", "26200": "74875a8e60ba1117dc98743b3297234f5ea6cf9a", "26202": "b21b3032df098275b61c6501bdb3fa9ae4c99288", "26203": "21d2b6ff75d0f82dc48f70f5d9e0fde07ee2d813", "26205": "52e58c424f9d019f2b80a1c553562967477c6cb0", "26206": "2a60c195434f83d60c704c968b083439b0d7adeb", "26207": "c068959434632210af9984e6690b9bc14586bdf5", "26209": "b60ecd430c239679641365652dd278f514270ec1", "26214": "7df7d350fb3156d6e1554eec6997be8bb59cb052", "26218": "ab1c0907fe9255582397db04592d6066745018d3", "26232": "0e75601a41d3aeb33b7bbb00573bbd04e3b37f9f", "26248": "0026e6fc365d9ecae51ebb260097bc03b74d12e4", "26260": "9b9f2e8725990ea2a9cef2fe3a11de07ef0fa78a", "26265": "04ccb63ff4f99a96d1903dd8828a7bb3b1bec061", "26268": "8f382816f9bab3cdd1da40587e77abe8d71d4bcb", "26269": "a2aec60ae99a5f7ee597c2b4ed5fd6b367b5e622", "26272": "08b992ddeeb2ee5f61b15a72bac1cf82fea9d9e6", "26275": "89a2e815dea2f17c12534c13231652730f8d1c16", "26277": "3d2e6f475f281fa4b14e7498d757f6f85e1b5f1b", "26279": "e33fb5dc364a1be0fcb0522aef4701d64fd06c19", "26281": "01df330eb643e00ff3dc006e805a33d50a539892", "26282": "e38446ee3d8d41be9a5e141427a2edf485ecef51", "26286": "3f204f9e9b5df483a15ea3645a4023bf177ffde4", "26291": "d293adbbb64501b2b1310a8c7e0dce03d5d95360", "26293": "bfd2e7891f03aa93164bc0fab5b014eadee8c8eb", "26298": "5e9eb0102a32da2a4e25df346b5aa08aaaffc6cc", "26300": "0c90e843011ca2a832db23dc74a4902849d81438", "26304": "255d49cd63d4341c4d95b28ee8272657bf5e8e42", "26307": "802bf23c3a7e371b0502694b80d9744f0a100e57", "26308": "838d5726585e7c5b79a613c5f1dec98b7b3e5b20", "26310": "2589b0d0042846778fdadd0c0f9f7a8620b62c3e", "26312": "5a42f061686fb9d2e899b183c16d1eacc2f2d036", "26324": "ac63126f4007b66de0d57189b3637d60deed10ec", "26328": "2abaedd7edf22463a20eac5c067b587fc13700e0", "26329": "1d10a4afe95cdd4bcae80db5f312c466d9921d4e", "26330": "9da1c4bad19f434e7e511a164e0a7af954a4202d", "26333": "01838d2c2ce0fee9bb9e62da1a4f10d63fe9b36f", "26336": "476c6deb4f22ebb62aa5d22cd835f05e45ce08d1", "26337": "0ec3c2f1a986e6d88013816ff0bf97951192ca09", "26341": "ed24f99c5195008e4211b17c59b8b44634fdbe39", "26344": "bab1925319d80ba11928c9a3985781c310b3a1b7", "26345": "ff9267b6ee01e642c20ed0879222183c4fbbb2c2", "26346": "4fd523c6df445cdf5dc61f6018a81abd3422ffec", "26353": "764f1041c19724b5df208bae8b9390ea2bfe4d79", "26354": "3e968dc661ede52495aba0bbc76639b3ddfdf8f7", "26355": "05aa62c79368fba181d733025a76ba6b0b0bac9c", "26359": "b50171a59bc0016a53868a72f6cb4021de5d465b", "26360": "c499a59ec710dce034eb45d7e46566db42fc00d2", "26361": "db3557e3aa8f577d7914677911483c508fc3f7f3", "26362": "2683f492164f9e99a10fcd8195827d8dc92df490", "26363": "1302b80ba01cbb07b1b57618c342799064210a36", "26364": "4b5c489c1edfca344054744e1dbe090ae38af6dd", "26365": "89ac326468ee22946d4a22154ff458b7fab07f01", "26369": "c47515cb837c53d0e8eaa7a5a7c0ff2aec1dc194", "26370": "15b43a1cb3f0c0871741963cc8f6d2f910e71a30", "26371": "8538cc9040a46bdf5000509d49c35a8b6cfcdc28", "26390": "d02a18605714180550bc4287f3964699d6466517", "26399": "e9dac0af7841e79c797b6fa0b76b5a250973f73c", "26400": "0cb5a06c9465b99737f914dce48d9f5aa4400e31", "26411": "3258f6cffeae6217d290d437126dbf36908cb9e1", "26412": "953f8d40cfc2cf5c293b94bece23ae0e2a2e84d3", "26413": "c0aed3bceb49c1fc6ff286c05b1f9ba6924d37df", "26417": "4f49abd9579a6a4510ccf630c32d6ecb2faf9347", "26418": "417761e719dcb5cf3c9bb0a25f9f0f792cfb350a", "26424": "859c1061b3d5aa30c4466824049d69edde5499a2", "26429": "60df21a5a4146035cb1fff778b3eb77ab21f7ecc", "26430": "d8d6634e8f26c4132697b5ab38f513f58f160b08", "26435": "33a8f6deae1cbf74e45dd8f8cde69450aa897c66", "26438": "6cc51cddc846fe1d6afc19a7fbf694eacf3a7ef9", "26442": "1e90f156e97c4a765a4a73cdd8c0a9a6d85a999f", "26443": "54f8d14712eb7cd838a4c8ecbcf5cbcfc6e5902f", "26444": "e4dae97415cd25cbb06e36c80e318d0bee925b40", "26446": "7ac475cbe6e609a19aeac9e9d18a71b8d905df3a", "26448": "c71cc91bd0b7c17d1c3e9e31e906615e0c389d08", "26449": "fe78d1708aac94e20ad8ac4c390e8ccbf15a37c3", "26450": "cedec5b30f74b40a8aa842c270af2085b591aa1e", "26451": "1ff8f62fb0ae45999b3f421eb71caed5ec7c3e4f", "26461": "1169d8740ac432d71565f8cd353e5497e14d69cf", "26462": "f304bd01bf3d70a4337f616bc9c2352c76f3cd7c", "26464": "af1866d5edbbed0bb4f7dd219ee951622db493ac", "26466": "08e390cc1f09d87215bbdd077188a135ec8e379f", "26468": "4ee6cdbcd8160d65a5d5dd99e303c131588d67f5", "26469": "505a8fc6cf160562830c102919e0d6d42e0a7365", "26470": "62b91ed73af8f0882887ddd92dd6a423aa6e9315", "26471": "bfd5b62185b3ebe96f2680980607d7cd44e48b1d", "26472": "f6762e4b502c7cb2455f660ed48954110d5ff616", "26476": "8fceb4807c35a87bfca375e89061dd76dac72102", "26477": "49f993970b2e018e5545eec7fe43e6141da34f8b", "26478": "ce04517add33d8485580e93ab2df38468f6da77c", "26481": "fa119c98b18e3dfc6e158e22e806831f40d660d3", "26482": "05ce9026a26f428bf3d79f666b05cbfdfd4c743d", "26484": "c95adfbf325144c6e8741436efde3a37cfe39c45", "26486": "8c35bfffc5578fb3097c3c7d8190c2b0db5d48e5", "26512": "f3ea4710dc626bb89d0ba1307aa92b004a0603e3", "26513": "f30b78ca2495c9498046f9788167b6f277a962df", "26514": "4fe52aed1ea375c2aa7a2a6b634787c9abdf32e3", "26517": "09ef43de29aca4c5f795f8d81fe7e3cce5306d54", "26519": "f34c2988151d3cd7635fc91386ddcaba68345015", "26520": "a1ffcaf37795a3140cc50b8fbb989765370b73d1", "26530": "25b386ec0cc9ab35ff024a8e955e413991e3e572", "26532": "bf7a9cc689bd1f81966b464caa725d2c02d02dd7", "26536": "5add51e288e10dc5a7add3ca8d129d8f003132e2", "26538": "5caee5d4ad564cfae4596f8dfa8b45997767035b", "26541": "5ab7426247900db9de856e790b8bea1bd71aec49", "26547": "9d6f0cf810091682dc0e14921764e61cfa8a6672", "26548": "e1b9f4700e1b785961999c81203ebf1547af728c", "26549": "395b89d66f74441806bab24741d346ece7cb4ada", "26551": "7195221bc0617ac98c78b97f5d5c98e024734d3d", "26555": "d98dbb998b4a9a567e69ef2561f22cdf9b03f8cd", "26557": "0a16fcc2eb27661362f3c4898cd2f90d70b41964", "26558": "292fff88a4d44606d7950d94b7794a7f6787086a", "26559": "e53f57783989a6311b9ec50242010569e1bde2a1", "26561": "53d391cb7d7f2c8c0272ea6bccef59dad9e6bfb8", "26562": "3bc8da3611598357457eb138cb57f3be23f14c0a", "26563": "8901ec75093d7938b6003429a13ab34bed4d9fd5", "26564": "5ac5f636f17b84cac14037aafe28c1ded9f5cd9d", "26566": "e171a18474d29343de40fb47c7821de8c820ff9b", "26567": "b986aaaa3b9a2b2c2008db43db53ca5d2ab47e24", "26569": "a0972b42590dbe96b6a5496a43488b6f636933af", "26575": "d78daa50c2d462c32b62cfa8cd4bb03b5d9b1403", "26579": "fc77ea19923c39618547b4033a9185dd8a3afcc1", "26591": "a593082acd0b3d2292de7cd4e01659da47ae0003", "26592": "1d296b6afd435784b089d0bd5bf54c399c7cab63", "26595": "f508446ee4f892c35aba521cc177cdee5b8581df", "26597": "2eb560e7f854ae6d801ca8cb5744d3af13613a67", "26599": "1f1fed67477e6de4882006e934378ab38d8d310a", "26607": "c7ae86e639917d227a356a7d6362e8f227954ff1", "26611": "b9897d6ba006e916d3245b1a69b3d93b98ba4482", "26612": "0f2887a8ea3682763fb9614e3f14490a9b6a6464", "26613": "47c6468c8984b30398b3a0681dfc8bd1945af39c", "26629": "0e81019ae3c931968cc77c4127480bc614b41849", "26630": "1f5efc47cf8b43abb3f9c85da21196b0c963f747", "26632": "a73c1a171a313cd51c89306d1abe6cfae91c5bca", "26644": "7c7a5f8393e7b16e5bc81c739c84fe2e639c367f", "26645": "4833a293e7790dd244b2530b74d1a6718cf385d0", "26648": "056603c3768ff329d3e3e60d700f856e14f8a7c7", "26654": "6d1d065bec445d10e337b4d7661d9f76a39e07a0", "26657": "ca2b572cc08e268db8e928e53a05155738bb9f63", "26658": "cb556d595e9ebd8c982749ea3035fd0a1d381438", "26659": "cb497aff16a119cb4b584a99760ccc2602a8aad9", "26660": "771b3ad774fac08788c1203cb475a384820088f9", "26662": "83205b1092406969cfb41b069b3e55a09f3bc45f", "26663": "c7ba5c0b239f10478d3c902cf4057edf1880b35d", "26665": "8ce882181e41ea62693b1e41b9b4cc67fa8a3e8b", "26668": "87badb12047a9ad9b648041452b0b24fcc12701b", "26669": "17d1c2b99e4170e38ed5f212dd3b8e7a04614a18", "26670": "9ebe12790b6a683669916a55fbf8e35deee93e0b", "26672": "69a77526d44e16ef953ae84f9365d90a5dbbfd89", "26673": "15bf22e6560197feeb6552b11a0cb4067c046984", "26677": "5f1fe5af49e6b82727c416974cd0a14712ad5135", "26727": "085b766efb054f6529815f8b7b1013c18aaca3bf", "26753": "f2ef65dc7f00672496d7de6154744fee55ef95e9", "26902": "a4cd586c8a11bba03295efc355b0b4cefa9de66a", "27053": "4ec4ab8d6ccc1cdb34b84fdcb66fde2cc0210dbf", "27079": "03eb3b23acc0516ee20c721e3c3f3875b49c4377", "27240": "7b90b3a9a3a94c0e69a12e1d3906980bd49f53f2", "27383": "9b04f4dd9a75cf47e980d6ec1944027065e19245", "27408": "43b76937c0aadf23b4e0fcc04f546fa5d61b543b", "27459": "165731a66da08f0f6feed7a1cc0a352f04622792", "27460": "22a848014412e23d900c24cdc8c976e7ccfe7b2b", "27480": "2b1586ddb40ffb8617831f658a3d2cec423ba0b1", "27485": "5eb2069b0bd57b94175ac4aa7dad4ba0c58a653b", "27486": "f860573eae038b0ad80cc27611a702136e55043d", "27491": "85dec2db4b458d0199c288575bc9e40ae43f4902", "27493": "44e31b1eb202ef91caad059952ba268d2610a60b", "27500": "1b7103ea72035e7e30ba18958fcf664219b07e6a", "27503": "f5e613cd5bd505f68c5a23be06d7622327ad93f8", "27506": "2c14c4854ba070725ec2fa97e8638ed2cd7b1d93", "27510": "edb50b09e92cc1b493242076b3f63e89397032e4", "27522": "4aebbd953fec41b2f3ff3ebbeb2bf91e88d0da2d", "27524": "a3af5699618d004b1f4380b6bd7669f310ad840f", "27526": "eb6632197cdf4f8eecbfcd95c3c25c57d50aaad4", "27530": "c0196fb09f2c28a917e705337aee508b16090666", "27532": "f18feb7154c0670665fd6ccbd383c0a50d1f6b78", "27534": "f397c8e17ac235316da6f1a10692b2604b6d6ec4", "27535": "7ed8612b9502408f9fbdb6099e6c2f5a17230b0c", "27536": "6464a1f051fd83d1adeb5cfcd8327186bad1bf37", "27544": "c2b16c5ad5dc16cb0fde4697753938949d546654", "27548": "153467a9174b0c6f4b90ffeed5871e5018658108", "27551": "e167e79a1cf4ef7b3c3dbc290236b470fd9105ef", "27552": "2b73504ccc6eda1d25a0f29d017fe521b9cdd8fa", "27553": "a5626b55bc371a2c8b025cf649436a9c731326e8", "27556": "5ddd07abd17dfb4ecb7189688009d0544b3dcbc2", "27559": "ebb2c59f6ac6c741e984b8c9325f5468b39688f9", "27563": "b8bdbbf112413e9a8f5e209fc05d3b8927718b28", "27572": "018986cb0260881827c6ef33cd2d804f54e39c85", "27578": "34e103a019aaed9fbb3dbf304c76884d817327c4", "27581": "5cfc63c521f79cdf53c4221e6bfbae18e23bf679", "27582": "0364b80037fd6a9379213a0d6ac27b3296f41794", "27584": "5acc23400ce53ab69e97e44e4faae7f3fb039cae", "27585": "b3f92fd2f785a7878abda21f64f727a3a83928ee", "27591": "d23321ce17bd1bb2b44d667a0c65ea98237b5075", "27592": "bba703f34223d29deb98ca93269a0982922d6a25", "27599": "da9c3b2fa55bc1f84053916db80f13880d9cc1d0", "27600": "4a4ca2287ada4ef14a2fc715cd9459733223f9da", "27601": "d1a683f5716e50ef84a61473518c15deb4a4d9f7", "27610": "50dbaf94a570fa817d0d72e0b94d9f87c4909a4e", "27611": "5fba81b49065cd929dbd8df64a43a4d57fe0c21e", "27612": "56cbe5ff46ed048c00424feb96d4134a82988716", "27613": "8e0e72620e5f6ea14904e709e3a12f54b20e6b66", "27616": "a1c3372868e08d5ea0ad44e16d1b9d37de93f69c", "27617": "5e80b2886d03e375ca3470f1b5a9d627793dd63b", "27620": "bc94acc851d2eb96e2a75cad5650b73e27b8a299", "27622": "3cb27e8c001868bdfdc25492c34854b6eb5fd82e", "27623": "e53b4fa02e6e21894cf2fa6e304aaad0da52aa2b", "27631": "1605c31af52afdf7feec22778476d4386d660acb", "27632": "500878e88eacddc7edba93dda7d9ee5f784e50e6", "27634": "8ef583067438a16e7f3a4bed2e109168f16dfda8", "27637": "b62bd82f571f069bcf14d0f19c94da146db68441", "27640": "bf0572e6f42a2892e16bfc6daf69922161ece260", "27643": "21c23279e8456a6733420f156636e630ff67b2da", "27644": "b7c79ab69b1ad63733c2f051ad68f969bb3a35ec", "27645": "cb0700e8f0b46990def8a7b3f1ea62311258562e", "27646": "1b98037f78922538252179ef4abac0827aef96ec", "27647": "6caa337fdc93159a49d8ad80a0a92d0cded7cb23", "27649": "f91728ab47e0702a06ff448dbc5d6e5705227679", "27654": "5b3a3b440525aa5038e2cead1f9b4f23a610cd9f", "27659": "81e7c044dc4136c7723dbabbeb421beea710da70", "27660": "fb13f09dbeaaa0c37794c2dc158f5d6daff9239c", "27662": "a4f43cf787334322db02b872ef10782517a0957c", "27664": "2b3177f7412b822f044b6365d80bc348e24dc70c", "27665": "425d30ab273ce9086782fd2785d86be08f384fb2", "27667": "8c54071d371ee174cd7f761a5f10e0ab5cbb4aed", "27668": "12b77ad2e2d8ee766566e19d66845ca02e378ff4", "27679": "b9aac67f71821843b17f0c087915c212fca2744e", "27681": "130a1e665e4988311ddeaf50144afb30630fee1c", "27695": "2d251cb3c2177bbe3afe7bcfaa4eb21f0baac3da", "27696": "82a03491c6033fc4cc14fcaa3d0361dd7fd3cf4e", "27697": "a71b6e43ec9248c52d4c0ac0d2a77be17b4cf588", "27699": "053f3f54130f8b17c09540352a784f4c54a919df", "27703": "88d4d946a22b3bd933884ec236bfba9526809ec9", "27704": "2552ed59db97768f74afd12b53e351b76cd9b180", "27714": "47af6102fc5a900c5008bc4ad8415ad2a136c92c", "27715": "26840e58390e2b0d359b188fa2e459d7da451ea4", "27716": "59daa0f75202d2de2d8cdfd5e3fedf6b57103c03", "27717": "6bc0b7297aaca7c7c1b4854d421b20d35172222c", "27718": "70e5772d53e45c8874f99e6723211c7d8bb41bbc", "27719": "56f8c41596bceafbb213dfe4936a5d3504f409b0", "27721": "8647ee9246cc561996c02f6ec535cae3aa69b225", "27725": "7e57e7951c2986c900aa05257e2ced662c24aaf4", "27726": "59160fe5bc76118b0eebe0c12a57e832e8ca72c4", "27730": "47bb6febaa10658c72962b9615d5d5aa2513fa3a", "27734": "608d48e8c2a3587c6885686a4e6a29d729359c49", "27737": "28e4811d48c99b7c68e41992eda5cff859c1fa2b", "27738": "3c35f0a3abdd07c2d2b8f2f1528709d6a393498e", "27739": "3a5d698d46117d9b269894c739a689b3719de04c", "27740": "70c8d80bd8ce97ea935d95111c779545c0aeb21e", "27742": "240d4c4fc534fe18fe754072a98fb32803fce9dd", "27743": "701cc9cbb06ca9897bb0db87e656cc1ad5856841", "27745": "9c2eff4826878df76deefd8045976a296ba0a07d", "27751": "e1712586da2c119fa252ddcd5669543ddd2a5d43", "27752": "59b8bba7717b540898a3ba88e41520cf6850fe82", "27753": "7f9e86de540834f69376ed949ddf878a589a4dbe", "27759": "803e52d7e82cfc027daa55426466da29bc303b5c", "27761": "15417d73cb2a1c4bb2bb6530e30d2b566632943e", "27769": "ee1fb3946113b200d53ae83d25f69455c897fce3", "27773": "e4b3e6eb372b8c1d875f2adf607630a31e2a609c", "27776": "65168d2df106ae42d44ea9600c318e2df475a96d", "27777": "ba5801702ba8f5ef24ecdd5c4451d9bd7c2e661c", "27778": "b32bba82efbde77aba1201835fe269ce9e79197c", "27781": "52ce00451697e6ee46b6e319b4252bbd6f8c16c2", "27783": "d92e0484a419de07f4c4dbfb278585de9049611b", "27785": "402ac3535b8c4f6b2cdf25ba3611f563122dda61", "27794": "7c0363f51d777c1c64bbfa7e2fc1f15b55621cd0", "27795": "fc3849453b7726e32d73e2668e6c3a35197b3ce7", "27799": "a290acb8831d331ee9617f3f5e4a8c1e2298298e", "27801": "f6cfccbdc87b0bdddf8c21177594b15d38d129b3", "27802": "85c95938b625e77956af4fdd600d24ea578371bd", "27809": "24144ec71e6b3523819f1d6a9ec803abc51a3eba", "27812": "9db8ef1038525d00b2c34b69a382f25f6363e416", "27813": "75ef7dbcbee1fa5114de86a3238333978350056a", "27816": "5e509471d972e55bbf881544918bc8e80a6b63e2", "27817": "39bf11b96f771dcecf332977fb2c7843a9fd55f2", "27835": "038b9774cdf766db0b5f0851bd1fd6c90af78163", "27838": "2f60c3397af857a51966163053ecadc417fac7d5", "27839": "10987b5e11c4e9c4c601682329726b524f8867db", "27840": "349bc202c1a64886462a9a9087d744e6ca21b792", "27841": "33a25aea48bea84fee7861355cbccf36a3fc90a6", "27845": "453aad79ffcdb7c3379938196077880a8ae5427a", "27846": "4c3206e47985f66977fdcea87cdeee9de5b80347", "27847": "2ec41b50fe1a8c27206ebcaf8b2eca0574d8cda4", "27850": "6c3514bb5c925c9eb5ecccc9632fb6c878828478", "27851": "d4e67bf0e9c31d11d0f6d5ab8e6a9bfd756bc72c", "27853": "e742ae1bf8ebe50ab52b71926ae3345000d5e822", "27854": "9e08b05d89c08bf5680bb679bcb4cd06e8b87ea2", "27855": "97089947eef7351e82718b105c244329d76138ac", "27857": "51a9381f31e285eb96147309a2a02e65dbc0c9a7", "27860": "20a118581ab0cde4cffb5ff1eed073b265101481", "27861": "8853c6117c6710d9d42314f3aabf7abdc8b158c0", "27862": "ad4d1f7cf16e0207d61881df5f7a846052f38559", "27864": "5996b0b928956505fae60f27b6d0d527165e453e", "27943": "aac7ba7cfdde023beada90a5cb8392b527383346", "28011": "48e1dd7e604df3ae57d104b407c5b7a2a6a3247d", "28142": "930bfc1f1f1f7c809a8f922e8eb370c3dc8a30f1", "28192": "e132a180363f48b672daa1da1f87df0c22623720", "28312": "f72cc95f4eb5cef207a2abd613640ca212a2e3d8", "28344": "59e6539cf80dc04b16b0f0ab52343381f0a7a2fa", "28460": "acb6edebab9f68e0dc315b5a2d859f09c43b0560", "28478": "4dc5e3bdee4b88cacf18c4fb09d11deb13e8aff6", "28529": "91530891107c4eb2274bd623f0f5158894072c82", "28625": "c762455f078d3d454cbc7f8b50febb44808d5ba1", "28777": "22e9f747c4b731f63a46477b057daf865c269aad", "28783": "4b3a2c13549be3402bb751fec7b572e8c90cec11", "28890": "ea004bd338738183ff4761427246198f84071ba1", "28893": "d460f29107cb6ce2ba30c8f5ceaed8dd6d1531d0", "28935": "b5d8bab88af61d61de09641243848df63380a67f", "28944": "6c2f5744af0f142d9d46946c973b99ced73cf9da", "28954": "fa6b307ba4b46a0a7e5f956831a68223cc7a5a39", "28975": "8dc1205a8b903705e0f9fd04bb138455db5be6a7", "28977": "4162ff194b79cc83fe8f747a720073051bfa9c6e", "28980": "b806a310d09e9bad4087eef158861e84c04d196b", "28981": "3a4c89498a53f05e3921f5ab03a96355d7f54849", "28982": "31ed6bce82e6486f31fb10a647fdd27d3008a8cb", "28984": "ff1d1555fc67589bf94c272a09ca519ae895d63a", "28990": "b31c6b6183b1ad49e38afc70f6e07c30a27360fe", "28992": "1cfbdbc33ab670eb882713d6220462250ca531c4", "28994": "266670d2674f39c06b934c0ba6ee4d0f76ebd9e9", "28997": "e7f5741df74f116fa9d306dbb6ef85e4a53183cb", "28998": "e8212863a7c09e047e78a9a8f983527ad01c69fc", "29000": "b06254e5a08a0fad05f6e5a09b7c847c893ff355", "29001": "821f62242c2c0b4e1e96af476a1293859439e47b", "29004": "362524aca23c1e2b158675616e1675fd36fbe13f", "29014": "fca37752450f07fefbc98e1e533896a07bf92215", "29015": "9f5753d97a732c65855ac0c73607562f1e3a8bf6", "29018": "fee7e06ea17d7de1b1b902c9fb39ebe850b4f9e9", "29022": "9e6b012fd89d09912dcb02593f35c48752631d16", "29024": "9bb9189a710130f6b00b7dcde74a83d375e1e282", "29026": "9fbd8f60b11110efe35da4b83a14e82982237df4", "29027": "5ec3c62887810fa9af622be3d8002c3929007831", "29029": "7818647e1d0c7c5a29bb975919c43c4687c34af3", "29031": "de769003aa0d60d0592cc98f86b85a13a0e1fd04", "29033": "d1295856f75362251161185c60b052531f05dfd5", "29035": "c4829bddb859ffe5716a88f6abd5e0d2dc1d9045", "29036": "77ab0a4dcf262dafc0e5e8a822c2019852937721", "29037": "4a856f1469be6724c519e2439744dafe5df94471", "29038": "428b4e4ba3214243fbc50d11b8bb3a6d66c5b691", "29042": "ed21abe9d2d43920ad9b33c1be0d02de15a9fa68", "29043": "b529d4c3e3397789e9dc75920c34694e549d6441", "29056": "9e8df2e78d1df43bc04fe6a6b846c96d7b8e9aaf", "29062": "649a80f40b66a79b69df9f9d3d18ff3288f6868c", "29066": "8b7b234e820defd65bab53894a6d368da953c4c4", "29068": "980935e04e3b721a3dcb8527fbcd56cfdd5754cd", "29071": "ce4b43097356dfc42504d81d6164b73ee0896c71", "29073": "bfffbd4bd73bfc47f16ff4516469fd8a988313ba", "29075": "8ba609c313f09bf2a333849ca3ac2bd24d7655e7", "29077": "b12dcb2ac103b56dc3ced8ac5ce4b406f67181cb", "29078": "8ecfa67651502dddea2c137b0c8dcb9eae44073a", "29080": "55acf5639a5ad8824602fee8991c3d16910168a2", "29081": "3703946987dfa94d19bd3fb1c42b79b7156512da", "29082": "d2a6ca5913878683880dffb1cc9a0345bcaaa121", "29084": "ad44afa0c8ecd6be03e5d4f5dc548cd67456b2cc", "29085": "17ccf4890fc993f7254f15a90cce3ca40dc8e763", "29086": "c4bd4ac28561a6f9620240ded15909401ccf3690", "29087": "33cd28409c8bf9d8f8e3558307259860ed881c47", "29091": "8773a0aad49f085b4ca39295d8946021a49ba095", "29092": "ffbbd1430d0138c494226b3923787b70253bdbeb", "29093": "871dbb11277de514749ac5e9ccff4f0a523c98a8", "29094": "40f4455eef9bb64e18eb9a6f557fa6fe4a7dd3ca", "29095": "455a70841472d719e7ba067253922b762799bcba", "29099": "2011bedb4e78ef6a955515394ee4a6a2f90bc28e", "29100": "7586f9bd88d787c2c7c29c2b4f1e63652e440b8d", "29101": "a89a025d8d727338191e3bf2a9081af5c164c099", "29103": "831d9aa787548709afd90363514bc66957f6c2d5", "29105": "a06cc0da56df9741105eedcd160b77f6f08236e1", "29107": "defbc282bcedc777bdd65951653bbe66e560a8ea", "29108": "b341097ace66f70ad10dd116e7683437afdd732e", "29109": "4d66d813205fc7280633469b3e2a7276b4dfe72e", "29111": "b6a151b119324e37da03bb4f1498d67769a7de79", "29112": "d29a0e5e64f93360d717c5adb42c84f9eccc6865", "29114": "2273abe8a2712d6feaa62428bcdd79be18a2dc94", "29115": "88270c078e0f3dcd80dc8b7367ff1cdd7db7bd15", "29116": "7abf27f2fe9046814a0eb6e618ad310bd29a15c4", "29117": "2656ccbcc24253b15de85f977e63fd91183e2095", "29118": "da64f8ca0ef2353b59994e7e37ecee4e67a9b1d3", "29120": "dcde9836f5c34e991dfd3f90aeb484ebf7465bec", "29122": "b914537213eb5046ba4560432e15243dae341808", "29125": "0ed66c76c010ec897a116e5a331941e43e3da562", "29126": "b9c208b2714c878cc8846f1d0884a7b0072fd6ce", "29149": "5a94865ca97bd3237e234e68935f07ba7b517794", "29150": "b9427e1b5d798f4c14ae9b6cbfec7d32dda15a46", "29152": "a57eed153fc000112734cb8472c355e98b8fbd33", "29154": "ef53758efffec6cd8e225f54686894d1b54b8ba3", "29155": "94e98daabbad231fe519c4d32a1412a27253ad49", "29160": "477b80bfb2a47d50a4214d5558df4037536aaba9", "29162": "c6cb9b0f900ba99fbb061c74ca4e7f00a20a823a", "29164": "4a3f1faa82008231ac3fd1bd833dcfd6d5ba5620", "29170": "071c5706280d73bb19e31beb64e1ac0a57d80f96", "29175": "5e6aa2dc90ee37a7034a2b6d9e4a5e4cef934f5d", "29178": "447172d245181f3dcce01127c5d40ccbb8a668df", "29179": "6660830eb7d7590d56f1377d27bf7ee97bb3adec", "29195": "c7d74d12c214f7bf8b4528eb02ce80e8d7cfc79a", "29196": "b8fcb788733e0d31a6f85a68437f0b78624c199c", "29202": "d08378a4f311b893a0130acb03cd782373904d4b", "29205": "7c3f7908f7014e67e85ecc24290a854ecda94797", "29210": "76fa962359292a0a5f4643291fc5208499bc55e8", "29212": "129331fcae813ac1ffebad6be4294278181a9827", "29213": "59d974bf14ff8c82f3353e2d2a9282d9bda67db5", "29226": "78ff9f16c4619759fc59f1e1813900738db8d7d2", "29227": "0dfb5d600299af16b1482731def7c91f7662ec28", "29232": "f793123b52b5e3cd4ab8863dfcf33265fd52388a", "29233": "cce070c7888b7b2e7bf8eb04153e5ccd4e86f337", "29234": "10451614e7a59028a3b2415d208636c448bea63e", "29237": "b6ba535cc785bd22a221c82eb2bbe2984ffd1131", "29243": "45549b6f8550eecd9794b337d32569074ecbcd88", "29250": "fd252cbee0299b14002b92290152d759341677b9", "29255": "9ce6bb04166bbd8b1a0a8a2c6d2deaf62d72933b", "29261": "e19821b634e63f0bf73af0bbdb12916ed05712b8", "29267": "f9780e3072432fd3c6080e6e737d51aebd4cd689", "29271": "1c1a46779a10f7af4560d63e0076d119d9ad7151", "29272": "b6ef699e224e34b9cee0d6f70e737ef9b5530c5f", "29273": "915a994945c5fc11b962469fba89f926f6c641da", "29274": "3292e2529d9e6311d65f06b9af4f5ec067fb9143", "29276": "6bc97c47367835442d8f68c346dd62367f5dcd83", "29277": "9a12908f843aed87203b32e45d1001353d90c548", "29278": "e3cd846ef353b10cc66972a5c7718e80948362ac", "29280": "69cf712a95d564503a2bf508244d050e8380ca1a", "29281": "6f3c7be0961c24b9086ed8e5f827e030b313fd5d", "29288": "9c5d9a5f82331a2a7c898a0f7c45b0c279f1fd4b", "29293": "2dac783bbbd4c0af8bd72bcc6c6338fe4bb2e4b2", "29294": "f1a934bef8263cbe10e34ca9791729248f9c792c", "29296": "2abf9303e3439f842f348ecb8b65487f25d2479a", "29297": "7a2ed20e50164e5eed588c586ce8a65888327b09", "29298": "27195e4870cd0155b19545df3d2479e2d437efd0", "29323": "80712b675895dec03c84ed0e1bfd3a5e242fb93f", "29324": "39a8e82e083a18f8e09a4c732b426e6743f16aeb", "29325": "1ab82fffd30f3bf936c1118e55617a978f9b7e90", "29326": "f9d61f09622b09d1048f017495975056557b161b", "29327": "64dd617cd2c7d1bb34a6e6dfc2ca37bad6ac063b", "29329": "6432ef2d9cc1f628ef64111bb63008f1cd794c9f", "29330": "dcbc2e53deb82f8b04c6860a9b64dbbd5da66ad0", "29331": "75a1b12e003bc9e9ca21c58c5eb8807ea507e89f", "29332": "24beed8d35bddaccd3c2bcfd88d34c9ed055f381", "29333": "e215f05d41aed8ead92fa2b7143c0f1d842b7154", "29334": "5f4ba674f3e3d2991c22aff8892f74c9c8d4e886", "29336": "1f2a6e8549966983ab35fd4096f883dfe668a969", "29337": "e73ceface03503a7937a520494e5eb34df84b5ac", "29339": "d7c1ff563a4bef578a7076a4be90c688be8f2da8", "29340": "eb2501ccb7389e8ee1d364b8987a2bd389c9e5d7", "29341": "3b80539fd6c1e4c3dafaa4a3ca6b8b2059d0fcb7", "29342": "0b7c7ba7c96d2657fcb52497c263bf1c8c155239", "29343": "7512955cc1a71f0c4f7026b53cf4e2966e63333e", "29345": "d87a65c947880ffd983b0b1742ae7e16f37823cb", "29346": "b5ffe94cdd165374b11aaded14cad47ba675845c", "29347": "132b9dec3e4d6329672e0d86628cf2366686a630", "29350": "d4c32e61357ec2256cbbcba4f4ae26f6c88cc58a", "29355": "1264ea0dfa705a740506fcf2ed3a8deb6bf96cee", "29356": "4ce0a75776af1ac98bab28368dbc93078fb301e8", "29357": "5d3cf28f084ce7109c27a38417df51bfed1c168b", "29360": "e7322848cf03d19c58a3ab5470aa8bdc65da6b1e", "29361": "6405523c9967c11b108e396ad7faaf83ef526aff", "29364": "e9f4b12c13d1b44c0037012b7433959a1b8e2a5d", "29367": "0c4f42d8c32fa9a1a9ea0680f952b163c08eb756", "29368": "21f7d569aca809eee8516af0e0220049514cfccd", "29369": "a48bb8a9e647a5889e98628b971359d2ebcfc254", "29371": "ced4d67ec8bfd7e25e5087c7dedc53bd8bd632d0", "29373": "4d942c5ee551d933a73c66d1566ad17408b5edaa", "29376": "9e8e9169c6113292b620bc4644bac0cde5ae8b96", "29379": "c44a56aee9bd1b9b7a3a2eda887d163dc4a67e44", "29381": "46a21b564580ffe77d684f0a2d2dc48fe7b80868", "29383": "ce67691026db9418568fdff62e1b2d6c6eef64df", "29384": "c711451e6f8e4a60c958a8451d6f5d998ecf48d4", "29387": "586c2e99cb27daa7743df5f204b2c1f5e72d6d21", "29389": "e8bb868d54e58b7479e697db728fcf08797211c6", "29395": "f0ce1787c333ce58b06b7ed6583458799a7e62a8", "29396": "862fe949059183129dc37c1e7fa4e41a467fcf77", "29397": "4c9ab5628061a29de8c9911a1b20ab09b3a51f99", "29398": "3c106e7e032834fcbbc2e5b43b64cf8f8d281e70", "29401": "b2a153522ea27f6e1bc7582831d0d763e9b3fea5", "29404": "8460e699c9bdc1039b031c15e290ad22372d5c3b", "29407": "653fd090fe18e28254986cd4c446c47b7051ef57", "29416": "87bcb916f8f259a46e69d7a44041f5d7c4a7246f", "29417": "75a3c3f47e9d3079f97ca1c21ac581933118c46c", "29418": "820fe86bf3ad8ba1c5647632b131659ed7bd447e", "29419": "aa674ea9f04fb33a266537e4e895b3ddd30c4d92", "29420": "7043404d4a7b6c43032de7ea008915fd618ce70f", "29422": "b74c192aab55422d52589cf0023d9b3bfb5d136b", "29424": "8647b6cabe6623c3a36fb4658da4320a6ffe5358", "29427": "e52b238f9f04ef5b2b0cf3266c2be705592bdb28", "29434": "bc9e2f1f8fe0c2ca277472a44576503a61a1a215", "29436": "69834743023220f0073ac9565cb5783c7a2dd433", "29443": "3e7584d6bc72d41ebb818832f8262581ac7b7396", "29444": "097ff500b582971bd178feabe9b7306712edf6cb", "29445": "b9183eb1f14ea6acc07d414b3399c0e1b3150e65", "29447": "2b4b1f088ca8b76cff26c1cd56322486f8c23658", "29448": "68a35309d0879466c0253b820001965eecc424af", "29450": "8f689c08293916170f2f658f32b251e3d2b331de", "29455": "2204e3a39c0d6c2d5292eaeae1a752e5565d9eb9", "29457": "13fcfaee253831134fc16716a2b54251deff20a2", "29459": "da8800108452fb1dc73e5817a8f74a89dc8065df", "29461": "2c3a826fd3f89400edb8a421aa7d556627220e8d", "29465": "928e21bfb90221b26d5515edc2d07192915a47b9", "29467": "7974a67bcfbad62e5db299cf7ce0dfb348b18699", "29471": "4b4c2da4ed889f4dc14672545a93c4e0e0bc3834", "29472": "3ba7ab42476ca5cd56549bca1de9bab2aaec1022", "29473": "2446fc79ae028e981f8643cd7b62e2fe20a46466", "29475": "e7d39a34edc9228f69cb6c8136b03a86ee70806d", "29476": "f3ea971ba459ea640809bc70442b997b41338622", "29479": "c166a9b88b011ef586c00f5216def56bd062b990", "29490": "168046fbb0cdf4afc857277abe544a3728016dd7", "29491": "93961a8d27b157064d9af8e36aab8542cd1a6c4d", "29498": "fb7a093ec52dec1c7656eea03783d15c02d63420", "29499": "a472022210f0e50f30d1d54096ddb850dffe4535", "29500": "5ae19560e0bb1934ff3d375fd36603fdf4265464", "29503": "1a6f02c435d66a40b255c96a68fa20a346bf0962", "29507": "c478a0dbe1ee0c1349eb584910781b1aeb158d38", "29512": "8f559871e613dfba55490e0c66f687c2b651ce7d", "29518": "03363632696e7f6d111d4dd31808ba4f165642cd", "29522": "a8b7c3216c0e8d6dc832d01d3e3dd92919279303", "29526": "2753deea0177a84199dc7f8bfa2aad2e324fa424", "29527": "7e52d370839b10c302c3a90c0425e9c459c68943", "29529": "084df9925bb95cffc5429a5da997b6501d17d249", "29531": "211380dd2308540477df287aa929bd108177dc18", "29543": "4cf21e753cf937d1c6c2d2a0e372fbc1dbbeea81", "29544": "b9cf39da9c9294588cc3feb9658b94172fd7f96b", "29548": "ba77f000ded56d07c9f52a154fbded87f2e419b2", "29549": "39fa4852bdefcd9675dc65e4f4ad059356cee265", "29563": "9e19577939d8ef10558f9485db84cc74dd2c7710", "29564": "5ad18b4757b0078558ac313524b1e7e33e87db96", "29565": "f94ad9e162937772836ba4d3d17408c604fc65f7", "29567": "d5e46add54425278eb7022e4d49f92e02b96ce8c", "29572": "81de56ae9081d587596a4ad7c274f31beeda36ec", "29601": "15ee28fc259f505743bf829662d088778bf3d473", "29602": "54e1140f03c8783360c45ef497c6b0c32d010f49", "29605": "8627df31ab07d66b438c7e5d5880e3f4d435f248", "29611": "060ab118f355dad8f8ba57c147ddb8849e97c9f1", "29615": "4c5e7f1b09f1f3b5be269f5266806dde9c5be72c", "29616": "6299b3021aa05a7feac438f46e1fed81f9065ad1", "29617": "62f75fa33f1a832043b53f0694693dee0fe9503a", "29622": "50a29c4109e4ec2b6f61db95aa4e49297db869f9", "29624": "94297f6c12ebda7e8bf876a0d2ef901f32708d09", "29629": "cc70faa3691f57a86b914cd8eb29902b9fc184c8", "29631": "fd3f0d41c5b396bf8aa74c61a8236e3830f6e4c2", "29633": "59611c75634449d386f87571323128be7c3999c3", "29635": "9cf66ad540304379147e90b3252d4620a22f909e", "29638": "3b9b7cc2db8ea904dad5a3ace83d4d2ef8668672", "29640": "7f7db53324bc6c9b7e8eac0a42441529da7b8b0c", "29648": "797ae0b63b6d19c564e2fb18362a354b1c65e3eb", "29651": "9fede9489d98707240d0e7213104bc617daa4c75", "29653": "87637da16c06230ca543c2ad90d8d0946ab3eac2", "29655": "26eb83029dd13ac24b2d3cdc5946b34010dc934c", "29656": "94aefabdf2bfe135d7e9ff631199d86502699585", "29657": "3da42862fd49f1b2bb6d5aee19c2eef25b679d03"}, "revision_to_date": {"163": 997776334000, "165": 997810742000, "814": 1064991141000, "962": 1080942011000, "998": 1082159940000, "1117": 1097226913000, "1407": 1131777472000, "1439": 1133389533000, "1521": 1137267282000, "1581": 1140351393000, "1699": 1142693999000, "1840": 1148476057000, "2062": 1153921448000, "2114": 1157443182000, "2287": 1165551859000, "3158": 1187463466000, "3258": 1190448800000, "4726": 1227520465000, "5014": 1232169385000, "5053": 1232695694000, "5103": 1235076101000, "5331": 1244097697000, "5348": 1244188045000, "5360": 1244777903000, "5433": 1252844436000, "5728": 1270736740000, "5742": 1271575424000, "5746": 1271603220000, "5747": 1271934000000, "5892": 1275663725000, "5996": 1278233358000, "6001": 1278835148000, "6015": 1279192688000, "6041": 1280155813000, "6406": 1292146170000, "6478": 1295774973000, "6502": 1296402855000, "6533": 1297508161000, "6547": 1298122355000, "6553": 1298194539000, "6567": 1298808413000, "6894": 1315773794000, "6915": 1316190391000, "7024": 1320352769000, "7046": 1321184037000, "7247": 1328901883000, "7306": 1329666728000, "7336": 1330292710000, "7742": 1339535195000, "7806": 1342556008000, "7863": 1344797844000, "8015": 1348306836000, "8684": 1361014570000, "8939": 1364591458000, "9003": 1365246032000, "10009": 1377174831000, "10483": 1381266180000, "10492": 1381435522000, "10569": 1382175820000, "10704": 1384611939000, "10845": 1386455933000, "11142": 1391493657000, "11580": 1394927680000, "11679": 1396469734000, "11741": 1398203488000, "11791": 1399112865000, "12717": 1416778622000, "12841": 1416769691000, "12859": 1418655286000, "12991": 1419958280000, "13101": 1420985662000, "13179": 1421598906000, "13996": 1431464781000, "14034": 1432455325000, "14186": 1436043464000, "14253": 1437681990000, "14947": 1445688336000, "15200": 1448489394000, "15298": 1450866397000, "15389": 1452066840000, "15406": 1452178412000, "15505": 1453474868000, "15524": 1453838503000, "15688": 1455570153000, "15930": 1457302716000, "16030": 1459050617000, "16125": 1460818148000, "16231": 1462558532000, "16259": 1463048199000, "16290": 1464508090000, "16470": 1466248656000, "16524": 1466427615000, "16594": 1468003137000, "16596": 1468017339000, "16651": 1469444270000, "16656": 1469747714000, "16788": 1471623716000, "16869": 1473403864000, "16931": 1474270070000, "16975": 1475169976000, "17152": 1476912084000, "17265": 1478721715000, "17369": 1480535658000, "17478": 1482353312000, "17615": 1484486690000, "17692": 1486490201000, "17746": 1487189736000, "17815": 1487945214000, "17838": 1488324116000, "17861": 1489055939000, "17999": 1491987223000, "18132": 1490135996000, "18152": 1493753858000, "18207": 1495483184000, "18289": 1497228716000, "18296": 1498124930000, "18355": 1499072469000, "18535": 1500832769000, "18778": 1502572664000, "19028": 1504419839000, "19142": 1505642043000, "19160": 1506157438000, "19208": 1506504681000, "19304": 1508010734000, "19344": 1507289532000, "19376": 1508909600000, "19413": 1509805579000, "19479": 1511850043000, "19505": 1513689486000, "19529": 1515434460000, "19587": 1517206037000, "19676": 1519065947000, "19787": 1520974097000, "19853": 1521860985000, "19993": 1522762548000, "20098": 1523796707000, "20133": 1524506200000, "20145": 1525529261000, "20172": 1526276969000, "20232": 1528084797000, "20350": 1529836890000, "20532": 1531728456000, "20605": 1533581125000, "20704": 1535434074000, "20786": 1537191592000, "20890": 1539148790000, "20960": 1540877607000, "21102": 1542638918000, "21142": 1543165997000, "21178": 1543989011000, "21185": 1544675402000, "21213": 1545069008000, "21290": 1546457799000, "21362": 1548280267000, "21433": 1549608686000, "21463": 1550056765000, "21584": 1551968268000, "21684": 1553727667000, "21953": 1555554846000, "22050": 1556308900000, "22084": 1557303904000, "22103": 1557363901000, "22134": 1558028929000, "22183": 1559310775000, "22210": 1559842419000, "22273": 1561055476000, "22451": 1562945355000, "22520": 1450231876000, "22598": 1564677197000, "22668": 1565234278000, "22812": 1566435976000, "23008": 1568172878000, "23095": 1570082302000, "23247": 1571834849000, "23355": 1573302446000, "23438": 1573569874000, "23513": 1574368782000, "23519": 1574465072000, "23585": 1575304010000, "23619": 1575758757000, "23650": 1576503882000, "23670": 1576697430000, "23690": 1577096140000, "23824": 1578921167000, "23846": 1579117998000, "23871": 1579280878000, "23910": 1579553235000, "23915": 1579635009000, "23933": 1580018647000, "23948": 1580344849000, "23962": 1580697618000, "23967": 1580980376000, "23971": 1581092763000, "23972": 1581158600000, "23973": 1581211284000, "23977": 1581264125000, "23979": 1581309973000, "24006": 1581454129000, "24007": 1581455761000, "24008": 1581455995000, "24010": 1580996972000, "24019": 1581521096000, "24022": 1581528886000, "24023": 1581531389000, "24028": 1581566025000, "24033": 1581576133000, "24034": 1581576336000, "24035": 1581581382000, "24037": 1581627743000, "24038": 1581645799000, "24043": 1581684607000, "24044": 1581528262000, "24049": 1581756845000, "24068": 1581794141000, "24069": 1581855314000, "24070": 1581880275000, "24085": 1581980319000, "24088": 1581982367000, "24091": 1581985908000, "24100": 1582005086000, "24102": 1582011299000, "24104": 1582011391000, "24109": 1582077177000, "24110": 1582084960000, "24116": 1582169984000, "24119": 1582227422000, "24120": 1582254815000, "24130": 1582434525000, "24133": 1582468353000, "24134": 1582468573000, "24135": 1582468808000, "24137": 1582488615000, "24138": 1582501693000, "24143": 1582515775000, "24145": 1582616471000, "24147": 1582662763000, "24150": 1582674931000, "24152": 1582773170000, "24158": 1582862300000, "24159": 1582869897000, "24160": 1582922425000, "24173": 1583101155000, "24178": 1583270690000, "24179": 1583300366000, "24185": 1583314493000, "24187": 1583305249000, "24192": 1583408233000, "24197": 1583571787000, "24199": 1583617718000, "24200": 1583620608000, "24201": 1583621001000, "24202": 1583628611000, "24204": 1583652740000, "24208": 1583689573000, "24210": 1583741319000, "24211": 1583813938000, "24213": 1583857106000, "24216": 1583944631000, "24217": 1583961023000, "24221": 1583971783000, "24225": 1584044896000, "24226": 1584057712000, "24244": 1584272690000, "24247": 1584293807000, "24248": 1584332529000, "24254": 1584456516000, "24256": 1584457252000, "24264": 1584560424000, "24265": 1584560662000, "24270": 1584610684000, "24271": 1584614938000, "24274": 1584637600000, "24282": 1584719454000, "24284": 1584722858000, "24286": 1584742879000, "24288": 1584790384000, "24292": 1584819784000, "24293": 1584820262000, "24294": 1584824261000, "24295": 1584828252000, "24298": 1585048884000, "24301": 1585129125000, "24302": 1585131837000, "24304": 1585141360000, "24305": 1585171680000, "24307": 1585306280000, "24309": 1585310784000, "24310": 1585310895000, "24313": 1585311399000, "24315": 1585318325000, "24316": 1585318641000, "24325": 1585405224000, "24326": 1585406701000, "24329": 1585424169000, "24331": 1585433390000, "24335": 1585457699000, "24337": 1585477970000, "24338": 1585481706000, "24341": 1585528720000, "24343": 1585570803000, "24348": 1585621177000, "24353": 1585647689000, "24354": 1585648037000, "24362": 1585784535000, "24366": 1585797270000, "24374": 1585840956000, "24376": 1585885385000, "24380": 1585992925000, "24381": 1585996689000, "24383": 1586023299000, "24386": 1586057033000, "24388": 1586088525000, "24390": 1586132545000, "24391": 1586145846000, "24392": 1586171738000, "24393": 1586181462000, "24394": 1586198345000, "24400": 1586318226000, "24402": 1586373184000, "24410": 1586392238000, "24422": 1586420190000, "24423": 1586423996000, "24425": 1586429189000, "24430": 1586455492000, "24438": 1586518999000, "24443": 1586550108000, "24450": 1586565875000, "24458": 1586609683000, "24470": 1586678387000, "24471": 1586685698000, "24473": 1586709199000, "24480": 1586747156000, "24481": 1586747986000, "24484": 1586814649000, "24485": 1586815177000, "24486": 1586815682000, "24490": 1586824100000, "24491": 1586829140000, "24492": 1586830708000, "24493": 1586846820000, "24494": 1586847096000, "24495": 1586888927000, "24510": 1586964254000, "24512": 1586981103000, "24519": 1587040381000, "24525": 1587078857000, "24526": 1587082840000, "24529": 1587089753000, "24534": 1587097344000, "24540": 1587119774000, "24541": 1587128558000, "24551": 1587169024000, "24556": 1587204397000, "24557": 1587206470000, "24558": 1587207009000, "24563": 1587241709000, "24564": 1587242520000, "24566": 1587257351000, "24569": 1587290446000, "24571": 1587298055000, "24575": 1587318411000, "24578": 1587330736000, "24579": 1587345331000, "24583": 1586117192000, "24585": 1586194094000, "24587": 1586705469000, "24589": 1586797757000, "24591": 1587383786000, "24595": 1587448879000, "24597": 1587473297000, "24600": 1587590523000, "24602": 1587610536000, "24604": 1587682692000, "24606": 1587725349000, "24607": 1587740460000, "24609": 1587822279000, "24611": 1587829034000, "24619": 1587890725000, "24621": 1587892715000, "24623": 1587894129000, "24625": 1587894506000, "24627": 1587895347000, "24630": 1587918047000, "24632": 1587923136000, "24635": 1587925191000, "24639": 1587930097000, "24650": 1587942517000, "24651": 1587943037000, "24657": 1588008401000, "24660": 1588017416000, "24661": 1588021131000, "24662": 1588021868000, "24667": 1588061467000, "24668": 1588062584000, "24670": 1588087353000, "24673": 1588106496000, "24682": 1588133701000, "24683": 1588146403000, "24684": 1588148409000, "24686": 1588191793000, "24691": 1588207699000, "24697": 1588260187000, "24701": 1588325563000, "24703": 1588369403000, "24705": 1588379914000, "24710": 1588396185000, "24717": 1588436355000, "24718": 1588444710000, "24719": 1588447555000, "24720": 1588449045000, "24721": 1588458149000, "24722": 1588460552000, "24729": 1588514678000, "24730": 1588514742000, "24731": 1588514877000, "24732": 1588514894000, "24752": 1588588437000, "24753": 1588588656000, "24754": 1588590380000, "24757": 1588604195000, "24759": 1588627014000, "24760": 1588628403000, "24775": 1588700982000, "24776": 1588702663000, "24778": 1588718107000, "24780": 1588718145000, "24782": 1588729219000, "24787": 1588742852000, "24791": 1588795339000, "24792": 1588799607000, "24793": 1588800533000, "24802": 1588884531000, "24805": 1588902127000, "24809": 1588914327000, "24811": 1588915418000, "24813": 1588916035000, "24818": 1588922206000, "24827": 1589013205000, "24829": 1589032209000, "24835": 1589050140000, "24839": 1589055766000, "24841": 1589057031000, "24842": 1589058595000, "24849": 1589105695000, "24850": 1589105818000, "24852": 1589106272000, "24853": 1589113064000, "24854": 1589113175000, "24857": 1589120546000, "24860": 1589172726000, "24861": 1589188814000, "24863": 1589209934000, "24866": 1589217802000, "24869": 1589278882000, "24870": 1589279746000, "24871": 1589348913000, "24872": 1589388937000, "24875": 1589435665000, "24877": 1589575532000, "24879": 1589599585000, "24881": 1589617972000, "24882": 1589642326000, "24885": 1589671965000, "24889": 1589691947000, "24890": 1589692557000, "24891": 1589693104000, "24901": 1589735395000, "24902": 1589736062000, "24906": 1589763182000, "24908": 1589806395000, "24910": 1589827075000, "24913": 1589846628000, "24914": 1589850070000, "24916": 1589940488000, "24920": 1589967906000, "24921": 1589968030000, "24923": 1589969631000, "24924": 1589969748000, "24927": 1589994694000, "24928": 1589994712000, "24929": 1589996517000, "24931": 1589999814000, "24932": 1590020688000, "24935": 1590029094000, "24939": 1590064046000, "24941": 1590097846000, "24942": 1590104303000, "24944": 1590112831000, "24951": 1590162864000, "24952": 1590190485000, "24982": 1590521267000, "25012": 1590666656000, "25030": 1590803305000, "25040": 1591051317000, "25063": 1591303889000, "25073": 1591478446000, "25111": 1591978868000, "25113": 1592082195000, "25127": 1592412481000, "25129": 1592534090000, "25131": 1592572772000, "25135": 1592663253000, "25136": 1592671869000, "25139": 1592680471000, "25151": 1592876242000, "25159": 1592924220000, "25164": 1593076178000, "25172": 1593360669000, "25181": 1593531519000, "25185": 1593541875000, "25189": 1593656662000, "25190": 1592843053000, "25193": 1592733645000, "25195": 1593875972000, "25206": 1593893033000, "25208": 1593894940000, "25209": 1592749847000, "25213": 1593984604000, "25214": 1594020685000, "25216": 1594074511000, "25217": 1594076959000, "25218": 1594089375000, "25220": 1594110928000, "25223": 1594147633000, "25224": 1594148898000, "25225": 1592325543000, "25226": 1592325569000, "25227": 1592504579000, "25228": 1592506402000, "25239": 1594232220000, "25240": 1594138539000, "25241": 1594334043000, "25244": 1594348464000, "25249": 1594390480000, "25254": 1594421005000, "25258": 1594420209000, "25261": 1540821954000, "25264": 1592255744000, "25267": 1593634504000, "25268": 1593595061000, "25269": 1594497183000, "25271": 1594542729000, "25272": 1594550727000, "25273": 1594550887000, "25274": 1594485468000, "25289": 1594817671000, "25293": 1594852146000, "25294": 1594915642000, "25295": 1594915745000, "25296": 1594916904000, "25301": 1594958251000, "25303": 1594978929000, "25304": 1594980065000, "25308": 1595002525000, "25309": 1595018840000, "25310": 1595023831000, "25311": 1595025187000, "25320": 1595074103000, "25323": 1595075683000, "25330": 1595083039000, "25334": 1595093065000, "25366": 1595110961000, "25368": 1595123238000, "25369": 1595167214000, "25370": 1595189682000, "25373": 1595230033000, "25383": 1595235492000, "25384": 1595236703000, "25385": 1595239662000, "25387": 1595291623000, "25388": 1595300237000, "25389": 1595334664000, "25396": 1595399211000, "25397": 1595407785000, "25398": 1595434715000, "25399": 1595468702000, "25404": 1595583861000, "25405": 1595609529000, "25407": 1595750401000, "25408": 1595750579000, "25410": 1595790835000, "25411": 1595810260000, "25412": 1595812795000, "25415": 1595894785000, "25416": 1595921804000, "25417": 1595931394000, "25418": 1595955762000, "25425": 1596099536000, "25426": 1596099929000, "25427": 1596139163000, "25433": 1596198368000, "25436": 1596318992000, "25438": 1596325002000, "25439": 1596356101000, "25440": 1596457003000, "25444": 1596496331000, "25446": 1596529570000, "25448": 1596558438000, "25454": 1596651746000, "25455": 1596665697000, "25456": 1596665732000, "25466": 1596794362000, "25468": 1596819294000, "25472": 1596919212000, "25474": 1596980601000, "25475": 1596980641000, "25476": 1596980893000, "25477": 1596981239000, "25479": 1596995722000, "25480": 1597002291000, "25483": 1597112969000, "25484": 1597113619000, "25488": 1597167970000, "25489": 1597199242000, "25491": 1597239195000, "25493": 1597285802000, "25495": 1597312209000, "25496": 1597413606000, "25498": 1597531961000, "25501": 1597590095000, "25503": 1597690361000, "25504": 1597698419000, "25505": 1597730866000, "25506": 1597751728000, "25507": 1597818780000, "25510": 1597857170000, "25519": 1597904767000, "25520": 1597500676000, "25521": 1597634442000, "25526": 1598171661000, "25530": 1598299997000, "25532": 1598347792000, "25535": 1598397867000, "25537": 1598413678000, "25538": 1598413816000, "25541": 1598454293000, "25542": 1598487283000, "25544": 1598635914000, "25546": 1598676336000, "25547": 1598718637000, "25555": 1598744821000, "25556": 1598779081000, "25557": 1598894228000, "25559": 1599073348000, "25561": 1599127755000, "25564": 1599208399000, "25566": 1599245900000, "25568": 1599251667000, "25569": 1599340391000, "25570": 1599346872000, "25573": 1599499460000, "25575": 1599565826000, "25576": 1599566353000, "25579": 1599617560000, "25583": 1599703024000, "25584": 1599742494000, "25589": 1599837025000, "25592": 1599882669000, "25593": 1599907742000, "25598": 1600037626000, "25599": 1600096285000, "25600": 1600096678000, "25601": 1600137147000, "25605": 1600404774000, "25615": 1600607087000, "25616": 1600745332000, "25619": 1600896405000, "25620": 1600955017000, "25621": 1600984031000, "25623": 1601049468000, "25624": 1601401307000, "25627": 1601513194000, "25628": 1601574539000, "25629": 1601459065000, "25651": 1601671547000, "25653": 1601686589000, "25656": 1601744967000, "25657": 1601747262000, "25662": 1602062042000, "25667": 1602150848000, "25669": 1602165440000, "25670": 1602205499000, "25671": 1602283878000, "25673": 1602437116000, "25676": 1602474629000, "25683": 1602856120000, "25684": 1602856397000, "25685": 1602857222000, "25686": 1602873729000, "25687": 1602891609000, "25688": 1602904352000, "25693": 1602991373000, "25694": 1603048661000, "25701": 1603104691000, "25704": 1603126110000, "25705": 1603128483000, "25706": 1603129380000, "25708": 1603200023000, "25709": 1603227718000, "25713": 1603354964000, "25714": 1603380306000, "25716": 1603484449000, "25720": 1603678731000, "25723": 1603766298000, "25724": 1603767343000, "25729": 1603826652000, "25730": 1603851926000, "25733": 1603999384000, "25736": 1604146869000, "25737": 1604148345000, "25740": 1604189618000, "25746": 1604228396000, "25748": 1604228845000, "25751": 1604231773000, "25753": 1604233119000, "25758": 1604264415000, "25760": 1604269999000, "25773": 1604309140000, "25776": 1604320848000, "25777": 1604396994000, "25778": 1604409139000, "25781": 1604456780000, "25784": 1604644756000, "25785": 1604715364000, "25790": 1604871076000, "25793": 1604892062000, "25806": 1604973022000, "25825": 1604959197000, "25828": 1600779557000, "25834": 1605129077000, "25837": 1605161188000, "25840": 1605191093000, "25843": 1605234424000, "25844": 1605235279000, "25853": 1605388572000, "25854": 1605389994000, "25855": 1605391564000, "25856": 1605393235000, "25857": 1605394235000, "25859": 1605440696000, "25860": 1605441446000, "25863": 1605490591000, "25866": 1605617077000, "25867": 1605620007000, "25869": 1605633122000, "25870": 1605649367000, "25879": 1605763428000, "25899": 1605842328000, "25907": 1605882621000, "25913": 1605917890000, "25914": 1605920897000, "25917": 1605993344000, "25921": 1606003121000, "25926": 1606012007000, "25927": 1606014390000, "25934": 1606246671000, "25936": 1606267463000, "25937": 1606273543000, "25951": 1606306947000, "25953": 1606307453000, "25955": 1606309267000, "25957": 1606328314000, "25962": 1606344597000, "25964": 1606360595000, "25972": 1606424288000, "25973": 1606432014000, "25974": 1606447427000, "25976": 1606460127000, "25977": 1606467169000, "25979": 1606476437000, "25981": 1606484175000, "25986": 1606570303000, "25987": 1606570603000, "25988": 1606570654000, "25989": 1606571130000, "25990": 1606571270000, "25997": 1606605147000, "26003": 1606650062000, "26004": 1606653895000, "26006": 1606664409000, "26009": 1606678937000, "26012": 1606782467000, "26014": 1606785949000, "26020": 1606793364000, "26023": 1606818593000, "26024": 1606824044000, "26025": 1606877638000, "26029": 1606956900000, "26030": 1606964388000, "26032": 1606985019000, "26033": 1607032147000, "26035": 1607206460000, "26037": 1607246664000, "26040": 1607359296000, "26042": 1607385921000, "26047": 1607481296000, "26048": 1607481614000, "26049": 1607490164000, "26054": 1607572665000, "26064": 1607726517000, "26065": 1607804481000, "26066": 1607804680000, "26067": 1607825504000, "26069": 1607855584000, "26070": 1607856597000, "26074": 1607968860000, "26077": 1608029851000, "26086": 1608140612000, "26091": 1608273020000, "26092": 1608274499000, "26098": 1608355433000, "26103": 1608416932000, "26106": 1608438888000, "26108": 1608493095000, "26110": 1608498459000, "26111": 1608500464000, "26114": 1608508468000, "26115": 1608525076000, "26116": 1608525402000, "26118": 1608537133000, "26168": 1608648858000, "26171": 1608719781000, "26173": 1608720875000, "26178": 1608774572000, "26187": 1608824862000, "26188": 1608828127000, "26189": 1608873795000, "26200": 1609020100000, "26202": 1609022287000, "26203": 1609118756000, "26205": 1609246269000, "26206": 1609246371000, "26207": 1609246723000, "26209": 1609252152000, "26214": 1609339546000, "26218": 1609369681000, "26232": 1609513104000, "26248": 1609542512000, "26260": 1609617140000, "26265": 1609700224000, "26268": 1609735411000, "26269": 1609738280000, "26272": 1609777215000, "26275": 1609779813000, "26277": 1609793388000, "26279": 1609798030000, "26281": 1609805753000, "26282": 1609812551000, "26286": 1609913108000, "26291": 1609998675000, "26293": 1610193653000, "26298": 1610227729000, "26300": 1610307309000, "26304": 1610367597000, "26307": 1610593957000, "26308": 1610606977000, "26310": 1610598914000, "26312": 1610668860000, "26324": 1610754351000, "26328": 1610823633000, "26329": 1610899883000, "26330": 1610900323000, "26333": 1611101434000, "26336": 1611184228000, "26337": 1611200840000, "26341": 1611282481000, "26344": 1611303650000, "26345": 1611363902000, "26346": 1611370834000, "26353": 1611432581000, "26354": 1611447645000, "26355": 1611522214000, "26359": 1611594208000, "26360": 1611600186000, "26361": 1611609302000, "26362": 1611630465000, "26363": 1611631826000, "26364": 1611428436000, "26365": 1611730449000, "26369": 1611749656000, "26370": 1611769323000, "26371": 1611773503000, "26390": 1611847645000, "26399": 1611891936000, "26400": 1611898429000, "26411": 1611961921000, "26412": 1611970612000, "26413": 1611974127000, "26417": 1612016740000, "26418": 1612020315000, "26424": 1612077851000, "26429": 1612118981000, "26430": 1612119009000, "26435": 1612122102000, "26438": 1612124111000, "26442": 1612153175000, "26443": 1612164322000, "26444": 1612197354000, "26446": 1612208405000, "26448": 1612216251000, "26449": 1612216870000, "26450": 1612217021000, "26451": 1612149656000, "26461": 1612295226000, "26462": 1612316981000, "26464": 1612386314000, "26466": 1612468541000, "26468": 1612481763000, "26469": 1612498746000, "26470": 1612557609000, "26471": 1612557791000, "26472": 1612559122000, "26476": 1612638226000, "26477": 1612649976000, "26478": 1612721347000, "26481": 1612796876000, "26482": 1612840043000, "26484": 1612912640000, "26486": 1612983113000, "26512": 1612644309000, "26513": 1613094992000, "26514": 1613095166000, "26517": 1613140357000, "26519": 1613173543000, "26520": 1613198619000, "26530": 1613257322000, "26532": 1613298451000, "26536": 1613455804000, "26538": 1613470627000, "26541": 1613494086000, "26547": 1613535924000, "26548": 1613557233000, "26549": 1613565644000, "26551": 1613586651000, "26555": 1613644241000, "26557": 1613653792000, "26558": 1613661689000, "26559": 1613661855000, "26561": 1613716233000, "26562": 1613726978000, "26563": 1613750467000, "26564": 1613792293000, "26566": 1613837200000, "26567": 1613878091000, "26569": 1613966691000, "26575": 1614011519000, "26579": 1614135951000, "26591": 1614299357000, "26592": 1614299977000, "26595": 1614386991000, "26597": 1614451106000, "26599": 1614452180000, "26607": 1614461829000, "26611": 1614517929000, "26612": 1614517989000, "26613": 1614518040000, "26629": 1614527931000, "26630": 1614528022000, "26632": 1614561101000, "26644": 1614690619000, "26645": 1614793456000, "26648": 1614994500000, "26654": 1615023265000, "26657": 1615045854000, "26658": 1615057175000, "26659": 1615058238000, "26660": 1615058372000, "26662": 1615066998000, "26663": 1615134215000, "26665": 1615143216000, "26668": 1615236161000, "26669": 1615258764000, "26670": 1615294321000, "26672": 1615322518000, "26673": 1615324681000, "26677": 1615518064000, "26727": 1616119701000, "26753": 1616364157000, "26902": 1617905689000, "27053": 1619317580000, "27079": 1619687621000, "27240": 1621433274000, "27383": 1622940120000, "27408": 1623261410000, "27459": 1623637014000, "27460": 1623785428000, "27480": 1624059029000, "27485": 1624096268000, "27486": 1624096718000, "27491": 1624132720000, "27493": 1624137474000, "27500": 1624195971000, "27503": 1624222584000, "27506": 1624292376000, "27510": 1624344778000, "27522": 1624415129000, "27524": 1618673141000, "27526": 1624470298000, "27530": 1624513390000, "27532": 1624563543000, "27534": 1624572691000, "27535": 1624586285000, "27536": 1624586689000, "27544": 1624712438000, "27548": 1624724118000, "27551": 1624816894000, "27552": 1624826644000, "27553": 1624832723000, "27556": 1624888689000, "27559": 1624993373000, "27563": 1625051169000, "27572": 1625126186000, "27578": 1625211004000, "27581": 1625269110000, "27582": 1625270246000, "27584": 1625351537000, "27585": 1625361162000, "27591": 1625442891000, "27592": 1625475538000, "27599": 1625617064000, "27600": 1625618693000, "27601": 1625638739000, "27610": 1625717743000, "27611": 1625741196000, "27612": 1625948112000, "27613": 1625952719000, "27616": 1626014084000, "27617": 1626014192000, "27620": 1626097188000, "27622": 1626110342000, "27623": 1626114818000, "27631": 1626161885000, "27632": 1626165173000, "27634": 1626192692000, "27637": 1626251592000, "27640": 1626373686000, "27643": 1626376906000, "27644": 1626377157000, "27645": 1626420873000, "27646": 1626421190000, "27647": 1626421553000, "27649": 1626539428000, "27654": 1626635940000, "27659": 1626750143000, "27660": 1626771418000, "27662": 1626809321000, "27664": 1626832570000, "27665": 1626851074000, "27667": 1626901285000, "27668": 1626928863000, "27679": 1627035055000, "27681": 1627067270000, "27695": 1627076115000, "27696": 1627125042000, "27697": 1627134977000, "27699": 1627159810000, "27703": 1627277841000, "27704": 1627317715000, "27714": 1627468223000, "27715": 1627561298000, "27716": 1627566077000, "27717": 1627619881000, "27718": 1627746909000, "27719": 1627754588000, "27721": 1627757299000, "27725": 1627819777000, "27726": 1627821736000, "27730": 1627851357000, "27734": 1627883444000, "27737": 1627906899000, "27738": 1627937976000, "27739": 1628015033000, "27740": 1628019374000, "27742": 1628115733000, "27743": 1628118637000, "27745": 1628158197000, "27751": 1628215474000, "27752": 1628236687000, "27753": 1628256920000, "27759": 1628374372000, "27761": 1628438241000, "27769": 1628505368000, "27773": 1628540249000, "27776": 1628814637000, "27777": 1628959518000, "27778": 1629072371000, "27781": 1629168499000, "27783": 1629208419000, "27785": 1629226965000, "27794": 1629306473000, "27795": 1629310461000, "27799": 1629371076000, "27801": 1629396965000, "27802": 1629405106000, "27809": 1629454647000, "27812": 1629466236000, "27813": 1629471558000, "27816": 1629555178000, "27817": 1629575163000, "27835": 1629710410000, "27838": 1629743294000, "27839": 1629759464000, "27840": 1629772022000, "27841": 1629772901000, "27845": 1629852754000, "27846": 1629924084000, "27847": 1629925765000, "27850": 1629972670000, "27851": 1629973170000, "27853": 1630044919000, "27854": 1630048342000, "27855": 1630058859000, "27857": 1630150252000, "27860": 1630182390000, "27861": 1630183508000, "27862": 1630215205000, "27864": 1630303038000, "27943": 1632070356000, "28011": 1633822228000, "28142": 1635559279000, "28192": 1636149643000, "28312": 1637306449000, "28344": 1637728273000, "28460": 1639062361000, "28478": 1639176366000, "28529": 1640023451000, "28625": 1640814309000, "28777": 1642564068000, "28783": 1642637475000, "28890": 1643497438000, "28893": 1643521050000, "28935": 1643985741000, "28944": 1644167904000, "28954": 1644318495000, "28975": 1644483957000, "28977": 1644507335000, "28980": 1644510425000, "28981": 1644512537000, "28982": 1644549133000, "28984": 1644636344000, "28990": 1644847581000, "28992": 1644848729000, "28994": 1644859213000, "28997": 1644907510000, "28998": 1644940353000, "29000": 1645006793000, "29001": 1645025834000, "29004": 1645087397000, "29014": 1645132045000, "29015": 1645135483000, "29018": 1645156173000, "29022": 1645177730000, "29024": 1645191302000, "29026": 1645368888000, "29027": 1645375393000, "29029": 1645382863000, "29031": 1645434249000, "29033": 1645463644000, "29035": 1645484902000, "29036": 1645535496000, "29037": 1645537351000, "29038": 1645588190000, "29042": 1645620728000, "29043": 1645628114000, "29056": 1645744035000, "29062": 1645795046000, "29066": 1645812803000, "29068": 1645822142000, "29071": 1645845109000, "29073": 1645878104000, "29075": 1645888573000, "29077": 1645925890000, "29078": 1645948167000, "29080": 1645985434000, "29081": 1646052121000, "29082": 1646073659000, "29084": 1646186059000, "29085": 1646192362000, "29086": 1646216546000, "29087": 1646375004000, "29091": 1646412619000, "29092": 1646473201000, "29093": 1646513422000, "29094": 1646523528000, "29095": 1646590995000, "29099": 1646626020000, "29100": 1646636872000, "29101": 1646638874000, "29103": 1646715343000, "29105": 1646727243000, "29107": 1646754269000, "29108": 1646825699000, "29109": 1646839770000, "29111": 1646911655000, "29112": 1646949797000, "29114": 1647018118000, "29115": 1647029354000, "29116": 1647030751000, "29117": 1647067434000, "29118": 1647166002000, "29120": 1647245711000, "29122": 1647271687000, "29125": 1647289304000, "29126": 1647352750000, "29149": 1647362062000, "29150": 1647375740000, "29152": 1647433416000, "29154": 1647447644000, "29155": 1647461334000, "29160": 1647521129000, "29162": 1647549401000, "29164": 1647550430000, "29170": 1647605957000, "29175": 1647634403000, "29178": 1647635130000, "29179": 1647653634000, "29195": 1647807131000, "29196": 1647812391000, "29202": 1647856723000, "29205": 1647859853000, "29210": 1647891709000, "29212": 1647915946000, "29213": 1647918229000, "29226": 1647989818000, "29227": 1648025941000, "29232": 1648090044000, "29233": 1648106647000, "29234": 1648137467000, "29237": 1648210799000, "29243": 1648223018000, "29250": 1648247544000, "29255": 1648307738000, "29261": 1648388718000, "29267": 1648411285000, "29271": 1648422644000, "29272": 1648441435000, "29273": 1648475604000, "29274": 1648576786000, "29276": 1648610788000, "29277": 1648629348000, "29278": 1648670693000, "29280": 1648766436000, "29281": 1648767657000, "29288": 1648801147000, "29293": 1648849617000, "29294": 1648857395000, "29296": 1648920994000, "29297": 1648921202000, "29298": 1648932260000, "29323": 1649106178000, "29324": 1649112234000, "29325": 1649125313000, "29326": 1649218344000, "29327": 1649223432000, "29329": 1649363862000, "29330": 1649499923000, "29331": 1649502635000, "29332": 1649505761000, "29333": 1649590663000, "29334": 1649609156000, "29336": 1649694192000, "29337": 1649760874000, "29339": 1648518064000, "29340": 1648729921000, "29341": 1649911279000, "29342": 1649943693000, "29343": 1649970108000, "29345": 1650026124000, "29346": 1650034654000, "29347": 1650087778000, "29350": 1650239333000, "29355": 1650274809000, "29356": 1650303457000, "29357": 1650323428000, "29360": 1650392704000, "29361": 1650395968000, "29364": 1650406416000, "29367": 1650441681000, "29368": 1650458220000, "29369": 1650490477000, "29371": 1650526341000, "29373": 1650584990000, "29376": 1650629094000, "29379": 1650645978000, "29381": 1650654830000, "29383": 1650735668000, "29384": 1650736897000, "29387": 1650791205000, "29389": 1650816166000, "29395": 1650838134000, "29396": 1650888024000, "29397": 1650895039000, "29398": 1650913160000, "29401": 1651000747000, "29404": 1651003517000, "29407": 1651013277000, "29416": 1651093837000, "29417": 1651096499000, "29418": 1651097279000, "29419": 1651160017000, "29420": 1651162799000, "29422": 1651188580000, "29424": 1651251538000, "29427": 1651269937000, "29434": 1651339098000, "29436": 1651352394000, "29443": 1651413521000, "29444": 1651431109000, "29445": 1651446177000, "29447": 1651485845000, "29448": 1651503478000, "29450": 1651531563000, "29455": 1651564828000, "29457": 1651587434000, "29459": 1651593726000, "29461": 1651671660000, "29465": 1651674950000, "29467": 1651688107000, "29471": 1651758819000, "29472": 1651770385000, "29473": 1651783395000, "29475": 1651804458000, "29476": 1651853323000, "29479": 1651907440000, "29490": 1652021037000, "29491": 1652036326000, "29498": 1652199096000, "29499": 1652203134000, "29500": 1652233192000, "29503": 1652290678000, "29507": 1652383450000, "29512": 1652164433000, "29518": 1652472590000, "29522": 1652484148000, "29526": 1652493478000, "29527": 1652536904000, "29529": 1652563676000, "29531": 1652624396000, "29543": 1652704846000, "29544": 1652710522000, "29548": 1652718591000, "29549": 1652721209000, "29563": 1652896212000, "29564": 1652896768000, "29565": 1652912556000, "29567": 1652935052000, "29572": 1652990240000, "29601": 1653069260000, "29602": 1653069382000, "29605": 1653076191000, "29611": 1653153144000, "29615": 1653225648000, "29616": 1653237677000, "29617": 1653242878000, "29622": 1653288750000, "29624": 1653313198000, "29629": 1653348297000, "29631": 1653427565000, "29633": 1653428233000, "29635": 1653431092000, "29638": 1653449604000, "29640": 1653471941000, "29648": 1653506108000, "29651": 1653555099000, "29653": 1653569703000, "29655": 1653598635000, "29656": 1653650712000, "29657": 1653691015000}, "params": {"arch": ["x86_64"], "cpu": ["Intel(R) Atom(TM) CPU N2800   @ 1.86GHz", "Intel(R) Core(TM) i7 CPU 920 @ 2.67GHz"], "machine": ["atom", "i7"], "num_cpu": ["8", null], "os": ["Linux", "Linux 3.16.0-4-amd64"], "ram": ["16416652", "4041288"], "python": ["3.7", "3.9"], "numpy": ["1.14.5", "1.21.5"], "Tempita": ["0.5.2"], "Cython": ["0.29.20", "0.29.21", "0.29.27"], "pytest": [""], "six": [""], "pybind11": ["2.3.0", "2.5.0", "2.9.0"], "pythran": ["", null], "setuptools": ["59.8.0", null], "branch": ["main"]}, "graph_param_list": [{"arch": "x86_64", "cpu": "Intel(R) Core(TM) i7 CPU 920 @ 2.67GHz", "machine": "i7", "num_cpu": "8", "os": "Linux", "ram": "16416652", "python": "3.7", "numpy": "1.14.5", "Tempita": "0.5.2", "Cython": "0.29.21", "pytest": "", "six": "", "pybind11": "2.5.0", "pythran": "", "branch": "main", "setuptools": null}, {"arch": "x86_64", "cpu": "Intel(R) Core(TM) i7 CPU 920 @ 2.67GHz", "machine": "i7", "num_cpu": "8", "os": "Linux", "ram": "16416652", "python": "3.9", "numpy": "1.21.5", "Tempita": "0.5.2", "Cython": "0.29.27", "pytest": "", "six": "", "pybind11": "2.9.0", "pythran": "", "setuptools": "59.8.0", "branch": "main"}, {"arch": "x86_64", "cpu": "Intel(R) Atom(TM) CPU N2800   @ 1.86GHz", "machine": "atom", "os": "Linux 3.16.0-4-amd64", "ram": "4041288", "python": "3.7", "numpy": "1.14.5", "Tempita": "0.5.2", "Cython": "0.29.20", "pytest": "", "six": "", "pybind11": "2.3.0", "branch": "main", "num_cpu": null, "pythran": null, "setuptools": null}], "benchmarks": {"blas_lapack.GetBlasLapackFuncs.time_find_best_blas_type": {"code": "class GetBlasLapackFuncs:\n    def time_find_best_blas_type(self, dtype1, dtype2, dtype1_ord, dtype2_ord, size):\n        prefix, dtype, prefer_fortran = bla.find_best_blas_type((self.arr1, self.arr2))\n\n    def setup(self, dtype1, dtype2, dtype1_ord, dtype2_ord, size):\n        self.arr1 = np.empty(size, dtype=dtype1, order=dtype1_ord)\n        self.arr2 = np.empty(size, dtype=dtype2, order=dtype2_ord)", "min_run_count": 2, "name": "blas_lapack.GetBlasLapackFuncs.time_find_best_blas_type", "number": 0, "param_names": ["dtype1", "dtype2", "dtype1_ord", "dtype2_ord", "size"], "params": [["'b'", "'G'", "'d'"], ["'d'", "'F'", "'?'"], ["'C'", "'F'"], ["'C'", "'F'"], ["10", "100", "1000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "693d25749534553dc3b95bf58b636610a499cd9a6a94d2b82421ebe862eb614c", "warmup_time": -1}, "cluster.HierarchyLinkage.time_linkage": {"code": "class HierarchyLinkage:\n    def time_linkage(self, method):\n        linkage(self.X, method=method)", "min_run_count": 2, "name": "cluster.HierarchyLinkage.time_linkage", "number": 0, "param_names": ["method"], "params": [["'single'", "'complete'", "'average'", "'weighted'", "'centroid'", "'median'", "'ward'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "886a23bad5fa5a00c76656791c898c69a0805a80db466949f34edc28f9ce00bd", "warmup_time": -1}, "cluster.KMeans.time_kmeans": {"code": "class KMeans:\n    def time_kmeans(self, k):\n        kmeans(self.obs, k, iter=10)", "min_run_count": 2, "name": "cluster.KMeans.time_kmeans", "number": 0, "param_names": ["k"], "params": [["2", "10", "50"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "62d888a0d1080159d649bb8fd1de0cfe8b8b1f892bbeeb7f60de3bf620d20ffb", "warmup_time": -1}, "cluster.KMeans2.time_kmeans2": {"code": "class KMeans2:\n    def time_kmeans2(self, k, init):\n        with suppress_warnings() as sup:\n            sup.filter(UserWarning,\n                       \"One of the clusters is empty. Re-run kmeans with a \"\n                       \"different initialization\")\n            kmeans2(self.obs, k, minit=init, iter=10)", "min_run_count": 2, "name": "cluster.KMeans2.time_kmeans2", "number": 0, "param_names": ["k", "init"], "params": [["2", "10", "50"], ["'random'", "'points'", "'++'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c31b9cbce459810759ed0885ce6ceb752574888dda15e6d1ca13e71eed225442", "warmup_time": -1}, "cluster.VQ.time_vq": {"code": "class VQ:\n    def time_vq(self, k, dtype):\n        vq(self.obs, self.cbook)\n\n    def setup(self, k, dtype):\n        self.obs = self.data.astype(dtype)\n        self.cbook = self.cbook_source[:k].astype(dtype)", "min_run_count": 2, "name": "cluster.VQ.time_vq", "number": 0, "param_names": ["k", "dtype"], "params": [["2", "10", "50"], ["'float32'", "'float64'", "'float128'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a8ef1a2c1ab11f03bd5a06903492b4472e58f2c62499acb3b715e3cf963ee3f0", "warmup_time": -1}, "cluster_hierarchy_disjoint_set.Bench.time_absence": {"code": "class Bench:\n    def time_absence(self, n):\n        # Test for absence\n        assert None not in self.pre_merged\n        assert \"dummy\" not in self.pre_merged\n        assert (1, 2, 3) not in self.pre_merged\n\n    def setup(self, n):\n        # Create random edges\n        rng = np.random.RandomState(seed=0)\n        self.edges = rng.randint(0, 10 * n, (n, 2))\n        self.nodes = np.unique(self.edges)\n        self.disjoint_set = DisjointSet(self.nodes)\n    \n        self.pre_merged = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged.merge(a, b)\n    \n        self.pre_merged_found = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged_found.merge(a, b)\n        for x in self.nodes:\n            self.pre_merged_found[x]", "min_run_count": 2, "name": "cluster_hierarchy_disjoint_set.Bench.time_absence", "number": 0, "param_names": ["n"], "params": [["100", "1000", "10000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "28b77d7db34292d962c123ef1cfc01ff87126b979482d56aef240642d196c8e4", "warmup_time": -1}, "cluster_hierarchy_disjoint_set.Bench.time_contains": {"code": "class Bench:\n    def time_contains(self, n):\n        assert self.nodes[0] in self.pre_merged\n        assert self.nodes[n // 2] in self.pre_merged\n        assert self.nodes[-1] in self.pre_merged\n\n    def setup(self, n):\n        # Create random edges\n        rng = np.random.RandomState(seed=0)\n        self.edges = rng.randint(0, 10 * n, (n, 2))\n        self.nodes = np.unique(self.edges)\n        self.disjoint_set = DisjointSet(self.nodes)\n    \n        self.pre_merged = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged.merge(a, b)\n    \n        self.pre_merged_found = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged_found.merge(a, b)\n        for x in self.nodes:\n            self.pre_merged_found[x]", "min_run_count": 2, "name": "cluster_hierarchy_disjoint_set.Bench.time_contains", "number": 0, "param_names": ["n"], "params": [["100", "1000", "10000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b35e5f755b032d3cb2a1cf191bdf1dc674ad043b89c743e962e9a4344dcd1e97", "warmup_time": -1}, "cluster_hierarchy_disjoint_set.Bench.time_find": {"code": "class Bench:\n    def time_find(self, n):\n        dis = self.pre_merged\n        return [dis[i] for i in self.nodes]\n\n    def setup(self, n):\n        # Create random edges\n        rng = np.random.RandomState(seed=0)\n        self.edges = rng.randint(0, 10 * n, (n, 2))\n        self.nodes = np.unique(self.edges)\n        self.disjoint_set = DisjointSet(self.nodes)\n    \n        self.pre_merged = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged.merge(a, b)\n    \n        self.pre_merged_found = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged_found.merge(a, b)\n        for x in self.nodes:\n            self.pre_merged_found[x]", "min_run_count": 2, "name": "cluster_hierarchy_disjoint_set.Bench.time_find", "number": 0, "param_names": ["n"], "params": [["100", "1000", "10000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0b7d50b7f5f03f920bd0a0c639e0f085567971793b0e01c04dd9d8b06cf8154f", "warmup_time": -1}, "cluster_hierarchy_disjoint_set.Bench.time_find_already_found": {"code": "class Bench:\n    def time_find_already_found(self, n):\n        dis = self.pre_merged_found\n        return [dis[i] for i in self.nodes]\n\n    def setup(self, n):\n        # Create random edges\n        rng = np.random.RandomState(seed=0)\n        self.edges = rng.randint(0, 10 * n, (n, 2))\n        self.nodes = np.unique(self.edges)\n        self.disjoint_set = DisjointSet(self.nodes)\n    \n        self.pre_merged = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged.merge(a, b)\n    \n        self.pre_merged_found = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged_found.merge(a, b)\n        for x in self.nodes:\n            self.pre_merged_found[x]", "min_run_count": 2, "name": "cluster_hierarchy_disjoint_set.Bench.time_find_already_found", "number": 0, "param_names": ["n"], "params": [["100", "1000", "10000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7cf68c47a2e5b1b2b5f778fbc00a35b5348a8fe044e78dad5e1da79805419a9c", "warmup_time": -1}, "cluster_hierarchy_disjoint_set.Bench.time_merge": {"code": "class Bench:\n    def time_merge(self, n):\n        dis = self.disjoint_set\n        for a, b in self.edges:\n            dis.merge(a, b)\n\n    def setup(self, n):\n        # Create random edges\n        rng = np.random.RandomState(seed=0)\n        self.edges = rng.randint(0, 10 * n, (n, 2))\n        self.nodes = np.unique(self.edges)\n        self.disjoint_set = DisjointSet(self.nodes)\n    \n        self.pre_merged = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged.merge(a, b)\n    \n        self.pre_merged_found = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged_found.merge(a, b)\n        for x in self.nodes:\n            self.pre_merged_found[x]", "min_run_count": 2, "name": "cluster_hierarchy_disjoint_set.Bench.time_merge", "number": 0, "param_names": ["n"], "params": [["100", "1000", "10000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e0a88a142f3aa2da399f7d2559aee279f0ff574d9093d4e9b4e761af634a263d", "warmup_time": -1}, "cluster_hierarchy_disjoint_set.Bench.time_merge_already_merged": {"code": "class Bench:\n    def time_merge_already_merged(self, n):\n        dis = self.pre_merged\n        for a, b in self.edges:\n            dis.merge(a, b)\n\n    def setup(self, n):\n        # Create random edges\n        rng = np.random.RandomState(seed=0)\n        self.edges = rng.randint(0, 10 * n, (n, 2))\n        self.nodes = np.unique(self.edges)\n        self.disjoint_set = DisjointSet(self.nodes)\n    \n        self.pre_merged = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged.merge(a, b)\n    \n        self.pre_merged_found = DisjointSet(self.nodes)\n        for a, b in self.edges:\n            self.pre_merged_found.merge(a, b)\n        for x in self.nodes:\n            self.pre_merged_found[x]", "min_run_count": 2, "name": "cluster_hierarchy_disjoint_set.Bench.time_merge_already_merged", "number": 0, "param_names": ["n"], "params": [["100", "1000", "10000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "da430f953ef308d98c79f6cdd545bb2f59f48de0317b62fcf43b35f8048d86f1", "warmup_time": -1}, "cython_special.CythonSpecial.time_airy_D": {"code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", "min_run_count": 2, "name": "cython_special.CythonSpecial.time_airy_D", "number": 0, "param_names": ["name", "argument", "N", "api"], "params": [["'airy_D'"], ["(1,)"], ["10", "100", "1000"], ["'python'", "'numpy'", "'cython'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a", "warmup_time": -1}, "cython_special.CythonSpecial.time_airy_d": {"code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", "min_run_count": 2, "name": "cython_special.CythonSpecial.time_airy_d", "number": 0, "param_names": ["name", "argument", "N", "api"], "params": [["'airy_d'"], ["(1,)"], ["10", "100", "1000"], ["'python'", "'numpy'", "'cython'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a", "warmup_time": -1}, "cython_special.CythonSpecial.time_beta_dd": {"code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", "min_run_count": 2, "name": "cython_special.CythonSpecial.time_beta_dd", "number": 0, "param_names": ["name", "argument", "N", "api"], "params": [["'beta_dd'"], ["(0.25, 0.75)"], ["10", "100", "1000"], ["'python'", "'numpy'", "'cython'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a", "warmup_time": -1}, "cython_special.CythonSpecial.time_erf_D": {"code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", "min_run_count": 2, "name": "cython_special.CythonSpecial.time_erf_D", "number": 0, "param_names": ["name", "argument", "N", "api"], "params": [["'erf_D'"], ["((1+1j),)"], ["10", "100", "1000"], ["'python'", "'numpy'", "'cython'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a", "warmup_time": -1}, "cython_special.CythonSpecial.time_erf_d": {"code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", "min_run_count": 2, "name": "cython_special.CythonSpecial.time_erf_d", "number": 0, "param_names": ["name", "argument", "N", "api"], "params": [["'erf_d'"], ["(1,)"], ["10", "100", "1000"], ["'python'", "'numpy'", "'cython'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a", "warmup_time": -1}, "cython_special.CythonSpecial.time_exprel_d": {"code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", "min_run_count": 2, "name": "cython_special.CythonSpecial.time_exprel_d", "number": 0, "param_names": ["name", "argument", "N", "api"], "params": [["'exprel_d'"], ["(1e-06,)"], ["10", "100", "1000"], ["'python'", "'numpy'", "'cython'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a", "warmup_time": -1}, "cython_special.CythonSpecial.time_gamma_D": {"code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", "min_run_count": 2, "name": "cython_special.CythonSpecial.time_gamma_D", "number": 0, "param_names": ["name", "argument", "N", "api"], "params": [["'gamma_D'"], ["((100+100j),)"], ["10", "100", "1000"], ["'python'", "'numpy'", "'cython'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a", "warmup_time": -1}, "cython_special.CythonSpecial.time_gamma_d": {"code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", "min_run_count": 2, "name": "cython_special.CythonSpecial.time_gamma_d", "number": 0, "param_names": ["name", "argument", "N", "api"], "params": [["'gamma_d'"], ["(100,)"], ["10", "100", "1000"], ["'python'", "'numpy'", "'cython'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a", "warmup_time": -1}, "cython_special.CythonSpecial.time_jv_dD": {"code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", "min_run_count": 2, "name": "cython_special.CythonSpecial.time_jv_dD", "number": 0, "param_names": ["name", "argument", "N", "api"], "params": [["'jv_dD'"], ["(1, (1+1j))"], ["10", "100", "1000"], ["'python'", "'numpy'", "'cython'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a", "warmup_time": -1}, "cython_special.CythonSpecial.time_jv_dd": {"code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", "min_run_count": 2, "name": "cython_special.CythonSpecial.time_jv_dd", "number": 0, "param_names": ["name", "argument", "N", "api"], "params": [["'jv_dd'"], ["(1, 1)"], ["10", "100", "1000"], ["'python'", "'numpy'", "'cython'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a", "warmup_time": -1}, "cython_special.CythonSpecial.time_loggamma_D": {"code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", "min_run_count": 2, "name": "cython_special.CythonSpecial.time_loggamma_D", "number": 0, "param_names": ["name", "argument", "N", "api"], "params": [["'loggamma_D'"], ["(20,)"], ["10", "100", "1000"], ["'python'", "'numpy'", "'cython'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a", "warmup_time": -1}, "cython_special.CythonSpecial.time_logit_d": {"code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", "min_run_count": 2, "name": "cython_special.CythonSpecial.time_logit_d", "number": 0, "param_names": ["name", "argument", "N", "api"], "params": [["'logit_d'"], ["(0.5,)"], ["10", "100", "1000"], ["'python'", "'numpy'", "'cython'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a", "warmup_time": -1}, "cython_special.CythonSpecial.time_psi_D": {"code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", "min_run_count": 2, "name": "cython_special.CythonSpecial.time_psi_D", "number": 0, "param_names": ["name", "argument", "N", "api"], "params": [["'psi_D'"], ["(1,)"], ["10", "100", "1000"], ["'python'", "'numpy'", "'cython'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a", "warmup_time": -1}, "cython_special.CythonSpecial.time_psi_d": {"code": "class <locals>:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\nclass CythonSpecial:\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", "min_run_count": 2, "name": "cython_special.CythonSpecial.time_psi_d", "number": 0, "param_names": ["name", "argument", "N", "api"], "params": [["'psi_d'"], ["(1,)"], ["10", "100", "1000"], ["'python'", "'numpy'", "'cython'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8c1cfd71ba6a602b4b43483384f0eecc5cbbeedf640a714e8c0d6811e22f5d4a", "warmup_time": -1}, "fft_basic.Fft.time_fft": {"code": "class Fft:\n    def time_fft(self, size, cmplx, module):\n        self.fft(self.x)\n\n    def setup(self, size, cmplx, module):\n        if cmplx == 'cmplx':\n            self.x = random([size]).astype(cdouble)+random([size]).astype(cdouble)*1j\n        else:\n            self.x = random([size]).astype(double)\n    \n        module = get_module(module)\n        self.fft = getattr(module, 'fft')\n        self.ifft = getattr(module, 'ifft')", "min_run_count": 2, "name": "fft_basic.Fft.time_fft", "number": 0, "param_names": ["size", "type", "module"], "params": [["100", "256", "313", "512", "1000", "1024", "2048", "4096", "8192"], ["'real'", "'cmplx'"], ["'scipy.fftpack'", "'scipy.fft'", "'numpy.fft'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "43cb7e1c276afa37a216c3345642bc059de8fafd391c29d9ce2f34b0af1332f6", "warmup_time": -1}, "fft_basic.Fft.time_ifft": {"code": "class Fft:\n    def time_ifft(self, size, cmplx, module):\n        self.ifft(self.x)\n\n    def setup(self, size, cmplx, module):\n        if cmplx == 'cmplx':\n            self.x = random([size]).astype(cdouble)+random([size]).astype(cdouble)*1j\n        else:\n            self.x = random([size]).astype(double)\n    \n        module = get_module(module)\n        self.fft = getattr(module, 'fft')\n        self.ifft = getattr(module, 'ifft')", "min_run_count": 2, "name": "fft_basic.Fft.time_ifft", "number": 0, "param_names": ["size", "type", "module"], "params": [["100", "256", "313", "512", "1000", "1024", "2048", "4096", "8192"], ["'real'", "'cmplx'"], ["'scipy.fftpack'", "'scipy.fft'", "'numpy.fft'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6b3dba7555699a7fcf10bdb4931781eb9e1287ac48a696e92444f357d1205ff9", "warmup_time": -1}, "fft_basic.FftBackends.time_fft": {"code": "class FftBackends:\n    def time_fft(self, size, cmplx, module):\n        self.fft(self.x)\n\n    def setup(self, size, cmplx, backend):\n        import scipy.fft\n        if cmplx == 'cmplx':\n            self.x = random([size]).astype(cdouble)+random([size]).astype(cdouble)*1j\n        else:\n            self.x = random([size]).astype(double)\n    \n        self.fft = scipy.fft.fft\n        self.ifft = scipy.fft.ifft\n    \n        if backend == 'pocketfft':\n            scipy.fft.set_global_backend('scipy')\n        elif backend == 'pyfftw':\n            if not has_pyfftw:\n                raise NotImplementedError\n            scipy.fft.set_global_backend(PyfftwBackend)\n        elif backend == 'numpy':\n            from scipy.fft._debug_backends import NumPyBackend\n            scipy.fft.set_global_backend(NumPyBackend)\n        elif backend == 'direct':\n            import scipy.fft._pocketfft\n            self.fft = scipy.fft._pocketfft.fft\n            self.ifft = scipy.fft._pocketfft.ifft", "min_run_count": 2, "name": "fft_basic.FftBackends.time_fft", "number": 0, "param_names": ["size", "type", "backend"], "params": [["100", "256", "313", "512", "1000", "1024", "2048", "4096", "8192"], ["'real'", "'cmplx'"], ["'pocketfft'", "'pyfftw'", "'numpy'", "'direct'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "fa985c0626675fcf7e506c6ba5ba852eb496adffc8ea0d6c70930b032eb10f20", "warmup_time": -1}, "fft_basic.FftBackends.time_ifft": {"code": "class FftBackends:\n    def time_ifft(self, size, cmplx, module):\n        self.ifft(self.x)\n\n    def setup(self, size, cmplx, backend):\n        import scipy.fft\n        if cmplx == 'cmplx':\n            self.x = random([size]).astype(cdouble)+random([size]).astype(cdouble)*1j\n        else:\n            self.x = random([size]).astype(double)\n    \n        self.fft = scipy.fft.fft\n        self.ifft = scipy.fft.ifft\n    \n        if backend == 'pocketfft':\n            scipy.fft.set_global_backend('scipy')\n        elif backend == 'pyfftw':\n            if not has_pyfftw:\n                raise NotImplementedError\n            scipy.fft.set_global_backend(PyfftwBackend)\n        elif backend == 'numpy':\n            from scipy.fft._debug_backends import NumPyBackend\n            scipy.fft.set_global_backend(NumPyBackend)\n        elif backend == 'direct':\n            import scipy.fft._pocketfft\n            self.fft = scipy.fft._pocketfft.fft\n            self.ifft = scipy.fft._pocketfft.ifft", "min_run_count": 2, "name": "fft_basic.FftBackends.time_ifft", "number": 0, "param_names": ["size", "type", "backend"], "params": [["100", "256", "313", "512", "1000", "1024", "2048", "4096", "8192"], ["'real'", "'cmplx'"], ["'pocketfft'", "'pyfftw'", "'numpy'", "'direct'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4b34c6676e64ef332e08a23bd92f95efa2d2ef52fc44daa807082886eef87762", "warmup_time": -1}, "fft_basic.FftThreading.time_fft": {"code": "class FftThreading:\n    def time_fft(self, size, num_transforms, method):\n        if method == 'threading':\n            self.map_thread(scipy_fft.fft)\n        else:\n            for x in self.xs:\n                scipy_fft.fft(x, workers=-1)\n\n    def setup(self, size, num_transforms, method):\n        if not has_scipy_fft:\n            raise NotImplementedError\n    \n        size = list(map(int, size.split(\"x\")))\n        self.xs = [(random(size)+1j*random(size)).astype(np.complex128)\n                   for _ in range(num_transforms)]\n    \n        if method == 'threading':\n            self.pool = futures.ThreadPoolExecutor(os.cpu_count())", "min_run_count": 2, "name": "fft_basic.FftThreading.time_fft", "number": 0, "param_names": ["size", "num_transforms", "method"], "params": [["'100x100'", "'1000x100'", "'256x256'", "'512x512'"], ["1", "8", "32", "100"], ["'workers'", "'threading'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "01c8d4ac7176096dd9169b1dccba311314ba689f6994d8c2aca0b8875797185e", "warmup_time": -1}, "fft_basic.FftThreading.time_fftn": {"code": "class FftThreading:\n    def time_fftn(self, size, num_transforms, method):\n        if method == 'threading':\n            self.map_thread(scipy_fft.fftn)\n        else:\n            for x in self.xs:\n                scipy_fft.fftn(x, workers=-1)\n\n    def setup(self, size, num_transforms, method):\n        if not has_scipy_fft:\n            raise NotImplementedError\n    \n        size = list(map(int, size.split(\"x\")))\n        self.xs = [(random(size)+1j*random(size)).astype(np.complex128)\n                   for _ in range(num_transforms)]\n    \n        if method == 'threading':\n            self.pool = futures.ThreadPoolExecutor(os.cpu_count())", "min_run_count": 2, "name": "fft_basic.FftThreading.time_fftn", "number": 0, "param_names": ["size", "num_transforms", "method"], "params": [["'100x100'", "'1000x100'", "'256x256'", "'512x512'"], ["1", "8", "32", "100"], ["'workers'", "'threading'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5776b5cd181dfaec02e289c6719a8854727ad9c851142440c3a2935d97b5b50c", "warmup_time": -1}, "fft_basic.Fftn.time_fftn": {"code": "class Fftn:\n    def time_fftn(self, size, cmplx, module):\n        self.fftn(self.x)\n\n    def setup(self, size, cmplx, module):\n        size = list(map(int, size.split(\"x\")))\n    \n        if cmplx != 'cmplx':\n            self.x = random(size).astype(double)\n        else:\n            self.x = random(size).astype(cdouble)+random(size).astype(cdouble)*1j\n    \n        self.fftn = getattr(get_module(module), 'fftn')", "min_run_count": 2, "name": "fft_basic.Fftn.time_fftn", "number": 0, "param_names": ["size", "type", "module"], "params": [["'100x100'", "'313x100'", "'1000x100'", "'256x256'", "'512x512'"], ["'real'", "'cmplx'"], ["'scipy.fftpack'", "'scipy.fft'", "'numpy.fft'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "46c3c6117d2afa7ff988d4b2a228967a6311e8a9240d1d4421b4c4676f1dedda", "warmup_time": -1}, "fft_basic.FftnBackends.time_fft": {"code": "class FftnBackends:\n    def time_fft(self, size, cmplx, module):\n        self.fftn(self.x)\n\n    def setup(self, size, cmplx, backend):\n        import scipy.fft\n        size = list(map(int, size.split(\"x\")))\n    \n        if cmplx == 'cmplx':\n            self.x = random(size).astype(double)+random(size).astype(double)*1j\n        else:\n            self.x = random(size).astype(double)\n    \n        self.fftn = scipy.fft.fftn\n        self.ifftn = scipy.fft.ifftn\n    \n        if backend == 'pocketfft':\n            scipy.fft.set_global_backend('scipy')\n        elif backend == 'pyfftw':\n            if not has_pyfftw:\n                raise NotImplementedError\n            scipy.fft.set_global_backend(PyfftwBackend)\n        elif backend == 'numpy':\n            from scipy.fft._debug_backends import NumPyBackend\n            scipy.fft.set_global_backend(NumPyBackend)\n        elif backend == 'direct':\n            import scipy.fft._pocketfft\n            self.fftn = scipy.fft._pocketfft.fftn\n            self.ifftn = scipy.fft._pocketfft.ifftn", "min_run_count": 2, "name": "fft_basic.FftnBackends.time_fft", "number": 0, "param_names": ["size", "type", "backend"], "params": [["'100x100'", "'313x100'", "'1000x100'", "'256x256'", "'512x512'"], ["'real'", "'cmplx'"], ["'pocketfft'", "'pyfftw'", "'numpy'", "'direct'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9210ea7955292189368628dd908c18ac7c03d1c51e0dc4385830514319fbd98e", "warmup_time": -1}, "fft_basic.FftnBackends.time_ifft": {"code": "class FftnBackends:\n    def time_ifft(self, size, cmplx, module):\n        self.ifftn(self.x)\n\n    def setup(self, size, cmplx, backend):\n        import scipy.fft\n        size = list(map(int, size.split(\"x\")))\n    \n        if cmplx == 'cmplx':\n            self.x = random(size).astype(double)+random(size).astype(double)*1j\n        else:\n            self.x = random(size).astype(double)\n    \n        self.fftn = scipy.fft.fftn\n        self.ifftn = scipy.fft.ifftn\n    \n        if backend == 'pocketfft':\n            scipy.fft.set_global_backend('scipy')\n        elif backend == 'pyfftw':\n            if not has_pyfftw:\n                raise NotImplementedError\n            scipy.fft.set_global_backend(PyfftwBackend)\n        elif backend == 'numpy':\n            from scipy.fft._debug_backends import NumPyBackend\n            scipy.fft.set_global_backend(NumPyBackend)\n        elif backend == 'direct':\n            import scipy.fft._pocketfft\n            self.fftn = scipy.fft._pocketfft.fftn\n            self.ifftn = scipy.fft._pocketfft.ifftn", "min_run_count": 2, "name": "fft_basic.FftnBackends.time_ifft", "number": 0, "param_names": ["size", "type", "backend"], "params": [["'100x100'", "'313x100'", "'1000x100'", "'256x256'", "'512x512'"], ["'real'", "'cmplx'"], ["'pocketfft'", "'pyfftw'", "'numpy'", "'direct'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b24b074608dd3bbe10b7dd28d42a003392711954883f8f5ab7a770653a5f252e", "warmup_time": -1}, "fft_basic.NextFastLen.time_next_fast_len": {"code": "class NextFastLen:\n    def time_next_fast_len(self, size):\n        scipy_fft.next_fast_len.__wrapped__(size)\n\n    def setup(self, size):\n        if not has_scipy_fft:\n            raise NotImplementedError", "min_run_count": 2, "name": "fft_basic.NextFastLen.time_next_fast_len", "number": 0, "param_names": ["size"], "params": [["12", "13", "1021", "1024", "16381", "16384", "262139", "262144", "999983", "1048576"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "67af4eb88556ff515fed9299578487d0a1b461fa77f61813319ecd11aba1d4cd", "warmup_time": -1}, "fft_basic.NextFastLen.time_next_fast_len_cached": {"code": "class NextFastLen:\n    def time_next_fast_len_cached(self, size):\n        scipy_fft.next_fast_len(size)\n\n    def setup(self, size):\n        if not has_scipy_fft:\n            raise NotImplementedError", "min_run_count": 2, "name": "fft_basic.NextFastLen.time_next_fast_len_cached", "number": 0, "param_names": ["size"], "params": [["12", "13", "1021", "1024", "16381", "16384", "262139", "262144", "999983", "1048576"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ce847bc3ab55322c9e7a0c167a71a368e987e504a4cfc9a7f5489e51e9ce45cf", "warmup_time": -1}, "fft_basic.RFft.time_irfft": {"code": "class RFft:\n    def time_irfft(self, size, module):\n        self.irfft(self.y)\n\n    def setup(self, size, module):\n        self.x = random([size]).astype(double)\n    \n        module = get_module(module)\n        self.rfft = getattr(module, 'rfft')\n        self.irfft = getattr(module, 'irfft')\n    \n        self.y = self.rfft(self.x)", "min_run_count": 2, "name": "fft_basic.RFft.time_irfft", "number": 0, "param_names": ["size", "module"], "params": [["100", "256", "313", "512", "1000", "1024", "2048", "4096", "8192"], ["'scipy.fftpack'", "'scipy.fft'", "'numpy.fft'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b29b8d884549ae838535aa610c255789236a95b97f0c33189871a8063f697fde", "warmup_time": -1}, "fft_basic.RFft.time_rfft": {"code": "class RFft:\n    def time_rfft(self, size, module):\n        self.rfft(self.x)\n\n    def setup(self, size, module):\n        self.x = random([size]).astype(double)\n    \n        module = get_module(module)\n        self.rfft = getattr(module, 'rfft')\n        self.irfft = getattr(module, 'irfft')\n    \n        self.y = self.rfft(self.x)", "min_run_count": 2, "name": "fft_basic.RFft.time_rfft", "number": 0, "param_names": ["size", "module"], "params": [["100", "256", "313", "512", "1000", "1024", "2048", "4096", "8192"], ["'scipy.fftpack'", "'scipy.fft'", "'numpy.fft'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "addbbfc97a7f43a5b3d08b5f48fc1fbfeaa0bbfb7d29833234666c1add1279a3", "warmup_time": -1}, "fft_basic.RealTransforms1D.time_dct": {"code": "class RealTransforms1D:\n    def time_dct(self, size, type, module):\n        self.dct(self.x, self.type)\n\n    def setup(self, size, type, module):\n        module = get_module(module)\n        self.dct = getattr(module, 'dct')\n        self.dst = getattr(module, 'dst')\n        self.type = {'I':1, 'II':2, 'III':3, 'IV':4}[type]\n    \n        # The \"logical\" transform size should be smooth, which for dct/dst\n        # type 1 is offset by -1/+1 respectively\n    \n        if self.type == 1:\n            size += 1\n    \n        self.x = random([size]).astype(double)\n    \n        if self.type == 1:\n            self.x_dst = self.x[:-2].copy()", "min_run_count": 2, "name": "fft_basic.RealTransforms1D.time_dct", "number": 0, "param_names": ["size", "type", "module"], "params": [["75", "100", "135", "256", "313", "512", "675", "1024", "2025", "2048"], ["'I'", "'II'", "'III'", "'IV'"], ["'scipy.fftpack'", "'scipy.fft'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e3497bca3bb059fd894674a9e02f6fe8bdd409e765011df69339b96bc5079627", "warmup_time": -1}, "fft_basic.RealTransforms1D.time_dst": {"code": "class RealTransforms1D:\n    def time_dst(self, size, type, module):\n        x = self.x if self.type != 1 else self.x_dst\n        self.dst(x, self.type)\n\n    def setup(self, size, type, module):\n        module = get_module(module)\n        self.dct = getattr(module, 'dct')\n        self.dst = getattr(module, 'dst')\n        self.type = {'I':1, 'II':2, 'III':3, 'IV':4}[type]\n    \n        # The \"logical\" transform size should be smooth, which for dct/dst\n        # type 1 is offset by -1/+1 respectively\n    \n        if self.type == 1:\n            size += 1\n    \n        self.x = random([size]).astype(double)\n    \n        if self.type == 1:\n            self.x_dst = self.x[:-2].copy()", "min_run_count": 2, "name": "fft_basic.RealTransforms1D.time_dst", "number": 0, "param_names": ["size", "type", "module"], "params": [["75", "100", "135", "256", "313", "512", "675", "1024", "2025", "2048"], ["'I'", "'II'", "'III'", "'IV'"], ["'scipy.fftpack'", "'scipy.fft'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ad275b349d0c19daf585e2327fbaf421b498839a302391bb20a64ba5491ade91", "warmup_time": -1}, "fft_basic.RealTransformsND.time_dctn": {"code": "class RealTransformsND:\n    def time_dctn(self, size, type, module):\n        self.dctn(self.x, self.type)\n\n    def setup(self, size, type, module):\n        self.dctn = getattr(get_module(module), 'dctn')\n        self.dstn = getattr(get_module(module), 'dstn')\n        self.type = {'I':1, 'II':2, 'III':3, 'IV':4}[type]\n    \n        # The \"logical\" transform size should be smooth, which for dct/dst\n        # type 1 is offset by -1/+1 respectively\n    \n        size = list(map(int, size.split('x')))\n        if self.type == 1:\n            size = (s + 1 for s in size)\n    \n        self.x = random(size).astype(double)\n        if self.type == 1:\n            self.x_dst = self.x[:-2,:-2].copy()", "min_run_count": 2, "name": "fft_basic.RealTransformsND.time_dctn", "number": 0, "param_names": ["size", "type", "module"], "params": [["'75x75'", "'100x100'", "'135x135'", "'313x363'", "'1000x100'", "'256x256'"], ["'I'", "'II'", "'III'", "'IV'"], ["'scipy.fftpack'", "'scipy.fft'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7ccc290bcc48df1765899eeebf91721e5ac2b3098c5caf5e11381d29ad90c55f", "warmup_time": -1}, "fft_basic.RealTransformsND.time_dstn": {"code": "class RealTransformsND:\n    def time_dstn(self, size, type, module):\n        x = self.x if self.type != 1 else self.x_dst\n        self.dstn(x, self.type)\n\n    def setup(self, size, type, module):\n        self.dctn = getattr(get_module(module), 'dctn')\n        self.dstn = getattr(get_module(module), 'dstn')\n        self.type = {'I':1, 'II':2, 'III':3, 'IV':4}[type]\n    \n        # The \"logical\" transform size should be smooth, which for dct/dst\n        # type 1 is offset by -1/+1 respectively\n    \n        size = list(map(int, size.split('x')))\n        if self.type == 1:\n            size = (s + 1 for s in size)\n    \n        self.x = random(size).astype(double)\n        if self.type == 1:\n            self.x_dst = self.x[:-2,:-2].copy()", "min_run_count": 2, "name": "fft_basic.RealTransformsND.time_dstn", "number": 0, "param_names": ["size", "type", "module"], "params": [["'75x75'", "'100x100'", "'135x135'", "'313x363'", "'1000x100'", "'256x256'"], ["'I'", "'II'", "'III'", "'IV'"], ["'scipy.fftpack'", "'scipy.fft'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0b77ec9d87bc2e7d48b9f235ad180970366b029e160f798bd56e6835a8ab3624", "warmup_time": -1}, "fftpack_pseudo_diffs.Bench.time_diff": {"code": "class Bench:\n    def time_diff(self, size, soltype):\n        if soltype == 'fft':\n            diff(self.f, 3)\n        else:\n            direct_diff(self.f, 3)\n\n    def setup(self, size, type):\n        size = int(size)\n    \n        x = arange(size)*2*pi/size\n        a = 1\n        self.a = a\n        if size < 2000:\n            self.f = sin(x)*cos(4*x)+exp(sin(3*x))\n            self.sf = sin(x+a)*cos(4*(x+a))+exp(sin(3*(x+a)))\n        else:\n            self.f = sin(x)*cos(4*x)\n            self.sf = sin(x+a)*cos(4*(x+a))", "min_run_count": 2, "name": "fftpack_pseudo_diffs.Bench.time_diff", "number": 0, "param_names": ["size", "type"], "params": [["100", "256", "512", "1000", "1024", "2048", "4096", "8192"], ["'fft'", "'direct'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ecbb51be15a54011afaf7419e4de58bf02949a7abc534276a2a18849eef9985d", "warmup_time": -1}, "fftpack_pseudo_diffs.Bench.time_hilbert": {"code": "class Bench:\n    def time_hilbert(self, size, soltype):\n        if soltype == 'fft':\n            hilbert(self.f)\n        else:\n            direct_hilbert(self.f)\n\n    def setup(self, size, type):\n        size = int(size)\n    \n        x = arange(size)*2*pi/size\n        a = 1\n        self.a = a\n        if size < 2000:\n            self.f = sin(x)*cos(4*x)+exp(sin(3*x))\n            self.sf = sin(x+a)*cos(4*(x+a))+exp(sin(3*(x+a)))\n        else:\n            self.f = sin(x)*cos(4*x)\n            self.sf = sin(x+a)*cos(4*(x+a))", "min_run_count": 2, "name": "fftpack_pseudo_diffs.Bench.time_hilbert", "number": 0, "param_names": ["size", "type"], "params": [["100", "256", "512", "1000", "1024", "2048", "4096", "8192"], ["'fft'", "'direct'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8b3864453f4e979dcd4238fbebaaa50967556fc1ad60bcd23efb503a899b40d5", "warmup_time": -1}, "fftpack_pseudo_diffs.Bench.time_shift": {"code": "class Bench:\n    def time_shift(self, size, soltype):\n        if soltype == 'fft':\n            shift(self.f, self.a)\n        else:\n            direct_shift(self.f, self.a)\n\n    def setup(self, size, type):\n        size = int(size)\n    \n        x = arange(size)*2*pi/size\n        a = 1\n        self.a = a\n        if size < 2000:\n            self.f = sin(x)*cos(4*x)+exp(sin(3*x))\n            self.sf = sin(x+a)*cos(4*(x+a))+exp(sin(3*(x+a)))\n        else:\n            self.f = sin(x)*cos(4*x)\n            self.sf = sin(x+a)*cos(4*(x+a))", "min_run_count": 2, "name": "fftpack_pseudo_diffs.Bench.time_shift", "number": 0, "param_names": ["size", "type"], "params": [["100", "256", "512", "1000", "1024", "2048", "4096", "8192"], ["'fft'", "'direct'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4af1e866705c2b2da21bb261c884019e967221fc2e7a27937a0fa09e012bb221", "warmup_time": -1}, "fftpack_pseudo_diffs.Bench.time_tilbert": {"code": "class Bench:\n    def time_tilbert(self, size, soltype):\n        if soltype == 'fft':\n            tilbert(self.f, 1)\n        else:\n            direct_tilbert(self.f, 1)\n\n    def setup(self, size, type):\n        size = int(size)\n    \n        x = arange(size)*2*pi/size\n        a = 1\n        self.a = a\n        if size < 2000:\n            self.f = sin(x)*cos(4*x)+exp(sin(3*x))\n            self.sf = sin(x+a)*cos(4*(x+a))+exp(sin(3*(x+a)))\n        else:\n            self.f = sin(x)*cos(4*x)\n            self.sf = sin(x+a)*cos(4*(x+a))", "min_run_count": 2, "name": "fftpack_pseudo_diffs.Bench.time_tilbert", "number": 0, "param_names": ["size", "type"], "params": [["100", "256", "512", "1000", "1024", "2048", "4096", "8192"], ["'fft'", "'direct'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9c700f861e3acd4a87c8e6abbd4fc60967a0ab446c25ea480db726774354ffa4", "warmup_time": -1}, "integrate.Quad.time_quad_cffi": {"code": "class Quad:\n    def time_quad_cffi(self):\n        quad(self.f_cffi, 0, np.pi)\n\n    def setup(self):\n        from math import sin\n    \n        self.f_python = lambda x: sin(x)\n        self.f_cython = from_cython(_ccallback_c, \"sine\")\n    \n        try:\n            from scipy.integrate.tests.test_quadpack import get_clib_test_routine\n            self.f_ctypes = get_clib_test_routine('_multivariate_sin', ctypes.c_double,\n                                                  ctypes.c_int, ctypes.c_double)\n        except ImportError:\n            lib = ctypes.CDLL(clib_test.__file__)\n            self.f_ctypes = lib._multivariate_sin\n            self.f_ctypes.restype = ctypes.c_double\n            self.f_ctypes.argtypes = (ctypes.c_int, ctypes.c_double)\n    \n        if cffi is not None:\n            voidp = ctypes.cast(self.f_ctypes, ctypes.c_void_p)\n            address = voidp.value\n            ffi = cffi.FFI()\n            self.f_cffi = LowLevelCallable(ffi.cast(\"double (*)(int, double *)\", address))", "min_run_count": 2, "name": "integrate.Quad.time_quad_cffi", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "47cc43352473cb8f1672bd55e600d8f6c35e86f47588ed3f313de0bc21837b42", "warmup_time": -1}, "integrate.Quad.time_quad_ctypes": {"code": "class Quad:\n    def time_quad_ctypes(self):\n        quad(self.f_ctypes, 0, np.pi)\n\n    def setup(self):\n        from math import sin\n    \n        self.f_python = lambda x: sin(x)\n        self.f_cython = from_cython(_ccallback_c, \"sine\")\n    \n        try:\n            from scipy.integrate.tests.test_quadpack import get_clib_test_routine\n            self.f_ctypes = get_clib_test_routine('_multivariate_sin', ctypes.c_double,\n                                                  ctypes.c_int, ctypes.c_double)\n        except ImportError:\n            lib = ctypes.CDLL(clib_test.__file__)\n            self.f_ctypes = lib._multivariate_sin\n            self.f_ctypes.restype = ctypes.c_double\n            self.f_ctypes.argtypes = (ctypes.c_int, ctypes.c_double)\n    \n        if cffi is not None:\n            voidp = ctypes.cast(self.f_ctypes, ctypes.c_void_p)\n            address = voidp.value\n            ffi = cffi.FFI()\n            self.f_cffi = LowLevelCallable(ffi.cast(\"double (*)(int, double *)\", address))", "min_run_count": 2, "name": "integrate.Quad.time_quad_ctypes", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "70cf2fdf9febf32a4e1c220cdba552e3ea5a0dbc48265a355956071d97a30d30", "warmup_time": -1}, "integrate.Quad.time_quad_cython": {"code": "class Quad:\n    def time_quad_cython(self):\n        quad(self.f_cython, 0, np.pi)\n\n    def setup(self):\n        from math import sin\n    \n        self.f_python = lambda x: sin(x)\n        self.f_cython = from_cython(_ccallback_c, \"sine\")\n    \n        try:\n            from scipy.integrate.tests.test_quadpack import get_clib_test_routine\n            self.f_ctypes = get_clib_test_routine('_multivariate_sin', ctypes.c_double,\n                                                  ctypes.c_int, ctypes.c_double)\n        except ImportError:\n            lib = ctypes.CDLL(clib_test.__file__)\n            self.f_ctypes = lib._multivariate_sin\n            self.f_ctypes.restype = ctypes.c_double\n            self.f_ctypes.argtypes = (ctypes.c_int, ctypes.c_double)\n    \n        if cffi is not None:\n            voidp = ctypes.cast(self.f_ctypes, ctypes.c_void_p)\n            address = voidp.value\n            ffi = cffi.FFI()\n            self.f_cffi = LowLevelCallable(ffi.cast(\"double (*)(int, double *)\", address))", "min_run_count": 2, "name": "integrate.Quad.time_quad_cython", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e2edfcdcee583057b5ed3b0457a0651204b56555482f883a4172c2a348c82ff6", "warmup_time": -1}, "integrate.Quad.time_quad_python": {"code": "class Quad:\n    def time_quad_python(self):\n        quad(self.f_python, 0, np.pi)\n\n    def setup(self):\n        from math import sin\n    \n        self.f_python = lambda x: sin(x)\n        self.f_cython = from_cython(_ccallback_c, \"sine\")\n    \n        try:\n            from scipy.integrate.tests.test_quadpack import get_clib_test_routine\n            self.f_ctypes = get_clib_test_routine('_multivariate_sin', ctypes.c_double,\n                                                  ctypes.c_int, ctypes.c_double)\n        except ImportError:\n            lib = ctypes.CDLL(clib_test.__file__)\n            self.f_ctypes = lib._multivariate_sin\n            self.f_ctypes.restype = ctypes.c_double\n            self.f_ctypes.argtypes = (ctypes.c_int, ctypes.c_double)\n    \n        if cffi is not None:\n            voidp = ctypes.cast(self.f_ctypes, ctypes.c_void_p)\n            address = voidp.value\n            ffi = cffi.FFI()\n            self.f_cffi = LowLevelCallable(ffi.cast(\"double (*)(int, double *)\", address))", "min_run_count": 2, "name": "integrate.Quad.time_quad_python", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4acf496a93c06b7898de52abd5077f1ad3e3fcf93a1b0477889e660b34515417", "warmup_time": -1}, "integrate.SolveBVP.time_flow": {"code": "class SolveBVP:\n    def time_flow(self):\n        x = np.linspace(0, 1, 10)\n        y = np.ones((7, x.size))\n        solve_bvp(self.fun_flow, self.bc_flow, x, y, p=[1], tol=self.TOL)", "min_run_count": 2, "name": "integrate.SolveBVP.time_flow", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "293d0d48d7da84b9911e7dc04cf3e31bdb1a4397e68597d8833cd1e39757f2b0", "warmup_time": -1}, "integrate.SolveBVP.time_gas": {"code": "class SolveBVP:\n    def time_gas(self):\n        x = np.linspace(0, 3, 5)\n        y = np.empty((2, x.size))\n        y[0] = 0.5\n        y[1] = -0.5\n        solve_bvp(self.fun_gas, self.bc_gas, x, y, tol=self.TOL)", "min_run_count": 2, "name": "integrate.SolveBVP.time_gas", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "62ed65f56095bdfe5e0cb9b1ed557471ee4156fd3ce8778282a49bc79625b19c", "warmup_time": -1}, "integrate.SolveBVP.time_peak": {"code": "class SolveBVP:\n    def time_peak(self):\n        x = np.linspace(-1, 1, 5)\n        y = np.zeros((2, x.size))\n        solve_bvp(self.fun_peak, self.bc_peak, x, y, tol=self.TOL)", "min_run_count": 2, "name": "integrate.SolveBVP.time_peak", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b4c8fe896d280ca8d3be45f4f837d03ef487b935598f20e10e080f9ca6c20c1c", "warmup_time": -1}, "interpolate.BenchPPoly.time_evaluation": {"code": "class BenchPPoly:\n    def time_evaluation(self):\n        self.pp(self.xp)\n\n    def setup(self):\n        rng = np.random.default_rng(1234)\n        m, k = 55, 3\n        x = np.sort(rng.random(m+1))\n        c = rng.random((k, m))\n        self.pp = interpolate.PPoly(c, x)\n    \n        npts = 100\n        self.xp = np.linspace(0, 1, npts)", "min_run_count": 2, "name": "interpolate.BenchPPoly.time_evaluation", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9c97ad8eb89793df6d942e57466574de767d644e4ace3c597033b6a88a2813a5", "warmup_time": -1}, "interpolate.BivariateSpline.time_lsq_bivariate_spline": {"code": "class BivariateSpline:\n    def time_lsq_bivariate_spline(self, n_samples):\n        interpolate.LSQBivariateSpline(self.x, self.y, self.z, self.xknots.flat, self.yknots.flat)\n\n    def setup(self, n_samples):\n        x = np.arange(0, n_samples, 0.5)\n        y = np.arange(0, n_samples, 0.5)\n        x, y = np.meshgrid(x, y)\n        x = x.ravel()\n        y = y.ravel()\n        xmin = x.min()-1\n        xmax = x.max()+1\n        ymin = y.min()-1\n        ymax = y.max()+1\n        s = 1.1\n        self.yknots = np.linspace(ymin+s, ymax-s, 10)\n        self.xknots = np.linspace(xmin+s, xmax-s, 10)\n        self.z = np.sin(x) + 0.1*np.random.normal(size=x.shape)\n        self.x = x\n        self.y = y", "min_run_count": 2, "name": "interpolate.BivariateSpline.time_lsq_bivariate_spline", "number": 0, "param_names": ["n_samples"], "params": [["10", "20", "30"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "26edc79385876a35063595d97558e84b15b2853afa424174781e5b6519cf0c15", "warmup_time": -1}, "interpolate.BivariateSpline.time_smooth_bivariate_spline": {"code": "class BivariateSpline:\n    def time_smooth_bivariate_spline(self, n_samples):\n        interpolate.SmoothBivariateSpline(self.x, self.y, self.z)\n\n    def setup(self, n_samples):\n        x = np.arange(0, n_samples, 0.5)\n        y = np.arange(0, n_samples, 0.5)\n        x, y = np.meshgrid(x, y)\n        x = x.ravel()\n        y = y.ravel()\n        xmin = x.min()-1\n        xmax = x.max()+1\n        ymin = y.min()-1\n        ymax = y.max()+1\n        s = 1.1\n        self.yknots = np.linspace(ymin+s, ymax-s, 10)\n        self.xknots = np.linspace(xmin+s, xmax-s, 10)\n        self.z = np.sin(x) + 0.1*np.random.normal(size=x.shape)\n        self.x = x\n        self.y = y", "min_run_count": 2, "name": "interpolate.BivariateSpline.time_smooth_bivariate_spline", "number": 0, "param_names": ["n_samples"], "params": [["10", "20", "30"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8875044efdaa5468cee675d6cbafc5eec34054c8cb8e3dcbdeb62354818ef8af", "warmup_time": -1}, "interpolate.GridData.time_evaluation": {"code": "class GridData:\n    def time_evaluation(self, n_grids, method):\n        interpolate.griddata(self.points, self.values, (self.grid_x, self.grid_y), method=method)\n\n    def setup(self, n_grids, method):\n        self.func = lambda x, y: x*(1-x)*np.cos(4*np.pi*x) * np.sin(4*np.pi*y**2)**2\n        self.grid_x, self.grid_y = np.mgrid[0:1:n_grids, 0:1:n_grids]\n        self.points = np.random.rand(1000, 2)\n        self.values = self.func(self.points[:, 0], self.points[:, 1])", "min_run_count": 2, "name": "interpolate.GridData.time_evaluation", "number": 0, "param_names": ["n_grids", "method"], "params": [["10j", "100j", "1000j"], ["'nearest'", "'linear'", "'cubic'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "923d16af64b5a3a7b7c90d693c0d51555c0b3434cb436920a0e400d9ec8ada02", "warmup_time": -1}, "interpolate.Interpolate.time_interpolate": {"code": "class Interpolate:\n    def time_interpolate(self, n_samples, module):\n        if module == 'scipy':\n            interpolate.interp1d(self.x, self.y, kind=\"linear\")\n        else:\n            np.interp(self.z, self.x, self.y)\n\n    def setup(self, n_samples, module):\n        self.x = np.arange(n_samples)\n        self.y = np.exp(-self.x/3.0)\n        self.z = np.random.normal(size=self.x.shape)", "min_run_count": 2, "name": "interpolate.Interpolate.time_interpolate", "number": 0, "param_names": ["n_samples", "module"], "params": [["10", "50", "100"], ["'numpy'", "'scipy'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c7f060979e3517fffcbf1a369ef545515a013076ac2c659ccdf1596a636cc394", "warmup_time": -1}, "interpolate.Interpolate1d.time_interpolate": {"code": "class Interpolate1d:\n    def time_interpolate(self, n_samples, method):\n        \"\"\"Time the construction overhead.\"\"\"\n        interpolate.interp1d(self.x, self.y, kind=method)\n\n    def setup(self, n_samples, method):\n        self.x = np.arange(n_samples)\n        self.y = np.exp(-self.x/3.0)\n        self.interpolator = interpolate.interp1d(self.x, self.y, kind=method)\n        self.xp = np.linspace(self.x[0], self.x[-1], 4*n_samples)", "min_run_count": 2, "name": "interpolate.Interpolate1d.time_interpolate", "number": 0, "param_names": ["n_samples", "method"], "params": [["10", "50", "100", "1000", "10000"], ["'linear'", "'nearest'", "'zero'", "'slinear'", "'quadratic'", "'cubic'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "53ba4880a25d7a65d8bec417088d2ca3afa8e6a6534ed1eb7cf8eefe94f495bd", "warmup_time": -1}, "interpolate.Interpolate1d.time_interpolate_eval": {"code": "class Interpolate1d:\n    def time_interpolate_eval(self, n_samples, method):\n        \"\"\"Time the evaluation.\"\"\"\n        self.interpolator(self.xp)\n\n    def setup(self, n_samples, method):\n        self.x = np.arange(n_samples)\n        self.y = np.exp(-self.x/3.0)\n        self.interpolator = interpolate.interp1d(self.x, self.y, kind=method)\n        self.xp = np.linspace(self.x[0], self.x[-1], 4*n_samples)", "min_run_count": 2, "name": "interpolate.Interpolate1d.time_interpolate_eval", "number": 0, "param_names": ["n_samples", "method"], "params": [["10", "50", "100", "1000", "10000"], ["'linear'", "'nearest'", "'zero'", "'slinear'", "'quadratic'", "'cubic'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3e0c45886b58b68e7ea23068e78aee4f40175e59b2d3ec290f376d1fae95809d", "warmup_time": -1}, "interpolate.Interpolate2d.time_interpolate": {"code": "class Interpolate2d:\n    def time_interpolate(self, n_samples, method):\n        interpolate.interp2d(self.x, self.y, self.z, kind=method)\n\n    def setup(self, n_samples, method):\n        r_samples = n_samples / 2.\n        self.x = np.arange(-r_samples, r_samples, 0.25)\n        self.y = np.arange(-r_samples, r_samples, 0.25)\n        self.xx, self.yy = np.meshgrid(self.x, self.y)\n        self.z = np.sin(self.xx**2+self.yy**2)", "min_run_count": 2, "name": "interpolate.Interpolate2d.time_interpolate", "number": 0, "param_names": ["n_samples", "method"], "params": [["10", "50", "100"], ["'linear'", "'cubic'", "'quintic'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "48934ebda129680d6805a76a05748186a57d213fc0f27db8782b2705c6d6c7ec", "warmup_time": -1}, "interpolate.Leaks.track_leaks": {"code": "class Leaks:\n    def track_leaks(self):\n        set_mem_rlimit()\n    \n        # Setup temp file, make it fit in memory\n        repeats = [2, 5, 10, 50, 200]\n        peak_mems = []\n    \n        for repeat in repeats:\n            code = \"\"\"\n            import numpy as np\n            from scipy.interpolate import griddata\n    \n            def func(x, y):\n                return x*(1-x)*np.cos(4*np.pi*x) * np.sin(4*np.pi*y**2)**2\n    \n            grid_x, grid_y = np.mgrid[0:1:100j, 0:1:200j]\n            points = np.random.rand(1000, 2)\n            values = func(points[:,0], points[:,1])\n    \n            for t in range(%(repeat)d):\n                for method in ['nearest', 'linear', 'cubic']:\n                    griddata(points, values, (grid_x, grid_y), method=method)\n    \n            \"\"\" % dict(repeat=repeat)\n    \n            _, peak_mem = run_monitored(code)\n            peak_mems.append(peak_mem)\n    \n        corr, p = spearmanr(repeats, peak_mems)\n        if p < 0.05:\n            print(\"*\"*79)\n            print(\"PROBABLE MEMORY LEAK\")\n            print(\"*\"*79)\n        else:\n            print(\"PROBABLY NO MEMORY LEAK\")\n    \n        return max(peak_mems) / min(peak_mems)", "name": "interpolate.Leaks.track_leaks", "param_names": [], "params": [], "timeout": 60.0, "type": "track", "unit": "relative increase with repeats", "version": "660364525468f5ec677c63e82cdf86d50c2f10a4ccbcc4f1f116be695f7c0f50"}, "interpolate.RBFInterpolator.time_rbf_interpolator": {"code": "class RBFInterpolator:\n    def time_rbf_interpolator(self, neighbors, n_samples, kernel):\n        interp = interpolate.RBFInterpolator(\n            self.y,\n            self.d,\n            neighbors=neighbors,\n            epsilon=5.0,\n            kernel=kernel\n            )\n        interp(self.x)\n\n    def setup(self, neighbors, n_samples, kernel):\n        rng = np.random.RandomState(0)\n        self.y = rng.uniform(-1, 1, (n_samples, 2))\n        self.x = rng.uniform(-1, 1, (n_samples, 2))\n        self.d = np.sum(self.y, axis=1)*np.exp(-6*np.sum(self.y**2, axis=1))", "min_run_count": 2, "name": "interpolate.RBFInterpolator.time_rbf_interpolator", "number": 0, "param_names": ["neighbors", "n_samples", "kernel"], "params": [["None", "50"], ["10", "100", "1000"], ["'linear'", "'thin_plate_spline'", "'cubic'", "'quintic'", "'multiquadric'", "'inverse_multiquadric'", "'inverse_quadratic'", "'gaussian'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "38fb481841ed6a6c5cf95709b9bde276a1e10773431c54e69599d3a4a9d8cd04", "warmup_time": -1}, "interpolate.Rbf.time_rbf_1d": {"code": "class Rbf:\n    def time_rbf_1d(self, n_samples, function):\n        interpolate.Rbf(self.x, self.y, function=function)\n\n    def setup(self, n_samples, function):\n        self.x = np.arange(n_samples)\n        self.y = np.sin(self.x)\n        r_samples = n_samples / 2.\n        self.X = np.arange(-r_samples, r_samples, 0.25)\n        self.Y = np.arange(-r_samples, r_samples, 0.25)\n        self.z = np.exp(-self.X**2-self.Y**2)", "min_run_count": 2, "name": "interpolate.Rbf.time_rbf_1d", "number": 0, "param_names": ["n_samples", "function"], "params": [["10", "50", "100"], ["'multiquadric'", "'inverse'", "'gaussian'", "'linear'", "'cubic'", "'quintic'", "'thin_plate'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "322c7df9c3945502018241a8354ba06d665f4724576975d7749676e435f50628", "warmup_time": -1}, "interpolate.Rbf.time_rbf_2d": {"code": "class Rbf:\n    def time_rbf_2d(self, n_samples, function):\n        interpolate.Rbf(self.X, self.Y, self.z, function=function)\n\n    def setup(self, n_samples, function):\n        self.x = np.arange(n_samples)\n        self.y = np.sin(self.x)\n        r_samples = n_samples / 2.\n        self.X = np.arange(-r_samples, r_samples, 0.25)\n        self.Y = np.arange(-r_samples, r_samples, 0.25)\n        self.z = np.exp(-self.X**2-self.Y**2)", "min_run_count": 2, "name": "interpolate.Rbf.time_rbf_2d", "number": 0, "param_names": ["n_samples", "function"], "params": [["10", "50", "100"], ["'multiquadric'", "'inverse'", "'gaussian'", "'linear'", "'cubic'", "'quintic'", "'thin_plate'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0836465665fd46106764a0b8e45f7701a551aadfc91900cba329fda573193f18", "warmup_time": -1}, "interpolate.UnivariateSpline.time_univariate_spline": {"code": "class UnivariateSpline:\n    def time_univariate_spline(self, n_samples, degree):\n        interpolate.UnivariateSpline(self.x, self.y, k=degree)\n\n    def setup(self, n_samples, degree):\n        r_samples = n_samples / 2.\n        self.x = np.arange(-r_samples, r_samples, 0.25)\n        self.y = np.exp(-self.x**2) + 0.1 * np.random.randn(*self.x.shape)", "min_run_count": 2, "name": "interpolate.UnivariateSpline.time_univariate_spline", "number": 0, "param_names": ["n_samples", "degree"], "params": [["10", "50", "100"], ["3", "4", "5"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f29463d3d509e8f0d4533dce41682ae23c6c047e50f237c9afaac689ccf4df7d", "warmup_time": -1}, "io_matlab.MemUsage.track_loadmat": {"code": "class MemUsage:\n    def track_loadmat(self, size, compressed):\n        size = int(self.sizes[size])\n    \n        x = np.random.rand(size//8).view(dtype=np.uint8)\n        savemat(self.filename, dict(x=x), do_compression=compressed, oned_as='row')\n        del x\n    \n        code = \"\"\"\n        from scipy.io import loadmat\n        loadmat('%s')\n        \"\"\" % (self.filename,)\n        time, peak_mem = run_monitored(code)\n    \n        return peak_mem / size\n\n    def setup(self, size, compressed):\n        set_mem_rlimit()\n        self.sizes = self._get_sizes()\n        size = int(self.sizes[size])\n    \n        mem_info = get_mem_info()\n        try:\n            mem_available = mem_info['memavailable']\n        except KeyError:\n            mem_available = mem_info['memtotal']\n    \n        max_size = int(mem_available * 0.7)//4\n    \n        if size > max_size:\n            raise NotImplementedError()\n    \n        # Setup temp file\n        f = tempfile.NamedTemporaryFile(delete=False, suffix='.mat')\n        f.close()\n        self.filename = f.name", "name": "io_matlab.MemUsage.track_loadmat", "param_names": ["size", "compressed"], "params": [["'1M'", "'10M'", "'100M'", "'300M'"], ["True", "False"]], "timeout": 240, "type": "track", "unit": "actual/optimal memory usage ratio", "version": "a3de0f2b928a44594543559ae20a75c3b68b8ef0804ee8d76eb5d22cad39dd88"}, "io_matlab.MemUsage.track_savemat": {"code": "class MemUsage:\n    def track_savemat(self, size, compressed):\n        size = int(self.sizes[size])\n    \n        code = \"\"\"\n        import numpy as np\n        from scipy.io import savemat\n        x = np.random.rand(%d//8).view(dtype=np.uint8)\n        savemat('%s', dict(x=x), do_compression=%r, oned_as='row')\n        \"\"\" % (size, self.filename, compressed)\n        time, peak_mem = run_monitored(code)\n        return peak_mem / size\n\n    def setup(self, size, compressed):\n        set_mem_rlimit()\n        self.sizes = self._get_sizes()\n        size = int(self.sizes[size])\n    \n        mem_info = get_mem_info()\n        try:\n            mem_available = mem_info['memavailable']\n        except KeyError:\n            mem_available = mem_info['memtotal']\n    \n        max_size = int(mem_available * 0.7)//4\n    \n        if size > max_size:\n            raise NotImplementedError()\n    \n        # Setup temp file\n        f = tempfile.NamedTemporaryFile(delete=False, suffix='.mat')\n        f.close()\n        self.filename = f.name", "name": "io_matlab.MemUsage.track_savemat", "param_names": ["size", "compressed"], "params": [["'1M'", "'10M'", "'100M'", "'300M'"], ["True", "False"]], "timeout": 240, "type": "track", "unit": "actual/optimal memory usage ratio", "version": "457047076d11d25f1a3deee28e9af72616a90b5d6e383857226f869182bd8547"}, "io_matlab.StructArr.time_loadmat": {"code": "class StructArr:\n    def time_loadmat(self, nvfs, compression):\n        loadmat(self.str_io)\n\n    def setup(self, nvfs, compression):\n        n_vars, n_fields, n_structs = nvfs\n    \n        self.var_dict = StructArr.make_structarr(n_vars, n_fields, n_structs)\n        self.str_io = BytesIO()\n    \n        savemat(self.str_io, self.var_dict, do_compression=compression)", "min_run_count": 2, "name": "io_matlab.StructArr.time_loadmat", "number": 0, "param_names": ["(vars, fields, structs)", "compression"], "params": [["(10, 10, 20)", "(20, 20, 40)", "(30, 30, 50)"], ["False", "True"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "eaa1ea6c664b345fc8dd0a51ff7eedc973ed011300a9b2d3dedeec8cc61c2555", "warmup_time": -1}, "io_matlab.StructArr.time_savemat": {"code": "class StructArr:\n    def time_savemat(self, nvfs, compression):\n        savemat(self.str_io, self.var_dict, do_compression=compression)\n\n    def setup(self, nvfs, compression):\n        n_vars, n_fields, n_structs = nvfs\n    \n        self.var_dict = StructArr.make_structarr(n_vars, n_fields, n_structs)\n        self.str_io = BytesIO()\n    \n        savemat(self.str_io, self.var_dict, do_compression=compression)", "min_run_count": 2, "name": "io_matlab.StructArr.time_savemat", "number": 0, "param_names": ["(vars, fields, structs)", "compression"], "params": [["(10, 10, 20)", "(20, 20, 40)", "(30, 30, 50)"], ["False", "True"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8a4f85a8ff747a27983a799694aabf4332d11c7f5adb4b4a7db60a6b88ee538a", "warmup_time": -1}, "linalg.Bench.time_det": {"code": "class Bench:\n    def time_det(self, size, contig, module):\n        if module == 'numpy':\n            nl.det(self.a)\n        else:\n            sl.det(self.a)\n\n    def setup(self, size, contig, module):\n        if module == 'numpy' and size >= 200:\n            # skip: slow, and not useful to benchmark numpy\n            raise NotImplementedError()\n    \n        a = random([size, size])\n        # larger diagonal ensures non-singularity:\n        for i in range(size):\n            a[i, i] = 10*(.1+a[i, i])\n        b = random([size])\n    \n        if contig != 'contig':\n            a = a[-1::-1, -1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n    \n        self.a = a\n        self.b = b", "min_run_count": 2, "name": "linalg.Bench.time_det", "number": 0, "param_names": ["size", "contiguous", "module"], "params": [["20", "100", "500", "1000"], ["'contig'", "'nocont'"], ["'numpy'", "'scipy'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "87e530ee50eb6b6c06c7a8abe51c2168e133d5cbd486f4c1c2b9cedc5a078325", "warmup_time": -1}, "linalg.Bench.time_eigvals": {"code": "class Bench:\n    def time_eigvals(self, size, contig, module):\n        if module == 'numpy':\n            nl.eigvals(self.a)\n        else:\n            sl.eigvals(self.a)\n\n    def setup(self, size, contig, module):\n        if module == 'numpy' and size >= 200:\n            # skip: slow, and not useful to benchmark numpy\n            raise NotImplementedError()\n    \n        a = random([size, size])\n        # larger diagonal ensures non-singularity:\n        for i in range(size):\n            a[i, i] = 10*(.1+a[i, i])\n        b = random([size])\n    \n        if contig != 'contig':\n            a = a[-1::-1, -1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n    \n        self.a = a\n        self.b = b", "min_run_count": 2, "name": "linalg.Bench.time_eigvals", "number": 0, "param_names": ["size", "contiguous", "module"], "params": [["20", "100", "500", "1000"], ["'contig'", "'nocont'"], ["'numpy'", "'scipy'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9d68d3a6b473df9bdda3d3fd25c7f9aeea7d5cee869eec730fb2a2bcd1dfb907", "warmup_time": -1}, "linalg.Bench.time_inv": {"code": "class Bench:\n    def time_inv(self, size, contig, module):\n        if module == 'numpy':\n            nl.inv(self.a)\n        else:\n            sl.inv(self.a)\n\n    def setup(self, size, contig, module):\n        if module == 'numpy' and size >= 200:\n            # skip: slow, and not useful to benchmark numpy\n            raise NotImplementedError()\n    \n        a = random([size, size])\n        # larger diagonal ensures non-singularity:\n        for i in range(size):\n            a[i, i] = 10*(.1+a[i, i])\n        b = random([size])\n    \n        if contig != 'contig':\n            a = a[-1::-1, -1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n    \n        self.a = a\n        self.b = b", "min_run_count": 2, "name": "linalg.Bench.time_inv", "number": 0, "param_names": ["size", "contiguous", "module"], "params": [["20", "100", "500", "1000"], ["'contig'", "'nocont'"], ["'numpy'", "'scipy'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "20beee193c84a5713da9749246a7c40ef21590186c35ed00a4fe854cce9e153b", "warmup_time": -1}, "linalg.Bench.time_solve": {"code": "class Bench:\n    def time_solve(self, size, contig, module):\n        if module == 'numpy':\n            nl.solve(self.a, self.b)\n        else:\n            sl.solve(self.a, self.b)\n\n    def setup(self, size, contig, module):\n        if module == 'numpy' and size >= 200:\n            # skip: slow, and not useful to benchmark numpy\n            raise NotImplementedError()\n    \n        a = random([size, size])\n        # larger diagonal ensures non-singularity:\n        for i in range(size):\n            a[i, i] = 10*(.1+a[i, i])\n        b = random([size])\n    \n        if contig != 'contig':\n            a = a[-1::-1, -1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n    \n        self.a = a\n        self.b = b", "min_run_count": 2, "name": "linalg.Bench.time_solve", "number": 0, "param_names": ["size", "contiguous", "module"], "params": [["20", "100", "500", "1000"], ["'contig'", "'nocont'"], ["'numpy'", "'scipy'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1fe788070f1c9132cbe78a47fdb4cce58266427fc636d2aa9450e3c7d92c644c", "warmup_time": -1}, "linalg.Bench.time_solve_triangular": {"code": "class Bench:\n    def time_solve_triangular(self, size, contig, module):\n        # treats self.a as a lower-triangular matrix by ignoring the strictly\n        # upper-triangular part\n        if module == 'numpy':\n            pass\n        else:\n            sl.solve_triangular(self.a, self.b, lower=True)\n\n    def setup(self, size, contig, module):\n        if module == 'numpy' and size >= 200:\n            # skip: slow, and not useful to benchmark numpy\n            raise NotImplementedError()\n    \n        a = random([size, size])\n        # larger diagonal ensures non-singularity:\n        for i in range(size):\n            a[i, i] = 10*(.1+a[i, i])\n        b = random([size])\n    \n        if contig != 'contig':\n            a = a[-1::-1, -1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n    \n        self.a = a\n        self.b = b", "min_run_count": 2, "name": "linalg.Bench.time_solve_triangular", "number": 0, "param_names": ["size", "contiguous", "module"], "params": [["20", "100", "500", "1000"], ["'contig'", "'nocont'"], ["'numpy'", "'scipy'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f0ca78a2bbbb31809b47991f60d79103e46f6c00da7d9a55146c99be2e120904", "warmup_time": -1}, "linalg.Bench.time_svd": {"code": "class Bench:\n    def time_svd(self, size, contig, module):\n        if module == 'numpy':\n            nl.svd(self.a)\n        else:\n            sl.svd(self.a)\n\n    def setup(self, size, contig, module):\n        if module == 'numpy' and size >= 200:\n            # skip: slow, and not useful to benchmark numpy\n            raise NotImplementedError()\n    \n        a = random([size, size])\n        # larger diagonal ensures non-singularity:\n        for i in range(size):\n            a[i, i] = 10*(.1+a[i, i])\n        b = random([size])\n    \n        if contig != 'contig':\n            a = a[-1::-1, -1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n    \n        self.a = a\n        self.b = b", "min_run_count": 2, "name": "linalg.Bench.time_svd", "number": 0, "param_names": ["size", "contiguous", "module"], "params": [["20", "100", "500"], ["'contig'", "'nocont'"], ["'numpy'", "'scipy'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0ccbda456d096e459d4a6eefc6c674a815179e215f83931a81cfa8c18e39d6e3", "warmup_time": -1}, "linalg.GetFuncs.time_get_blas_funcs": {"code": "class GetFuncs:\n    def time_get_blas_funcs(self):\n        sl.blas.get_blas_funcs('gemm', dtype=float)\n\n    def setup(self):\n        self.x = np.eye(1)", "min_run_count": 2, "name": "linalg.GetFuncs.time_get_blas_funcs", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "85a492abc5bc17863ce56989679878c5cf88bfbabf331e733bac1e15c8b372c5", "warmup_time": -1}, "linalg.GetFuncs.time_get_blas_funcs_2": {"code": "class GetFuncs:\n    def time_get_blas_funcs_2(self):\n        sl.blas.get_blas_funcs(('gemm', 'axpy'), (self.x, self.x))\n\n    def setup(self):\n        self.x = np.eye(1)", "min_run_count": 2, "name": "linalg.GetFuncs.time_get_blas_funcs_2", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c5594e743e5de438fdfc4892c3c3ebf5f647a20b063740bc7b54e1b9728b17d2", "warmup_time": -1}, "linalg.GetFuncs.time_small_cholesky": {"code": "class GetFuncs:\n    def time_small_cholesky(self):\n        sl.cholesky(self.x)\n\n    def setup(self):\n        self.x = np.eye(1)", "min_run_count": 2, "name": "linalg.GetFuncs.time_small_cholesky", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5498b2ca496c0cc3be4278c533bbd9f6242df36c6116c748198937ffa7765a3d", "warmup_time": -1}, "linalg.Lstsq.time_lstsq": {"code": "class Lstsq:\n    def time_lstsq(self, dtype, size, lapack_driver):\n        if lapack_driver == 'numpy':\n            np.linalg.lstsq(self.A, self.b,\n                            rcond=np.finfo(self.A.dtype).eps * 100)\n        else:\n            sl.lstsq(self.A, self.b, cond=None, overwrite_a=False,\n                     overwrite_b=False, check_finite=False,\n                     lapack_driver=lapack_driver)\n\n    def setup(self, dtype, size, lapack_driver):\n        if lapack_driver == 'numpy' and size >= 200:\n            # skip: slow, and not useful to benchmark numpy\n            raise NotImplementedError()\n    \n        rng = np.random.default_rng(1234)\n        n = math.ceil(2./3. * size)\n        k = math.ceil(1./2. * size)\n        m = size\n    \n        if dtype is np.complex128:\n            A = ((10 * rng.random((m,k)) - 5) +\n                 1j*(10 * rng.random((m,k)) - 5))\n            temp = ((10 * rng.random((k,n)) - 5) +\n                    1j*(10 * rng.random((k,n)) - 5))\n            b = ((10 * rng.random((m,1)) - 5) +\n                 1j*(10 * rng.random((m,1)) - 5))\n        else:\n            A = (10 * rng.random((m,k)) - 5)\n            temp = 10 * rng.random((k,n)) - 5\n            b = 10 * rng.random((m,1)) - 5\n    \n        self.A = A.dot(temp)\n        self.b = b", "min_run_count": 2, "name": "linalg.Lstsq.time_lstsq", "number": 0, "param_names": ["dtype", "size", "driver"], "params": [["<class 'numpy.float64'>", "<class 'numpy.complex128'>"], ["10", "100", "1000"], ["'gelss'", "'gelsy'", "'gelsd'", "'numpy'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "15ee0be14a0a597c7d1c9a3dab2c39e15c8ac623484410ffefa406bf6b596ebe", "warmup_time": -1}, "linalg.Norm.time_1_norm": {"code": "class Norm:\n    def time_1_norm(self, size, contig, module):\n        if module == 'numpy':\n            nl.norm(self.a, ord=1)\n        else:\n            sl.norm(self.a, ord=1)\n\n    def setup(self, shape, contig, module):\n        a = np.random.randn(*shape)\n        if contig != 'contig':\n            a = a[-1::-1,-1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n        self.a = a", "min_run_count": 2, "name": "linalg.Norm.time_1_norm", "number": 0, "param_names": ["shape", "contiguous", "module"], "params": [["(20, 20)", "(100, 100)", "(1000, 1000)", "(20, 1000)", "(1000, 20)"], ["'contig'", "'nocont'"], ["'numpy'", "'scipy'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0c4e469d4304940ea54e1e81648836218da8c130601351fcd645b5d0856aad52", "warmup_time": -1}, "linalg.Norm.time_frobenius_norm": {"code": "class Norm:\n    def time_frobenius_norm(self, size, contig, module):\n        if module == 'numpy':\n            nl.norm(self.a)\n        else:\n            sl.norm(self.a)\n\n    def setup(self, shape, contig, module):\n        a = np.random.randn(*shape)\n        if contig != 'contig':\n            a = a[-1::-1,-1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n        self.a = a", "min_run_count": 2, "name": "linalg.Norm.time_frobenius_norm", "number": 0, "param_names": ["shape", "contiguous", "module"], "params": [["(20, 20)", "(100, 100)", "(1000, 1000)", "(20, 1000)", "(1000, 20)"], ["'contig'", "'nocont'"], ["'numpy'", "'scipy'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8fe6813e0aaaefc14b8423df9052a9ae584c655d64d2aa3f640bccf491f5023d", "warmup_time": -1}, "linalg.Norm.time_inf_norm": {"code": "class Norm:\n    def time_inf_norm(self, size, contig, module):\n        if module == 'numpy':\n            nl.norm(self.a, ord=np.inf)\n        else:\n            sl.norm(self.a, ord=np.inf)\n\n    def setup(self, shape, contig, module):\n        a = np.random.randn(*shape)\n        if contig != 'contig':\n            a = a[-1::-1,-1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n        self.a = a", "min_run_count": 2, "name": "linalg.Norm.time_inf_norm", "number": 0, "param_names": ["shape", "contiguous", "module"], "params": [["(20, 20)", "(100, 100)", "(1000, 1000)", "(20, 1000)", "(1000, 20)"], ["'contig'", "'nocont'"], ["'numpy'", "'scipy'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "eeebd84b29c3213e8701161fb693d8ccf1b0a3ce1571b7056a2375d860a9f379", "warmup_time": -1}, "linalg.SpecialMatrices.time_block_diag_big": {"code": "class SpecialMatrices:\n    def time_block_diag_big(self, size):\n        sl.block_diag(*self.big_blocks)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]", "min_run_count": 2, "name": "linalg.SpecialMatrices.time_block_diag_big", "number": 0, "param_names": ["size"], "params": [["4", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ca1cfb7c5688eb5158bf1a4786c068cadad77dac06e0993bb7a09900268d2f8a", "warmup_time": -1}, "linalg.SpecialMatrices.time_block_diag_small": {"code": "class SpecialMatrices:\n    def time_block_diag_small(self, size):\n        sl.block_diag(*self.small_blocks)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]", "min_run_count": 2, "name": "linalg.SpecialMatrices.time_block_diag_small", "number": 0, "param_names": ["size"], "params": [["4", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "08bd113cd63ceab984ec8506832a8481a9f71ec545ed6c666bf8b136ba1641a4", "warmup_time": -1}, "linalg.SpecialMatrices.time_circulant": {"code": "class SpecialMatrices:\n    def time_circulant(self, size):\n        sl.circulant(self.x)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]", "min_run_count": 2, "name": "linalg.SpecialMatrices.time_circulant", "number": 0, "param_names": ["size"], "params": [["4", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9a8e71bd90ee1cee162f93e666ffbe70e52dcff361363ed393451e95173ffb93", "warmup_time": -1}, "linalg.SpecialMatrices.time_companion": {"code": "class SpecialMatrices:\n    def time_companion(self, size):\n        sl.companion(self.x)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]", "min_run_count": 2, "name": "linalg.SpecialMatrices.time_companion", "number": 0, "param_names": ["size"], "params": [["4", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6a2b51c299f8053c4a2892dfb27fe9c0e04839e27f282ee64082a3c6f945bb26", "warmup_time": -1}, "linalg.SpecialMatrices.time_dft": {"code": "class SpecialMatrices:\n    def time_dft(self, size):\n        sl.dft(size)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]", "min_run_count": 2, "name": "linalg.SpecialMatrices.time_dft", "number": 0, "param_names": ["size"], "params": [["4", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "774d3ef82e8e8667149d3b0392926b8b14f31654b8e8a1e9040ee11dc8a81001", "warmup_time": -1}, "linalg.SpecialMatrices.time_hadamard": {"code": "class SpecialMatrices:\n    def time_hadamard(self, size):\n        sl.hadamard(size)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]", "min_run_count": 2, "name": "linalg.SpecialMatrices.time_hadamard", "number": 0, "param_names": ["size"], "params": [["4", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6982c46c572fb1e959ddc398e289b7c0297219cf0b1da0fb2bbe593a8238143e", "warmup_time": -1}, "linalg.SpecialMatrices.time_hankel": {"code": "class SpecialMatrices:\n    def time_hankel(self, size):\n        sl.hankel(self.x)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]", "min_run_count": 2, "name": "linalg.SpecialMatrices.time_hankel", "number": 0, "param_names": ["size"], "params": [["4", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "df4ca64aee572eecd70fd7579f07d92ead412147971b102d0a5d07085d1a570b", "warmup_time": -1}, "linalg.SpecialMatrices.time_helmert": {"code": "class SpecialMatrices:\n    def time_helmert(self, size):\n        sl.helmert(size)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]", "min_run_count": 2, "name": "linalg.SpecialMatrices.time_helmert", "number": 0, "param_names": ["size"], "params": [["4", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "95dd6bf94b1595e67c8773393bb7444b228699d7816587cb2c78a5de5a2b7e61", "warmup_time": -1}, "linalg.SpecialMatrices.time_hilbert": {"code": "class SpecialMatrices:\n    def time_hilbert(self, size):\n        sl.hilbert(size)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]", "min_run_count": 2, "name": "linalg.SpecialMatrices.time_hilbert", "number": 0, "param_names": ["size"], "params": [["4", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "893c05bfdd50af7f0ecd24db33c54fbd8161eda59eee574312a59f9556d1e152", "warmup_time": -1}, "linalg.SpecialMatrices.time_invhilbert": {"code": "class SpecialMatrices:\n    def time_invhilbert(self, size):\n        sl.invhilbert(size)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]", "min_run_count": 2, "name": "linalg.SpecialMatrices.time_invhilbert", "number": 0, "param_names": ["size"], "params": [["4", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "95fc697960fd6ba2701667dd367983c5da39658cf1ea3912e8070291c88a5651", "warmup_time": -1}, "linalg.SpecialMatrices.time_invpascal": {"code": "class SpecialMatrices:\n    def time_invpascal(self, size):\n        sl.invpascal(size)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]", "min_run_count": 2, "name": "linalg.SpecialMatrices.time_invpascal", "number": 0, "param_names": ["size"], "params": [["4", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c986e6e8e50989963505966431db567554ecc8d0ce48e3e1b01d864c9fabb823", "warmup_time": -1}, "linalg.SpecialMatrices.time_leslie": {"code": "class SpecialMatrices:\n    def time_leslie(self, size):\n        sl.leslie(self.x, self.x[1:])\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]", "min_run_count": 2, "name": "linalg.SpecialMatrices.time_leslie", "number": 0, "param_names": ["size"], "params": [["4", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "32f946dce60929e4b038909b92206c66036f26ef3f447ffe35f1acda9adad10c", "warmup_time": -1}, "linalg.SpecialMatrices.time_pascal": {"code": "class SpecialMatrices:\n    def time_pascal(self, size):\n        sl.pascal(size)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]", "min_run_count": 2, "name": "linalg.SpecialMatrices.time_pascal", "number": 0, "param_names": ["size"], "params": [["4", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7eb81323c4e69ab614ac789d44882ed319c651987bc9795f36af4264a7383a7c", "warmup_time": -1}, "linalg.SpecialMatrices.time_toeplitz": {"code": "class SpecialMatrices:\n    def time_toeplitz(self, size):\n        sl.toeplitz(self.x)\n\n    def setup(self, size):\n        self.x = np.arange(1, size + 1).astype(float)\n        self.small_blocks = [np.ones([2, 2])] * (size//2)\n        self.big_blocks = [np.ones([size//2, size//2]),\n                           np.ones([size//2, size//2])]", "min_run_count": 2, "name": "linalg.SpecialMatrices.time_toeplitz", "number": 0, "param_names": ["size"], "params": [["4", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "72f43bf3cb772c6ef6be46598b81a7ba5d59f9fc12fb58e3a2f1148c8ec755fb", "warmup_time": -1}, "linalg_logm.Logm.time_logm": {"code": "class Logm:\n    def time_logm(self, dtype, n, structure):\n        scipy.linalg.logm(self.A, disp=False)\n\n    def setup(self, dtype, n, structure):\n        n = int(n)\n        dtype = np.dtype(dtype)\n    \n        A = np.random.rand(n, n)\n        if dtype == np.complex128:\n            A = A + 1j*np.random.rand(n, n)\n    \n        if structure == 'pos':\n            A = A @ A.T.conj()\n        elif structure == 'her':\n            A = A + A.T.conj()\n    \n        self.A = A", "min_run_count": 2, "name": "linalg_logm.Logm.time_logm", "number": 0, "param_names": ["dtype", "n", "structure"], "params": [["'float64'", "'complex128'"], ["64", "256"], ["'gen'", "'her'", "'pos'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6e9f69e2e3cd7003ba0cf66bf2706a2be2c80f065d0f48427d3c7bda668a2058", "warmup_time": -1}, "linalg_solve_toeplitz.SolveToeplitz.time_solve_toeplitz": {"code": "class SolveToeplitz:\n    def time_solve_toeplitz(self, dtype, n, soltype):\n        if soltype == 'toeplitz':\n            scipy.linalg.solve_toeplitz((self.c, self.r), self.y)\n        else:\n            scipy.linalg.solve(self.T, self.y)\n\n    def setup(self, dtype, n, soltype):\n        random = np.random.RandomState(1234)\n    \n        dtype = np.dtype(dtype)\n    \n        # Sample a random Toeplitz matrix representation and rhs.\n        c = random.randn(n)\n        r = random.randn(n)\n        y = random.randn(n)\n        if dtype == np.complex128:\n            c = c + 1j*random.rand(n)\n            r = r + 1j*random.rand(n)\n            y = y + 1j*random.rand(n)\n    \n        self.c = c\n        self.r = r\n        self.y = y\n        self.T = scipy.linalg.toeplitz(c, r=r)", "min_run_count": 2, "name": "linalg_solve_toeplitz.SolveToeplitz.time_solve_toeplitz", "number": 0, "param_names": ["dtype", "n", "solver"], "params": [["'float64'", "'complex128'"], ["100", "300", "1000"], ["'toeplitz'", "'generic'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d5d6bb8933b458885e968d871d860965a2af33720ca7a4872dafe7b9db2eb5c3", "warmup_time": -1}, "linalg_sqrtm.Sqrtm.time_sqrtm": {"code": "class Sqrtm:\n    def time_sqrtm(self, dtype, n, blocksize):\n        scipy.linalg.sqrtm(self.A, disp=False, blocksize=blocksize)\n\n    def setup(self, dtype, n, blocksize):\n        n = int(n)\n        dtype = np.dtype(dtype)\n        blocksize = int(blocksize)\n        A = np.random.rand(n, n)\n        if dtype == np.complex128:\n            A = A + 1j*np.random.rand(n, n)\n        self.A = A\n    \n        if blocksize > n:\n            raise NotImplementedError()", "min_run_count": 2, "name": "linalg_sqrtm.Sqrtm.time_sqrtm", "number": 0, "param_names": ["dtype", "n", "blocksize"], "params": [["'float64'", "'complex128'"], ["64", "256"], ["32", "64", "256"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "359ff21f2b4f63f08772e0e19eef1758190d58abd549c8b5b6d8b784100b9cb0", "warmup_time": -1}, "ndimage_interpolation.NdimageInterpolation.peakmem_rotate": {"code": "class NdimageInterpolation:\n    def peakmem_rotate(self, shape, order, mode):\n        rotate(self.x, 15, order=order, mode=mode)\n\n    def setup(self, shape, order, mode):\n        rstate = np.random.RandomState(5)\n        self.x = rstate.standard_normal(shape)\n        self.matrix_2d = np.asarray([[0.8, 0, 1.5],\n                                     [0, 1.2, -5.]])\n        self.matrix_3d = np.asarray([[0.8, 0, 0, 1.5],\n                                     [0, 1.2, 0, -5.],\n                                     [0, 0, 1, 0]])", "name": "ndimage_interpolation.NdimageInterpolation.peakmem_rotate", "param_names": ["shape", "order", "mode"], "params": [["(64, 64)", "(512, 512)", "(2048, 2048)", "(16, 16, 16)", "(128, 128, 128)"], ["0", "1", "3", "5"], ["'mirror'", "'constant'"]], "timeout": 60.0, "type": "peakmemory", "unit": "bytes", "version": "6f1ea489a0714868c9f52c013d563cda0604c90c44d49df51afe4c5c362a8331"}, "ndimage_interpolation.NdimageInterpolation.peakmem_shift": {"code": "class NdimageInterpolation:\n    def peakmem_shift(self, shape, order, mode):\n        shift(self.x, 3, order=order, mode=mode)\n\n    def setup(self, shape, order, mode):\n        rstate = np.random.RandomState(5)\n        self.x = rstate.standard_normal(shape)\n        self.matrix_2d = np.asarray([[0.8, 0, 1.5],\n                                     [0, 1.2, -5.]])\n        self.matrix_3d = np.asarray([[0.8, 0, 0, 1.5],\n                                     [0, 1.2, 0, -5.],\n                                     [0, 0, 1, 0]])", "name": "ndimage_interpolation.NdimageInterpolation.peakmem_shift", "param_names": ["shape", "order", "mode"], "params": [["(64, 64)", "(512, 512)", "(2048, 2048)", "(16, 16, 16)", "(128, 128, 128)"], ["0", "1", "3", "5"], ["'mirror'", "'constant'"]], "timeout": 60.0, "type": "peakmemory", "unit": "bytes", "version": "c0431a339d0b5e59a56534e533fc4236ebe6fc1086c437410c900ab9005e4dd7"}, "ndimage_interpolation.NdimageInterpolation.time_affine_transform": {"code": "class NdimageInterpolation:\n    def time_affine_transform(self, shape, order, mode):\n        if self.x.ndim == 2:\n            matrix = self.matrix_2d\n        else:\n            matrix = self.matrix_3d\n        affine_transform(self.x, matrix, order=order, mode=mode)\n\n    def setup(self, shape, order, mode):\n        rstate = np.random.RandomState(5)\n        self.x = rstate.standard_normal(shape)\n        self.matrix_2d = np.asarray([[0.8, 0, 1.5],\n                                     [0, 1.2, -5.]])\n        self.matrix_3d = np.asarray([[0.8, 0, 0, 1.5],\n                                     [0, 1.2, 0, -5.],\n                                     [0, 0, 1, 0]])", "min_run_count": 2, "name": "ndimage_interpolation.NdimageInterpolation.time_affine_transform", "number": 0, "param_names": ["shape", "order", "mode"], "params": [["(64, 64)", "(512, 512)", "(2048, 2048)", "(16, 16, 16)", "(128, 128, 128)"], ["0", "1", "3", "5"], ["'mirror'", "'constant'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "87ae4c3be4b670d5403bc0cecc52f5b360269fe4b6d91bce0cc65359bbb45888", "warmup_time": -1}, "ndimage_interpolation.NdimageInterpolation.time_geometric_transform_mapping": {"code": "class NdimageInterpolation:\n    def time_geometric_transform_mapping(self, shape, order, mode):\n        if self.x.ndim == 2:\n            mapping = shift_func_2d\n        if self.x.ndim == 3:\n            mapping = shift_func_3d\n        geometric_transform(self.x, mapping, order=order, mode=mode)\n\n    def setup(self, shape, order, mode):\n        rstate = np.random.RandomState(5)\n        self.x = rstate.standard_normal(shape)\n        self.matrix_2d = np.asarray([[0.8, 0, 1.5],\n                                     [0, 1.2, -5.]])\n        self.matrix_3d = np.asarray([[0.8, 0, 0, 1.5],\n                                     [0, 1.2, 0, -5.],\n                                     [0, 0, 1, 0]])", "min_run_count": 2, "name": "ndimage_interpolation.NdimageInterpolation.time_geometric_transform_mapping", "number": 0, "param_names": ["shape", "order", "mode"], "params": [["(64, 64)", "(512, 512)", "(2048, 2048)", "(16, 16, 16)", "(128, 128, 128)"], ["0", "1", "3", "5"], ["'mirror'", "'constant'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7d3fc4986820607551da357e66e28639b5182b2b75c35dbc7c979748b11042a1", "warmup_time": -1}, "ndimage_interpolation.NdimageInterpolation.time_map_coordinates": {"code": "class NdimageInterpolation:\n    def time_map_coordinates(self, shape, order, mode):\n        coords = np.meshgrid(*[np.arange(0, s, 2) + 0.3 for s in self.x.shape])\n        map_coordinates(self.x, coords, order=order, mode=mode)\n\n    def setup(self, shape, order, mode):\n        rstate = np.random.RandomState(5)\n        self.x = rstate.standard_normal(shape)\n        self.matrix_2d = np.asarray([[0.8, 0, 1.5],\n                                     [0, 1.2, -5.]])\n        self.matrix_3d = np.asarray([[0.8, 0, 0, 1.5],\n                                     [0, 1.2, 0, -5.],\n                                     [0, 0, 1, 0]])", "min_run_count": 2, "name": "ndimage_interpolation.NdimageInterpolation.time_map_coordinates", "number": 0, "param_names": ["shape", "order", "mode"], "params": [["(64, 64)", "(512, 512)", "(2048, 2048)", "(16, 16, 16)", "(128, 128, 128)"], ["0", "1", "3", "5"], ["'mirror'", "'constant'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "12262655b132fab6113eccbf4e5c74a7683219f463ba745394a95c0eb0e02053", "warmup_time": -1}, "ndimage_interpolation.NdimageInterpolation.time_rotate": {"code": "class NdimageInterpolation:\n    def time_rotate(self, shape, order, mode):\n        rotate(self.x, 15, order=order, mode=mode)\n\n    def setup(self, shape, order, mode):\n        rstate = np.random.RandomState(5)\n        self.x = rstate.standard_normal(shape)\n        self.matrix_2d = np.asarray([[0.8, 0, 1.5],\n                                     [0, 1.2, -5.]])\n        self.matrix_3d = np.asarray([[0.8, 0, 0, 1.5],\n                                     [0, 1.2, 0, -5.],\n                                     [0, 0, 1, 0]])", "min_run_count": 2, "name": "ndimage_interpolation.NdimageInterpolation.time_rotate", "number": 0, "param_names": ["shape", "order", "mode"], "params": [["(64, 64)", "(512, 512)", "(2048, 2048)", "(16, 16, 16)", "(128, 128, 128)"], ["0", "1", "3", "5"], ["'mirror'", "'constant'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c346329372eb7abaaedd1f78c642ae55fff9d5991644b9608ab3ed4380d00d0c", "warmup_time": -1}, "ndimage_interpolation.NdimageInterpolation.time_shift": {"code": "class NdimageInterpolation:\n    def time_shift(self, shape, order, mode):\n        shift(self.x, (-2.5,) * self.x.ndim, order=order, mode=mode)\n\n    def setup(self, shape, order, mode):\n        rstate = np.random.RandomState(5)\n        self.x = rstate.standard_normal(shape)\n        self.matrix_2d = np.asarray([[0.8, 0, 1.5],\n                                     [0, 1.2, -5.]])\n        self.matrix_3d = np.asarray([[0.8, 0, 0, 1.5],\n                                     [0, 1.2, 0, -5.],\n                                     [0, 0, 1, 0]])", "min_run_count": 2, "name": "ndimage_interpolation.NdimageInterpolation.time_shift", "number": 0, "param_names": ["shape", "order", "mode"], "params": [["(64, 64)", "(512, 512)", "(2048, 2048)", "(16, 16, 16)", "(128, 128, 128)"], ["0", "1", "3", "5"], ["'mirror'", "'constant'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "136f315880a230d6e7dd105c0bbefde19261fab1b85e40d0d6124dbf51359c04", "warmup_time": -1}, "ndimage_interpolation.NdimageInterpolation.time_zoom": {"code": "class NdimageInterpolation:\n    def time_zoom(self, shape, order, mode):\n        zoom(self.x, (1.3,) * self.x.ndim, order=order, mode=mode)\n\n    def setup(self, shape, order, mode):\n        rstate = np.random.RandomState(5)\n        self.x = rstate.standard_normal(shape)\n        self.matrix_2d = np.asarray([[0.8, 0, 1.5],\n                                     [0, 1.2, -5.]])\n        self.matrix_3d = np.asarray([[0.8, 0, 0, 1.5],\n                                     [0, 1.2, 0, -5.],\n                                     [0, 0, 1, 0]])", "min_run_count": 2, "name": "ndimage_interpolation.NdimageInterpolation.time_zoom", "number": 0, "param_names": ["shape", "order", "mode"], "params": [["(64, 64)", "(512, 512)", "(2048, 2048)", "(16, 16, 16)", "(128, 128, 128)"], ["0", "1", "3", "5"], ["'mirror'", "'constant'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "986a39adec187cc3b9b3ad42a883d5fa054683bbc38fa75ff3a5c64d9d1fb14d", "warmup_time": -1}, "optimize.BenchGlobal.track_all": {"code": "class BenchGlobal:\n    def track_all(self, name, ret_value, solver):\n        if name in self.results and solver in self.results[name]:\n            # have we done the function, and done the solver?\n            # if so, then just return the ret_value\n            av_results = self.results[name]\n            if ret_value == 'success%':\n                return 100 * av_results[solver]['nsuccess'] / av_results[solver]['ntrials']\n            elif ret_value == '<nfev>':\n                return av_results[solver]['mean_nfev']\n            else:\n                raise ValueError()\n    \n        klass = self._functions[name]\n        f = klass()\n        try:\n            b = _BenchOptimizers.from_funcobj(name, f)\n            with np.errstate(all='ignore'):\n                b.bench_run_global(methods=[solver],\n                                   numtrials=self.numtrials)\n    \n            av_results = b.average_results()\n    \n            if name not in self.results:\n                self.results[name] = {}\n            self.results[name][solver] = av_results[solver]\n    \n            if ret_value == 'success%':\n                return 100 * av_results[solver]['nsuccess'] / av_results[solver]['ntrials']\n            elif ret_value == '<nfev>':\n                return av_results[solver]['mean_nfev']\n            else:\n                raise ValueError()\n        except Exception:\n            print(\"\".join(traceback.format_exc()))\n            self.results[name] = \"\".join(traceback.format_exc())\n\n    def setup(self, name, ret_value, solver):\n        if name not in self._enabled_functions:\n            raise NotImplementedError(\"skipped\")\n    \n        # load json backing file\n        with open(self.dump_fn, 'r') as f:\n            self.results = json.load(f)\n\n    def setup_cache(self):\n        if not self.enabled:\n            return\n    \n        # create the logfile to start with\n        with open(self.dump_fn, 'w') as f:\n            json.dump({}, f, indent=2)", "name": "optimize.BenchGlobal.track_all", "param_names": ["test function", "result type", "solver"], "params": [["'AMGM'", "'Ackley01'", "'Ackley02'", "'Ackley03'", "'Adjiman'", "'Alpine01'", "'Alpine02'", "'BartelsConn'", "'Beale'", "'BiggsExp02'", "'BiggsExp03'", "'BiggsExp04'", "'BiggsExp05'", "'Bird'", "'Bohachevsky1'", "'Bohachevsky2'", "'Bohachevsky3'", "'BoxBetts'", "'Branin01'", "'Branin02'", "'Brent'", "'Brown'", "'Bukin02'", "'Bukin04'", "'Bukin06'", "'CarromTable'", "'Chichinadze'", "'Cigar'", "'Cola'", "'Colville'", "'Corana'", "'CosineMixture'", "'CrossInTray'", "'CrossLegTable'", "'CrownedCross'", "'Csendes'", "'Cube'", "'Damavandi'", "'DeVilliersGlasser01'", "'DeVilliersGlasser02'", "'Deb01'", "'Deb03'", "'Decanomial'", "'Deceptive'", "'DeckkersAarts'", "'DeflectedCorrugatedSpring'", "'DixonPrice'", "'Dolan'", "'DropWave'", "'Easom'", "'Eckerle4'", "'EggCrate'", "'EggHolder'", "'ElAttarVidyasagarDutta'", "'Exp2'", "'Exponential'", "'FreudensteinRoth'", "'Gear'", "'Giunta'", "'GoldsteinPrice'", "'Griewank'", "'Gulf'", "'Hansen'", "'Hartmann3'", "'Hartmann6'", "'HelicalValley'", "'HimmelBlau'", "'HolderTable'", "'Hosaki'", "'Infinity'", "'JennrichSampson'", "'Judge'", "'Katsuura'", "'Keane'", "'Kowalik'", "'Langermann'", "'LennardJones'", "'Leon'", "'Levy03'", "'Levy05'", "'Levy13'", "'Matyas'", "'McCormick'", "'Meyer'", "'Michalewicz'", "'MieleCantrell'", "'Mishra01'", "'Mishra02'", "'Mishra03'", "'Mishra04'", "'Mishra05'", "'Mishra06'", "'Mishra07'", "'Mishra08'", "'Mishra09'", "'Mishra10'", "'Mishra11'", "'MultiModal'", "'NeedleEye'", "'NewFunction01'", "'NewFunction02'", "'OddSquare'", "'Parsopoulos'", "'Pathological'", "'Paviani'", "'PenHolder'", "'Penalty01'", "'Penalty02'", "'PermFunction01'", "'PermFunction02'", "'Pinter'", "'Plateau'", "'Powell'", "'PowerSum'", "'Price01'", "'Price02'", "'Price03'", "'Price04'", "'Qing'", "'Quadratic'", "'Quintic'", "'Rana'", "'Rastrigin'", "'Ratkowsky01'", "'Ratkowsky02'", "'Ripple01'", "'Ripple25'", "'Rosenbrock'", "'RosenbrockModified'", "'RotatedEllipse01'", "'RotatedEllipse02'", "'Salomon'", "'Sargan'", "'Schaffer01'", "'Schaffer02'", "'Schaffer03'", "'Schaffer04'", "'Schwefel01'", "'Schwefel02'", "'Schwefel04'", "'Schwefel06'", "'Schwefel20'", "'Schwefel21'", "'Schwefel22'", "'Schwefel26'", "'Schwefel36'", "'Shekel05'", "'Shekel07'", "'Shekel10'", "'Shubert01'", "'Shubert03'", "'Shubert04'", "'SineEnvelope'", "'SixHumpCamel'", "'Sodp'", "'Sphere'", "'Step'", "'Step2'", "'Stochastic'", "'StretchedV'", "'StyblinskiTang'", "'TestTubeHolder'", "'ThreeHumpCamel'", "'Thurber'", "'Treccani'", "'Trefethen'", "'Trid'", "'Trigonometric01'", "'Trigonometric02'", "'Tripod'", "'Ursem01'", "'Ursem03'", "'Ursem04'", "'UrsemWaves'", "'VenterSobiezcczanskiSobieski'", "'Vincent'", "'Watson'", "'Wavy'", "'WayburnSeader01'", "'WayburnSeader02'", "'Weierstrass'", "'Whitley'", "'Wolfe'", "'XinSheYang01'", "'XinSheYang02'", "'XinSheYang03'", "'XinSheYang04'", "'Xor'", "'YaoLiu04'", "'YaoLiu09'", "'Zacharov'", "'ZeroSum'", "'Zettl'", "'Zimmerman'", "'Zirilli'"], ["'success%'", "'<nfev>'"], ["'DE'", "'basinh.'", "'DA'"]], "setup_cache_key": "optimize:519", "timeout": 300, "type": "track", "unit": "unit", "version": "054a3246db40d00bd06bdd153e16fba533aa32a939b0cc5a9d4ad3425afdd4d5"}, "optimize.BenchLeastSquares.track_all": {"code": "class BenchLeastSquares:\n    def track_all(self, problem_name, result_type):\n        problem = self.problems[problem_name]\n    \n        if problem.lb is not None or problem.ub is not None:\n            raise NotImplementedError\n    \n        ftol = 1e-5\n    \n        if result_type == 'average time':\n            n_runs = 10\n            t0 = time.time()\n            for _ in range(n_runs):\n                leastsq(problem.fun, problem.x0, Dfun=problem.jac, ftol=ftol,\n                        full_output=True)\n            return (time.time() - t0) / n_runs\n    \n        x, cov_x, info, message, ier = leastsq(\n            problem.fun, problem.x0, Dfun=problem.jac,\n            ftol=ftol, full_output=True\n        )\n        if result_type == 'nfev':\n            return info['nfev']\n        elif result_type == 'success':\n            return int(problem.check_answer(x, ftol))\n        else:\n            raise NotImplementedError", "name": "optimize.BenchLeastSquares.track_all", "param_names": ["problem", "result type"], "params": [["'AlphaPineneDirect'", "'ChebyshevQuadrature'", "'CoatingThickness'", "'EnzymeReaction'", "'ExponentialFitting'", "'GaussianFitting'", "'ThermistorResistance'"], ["'average time'", "'nfev'", "'success'"]], "timeout": 60.0, "type": "track", "unit": "unit", "version": "f38fbe672c2954249e521c5aa92737c6659f885c52e0ed5fa863c171f56bb902"}, "optimize.BenchSmoothUnbounded.track_all": {"code": "class BenchSmoothUnbounded:\n    def track_all(self, func_name, method_name, ret_val):\n        return self.result\n\n    def setup(self, func_name, method_name, ret_val):\n        b = getattr(self, 'run_' + func_name)(methods=[method_name])\n        r = b.average_results().get(method_name)\n        if r is None:\n            raise NotImplementedError()\n        self.result = getattr(r, ret_val)", "name": "optimize.BenchSmoothUnbounded.track_all", "param_names": ["test function", "solver", "result type"], "params": [["'rosenbrock_slow'", "'rosenbrock_nograd'", "'rosenbrock'", "'rosenbrock_tight'", "'simple_quadratic'", "'asymmetric_quadratic'", "'sin_1d'", "'booth'", "'beale'", "'LJ'"], ["'COBYLA'", "'Powell'", "'nelder-mead'", "'L-BFGS-B'", "'BFGS'", "'CG'", "'TNC'", "'SLSQP'", "'Newton-CG'", "'dogleg'", "'trust-ncg'", "'trust-exact'", "'trust-krylov'", "'trust-constr'"], ["'mean_nfev'", "'mean_time'"]], "timeout": 60.0, "type": "track", "unit": "unit", "version": "470a193366611f84efefb220d095286dbc18dc8501b63d8e703aad41a1b0b32f"}, "optimize_lap.LinearAssignment.time_evaluation": {"code": "class LinearAssignment:\n    def time_evaluation(self, *args):\n        linear_sum_assignment(self.cost_matrix)\n\n    def setup(self, shape, cost_type):\n    \n        cost_func = {'uniform': random_uniform,\n                     'spatial': random_spatial,\n                     'logarithmic': random_logarithmic,\n                     'integer': random_integer,\n                     'binary': random_binary}[cost_type]\n    \n        self.cost_matrix = cost_func(shape)", "min_run_count": 2, "name": "optimize_lap.LinearAssignment.time_evaluation", "number": 0, "param_names": ["shape", "cost_type"], "params": [["(100, 100)", "(200, 200)", "(300, 300)", "(400, 400)", "(100, 200)", "(200, 400)", "(300, 600)", "(400, 800)", "(200, 100)", "(400, 200)", "(600, 300)", "(800, 400)"], ["'uniform'", "'spatial'", "'logarithmic'", "'integer'", "'binary'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ac7928b4de54d3fe94a6560b66d403b8ed9ffe1f2c8e910dd59159fda0bb34b0", "warmup_time": -1}, "optimize_linprog.KleeMinty.time_klee_minty": {"code": "class KleeMinty:\n    def time_klee_minty(self, meth, dims):\n        method, options = meth\n        res = linprog(c=self.c, A_ub=self.A_ub, b_ub=self.b_ub,\n                      method=method, options=options)\n        self.fun = res.fun\n        self.x = res.x\n\n    def setup(self, meth, dims):\n        self.c, self.A_ub, self.b_ub, self.xf, self.obj = klee_minty(dims)\n        self.fun = None", "min_run_count": 2, "name": "optimize_linprog.KleeMinty.time_klee_minty", "number": 0, "param_names": ["method", "dimensions"], "params": [["('highs-ipm', {})", "('highs-ds', {})"], ["3", "6", "9"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "590dc9ee8c5e8773840dee6216d46fd19d8f684dee353f9a5fa6b37c39b9d381", "warmup_time": -1}, "optimize_linprog.KleeMinty.track_klee_minty": {"code": "class KleeMinty:\n    def track_klee_minty(self, meth, prob):\n        if self.fun is None:\n            self.time_klee_minty(meth, prob)\n        self.abs_error = np.abs(self.fun - self.obj)\n        self.rel_error = np.abs((self.fun - self.obj)/self.obj)\n        return min(self.abs_error, self.rel_error)\n\n    def setup(self, meth, dims):\n        self.c, self.A_ub, self.b_ub, self.xf, self.obj = klee_minty(dims)\n        self.fun = None", "name": "optimize_linprog.KleeMinty.track_klee_minty", "param_names": ["method", "dimensions"], "params": [["('highs-ipm', {})", "('highs-ds', {})"], ["3", "6", "9"]], "timeout": 60.0, "type": "track", "unit": "unit", "version": "64d3a316d3de8ff7bad239207b13f3b6bee2326fe913a4e0d15cf727b3291c30"}, "optimize_linprog.LpGen.time_lpgen": {"code": "class LpGen:\n    def time_lpgen(self, meth, m, n):\n        method, options = meth\n        with suppress_warnings() as sup:\n            sup.filter(RuntimeWarning, \"scipy.linalg.solve\\nIll-conditioned\")\n            linprog(c=self.c, A_ub=self.A, b_ub=self.b,\n                    method=method, options=options)\n\n    def setup(self, meth, m, n):\n        self.A, self.b, self.c = lpgen_2d(m, n)", "min_run_count": 2, "name": "optimize_linprog.LpGen.time_lpgen", "number": 0, "param_names": ["method", "m", "n"], "params": [["('highs-ipm', {})", "('highs-ds', {})"], ["20", "40", "60", "80"], ["20", "40", "60", "80"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "71ffc02cac666c80fe11a5dd116b7e33c97b5d9f27ccb95bb83610359c927c4e", "warmup_time": -1}, "optimize_linprog.MagicSquare.time_magic_square": {"code": "class MagicSquare:\n    def time_magic_square(self, meth, prob):\n        method, options = meth\n        with suppress_warnings() as sup:\n            sup.filter(OptimizeWarning, \"A_eq does not appear\")\n            res = linprog(c=self.c, A_eq=self.A_eq, b_eq=self.b_eq,\n                          bounds=(0, 1), method=method, options=options)\n            self.fun = res.fun\n\n    def setup(self, meth, prob):\n        if not is_xslow():\n            if prob[0] > 4:\n                raise NotImplementedError(\"skipped\")\n    \n        dims, obj = prob\n        self.A_eq, self.b_eq, self.c, numbers, _ = magic_square(dims)\n        self.fun = None", "min_run_count": 2, "name": "optimize_linprog.MagicSquare.time_magic_square", "number": 0, "param_names": ["method", "(dimensions, objective)"], "params": [["('highs-ipm', {})", "('highs-ds', {})"], ["(3, 1.7305505947214375)", "(4, 1.5485271031586025)", "(5, 1.807494583582637)", "(6, 1.747266446858304)"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "fcd1f8f0c666a2335be965e77fa535d9f66d5150ee6889e743f72e65b62b74c9", "warmup_time": -1}, "optimize_linprog.MagicSquare.track_magic_square": {"code": "class MagicSquare:\n    def track_magic_square(self, meth, prob):\n        dims, obj = prob\n        if self.fun is None:\n            self.time_magic_square(meth, prob)\n        self.abs_error = np.abs(self.fun - obj)\n        self.rel_error = np.abs((self.fun - obj)/obj)\n        return min(self.abs_error, self.rel_error)\n\n    def setup(self, meth, prob):\n        if not is_xslow():\n            if prob[0] > 4:\n                raise NotImplementedError(\"skipped\")\n    \n        dims, obj = prob\n        self.A_eq, self.b_eq, self.c, numbers, _ = magic_square(dims)\n        self.fun = None", "name": "optimize_linprog.MagicSquare.track_magic_square", "param_names": ["method", "(dimensions, objective)"], "params": [["('highs-ipm', {})", "('highs-ds', {})"], ["(3, 1.7305505947214375)", "(4, 1.5485271031586025)", "(5, 1.807494583582637)", "(6, 1.747266446858304)"]], "timeout": 60.0, "type": "track", "unit": "unit", "version": "072ab9c2faf33c9ea3532454c71b53e4489172eb72056407dd71026bfe576a46"}, "optimize_linprog.Netlib.time_netlib": {"code": "class Netlib:\n    def time_netlib(self, meth, prob):\n        method, options = meth\n        res = linprog(c=self.c,\n                      A_ub=self.A_ub,\n                      b_ub=self.b_ub,\n                      A_eq=self.A_eq,\n                      b_eq=self.b_eq,\n                      bounds=self.bounds,\n                      method=method,\n                      options=options)\n        self.fun = res.fun\n\n    def setup(self, meth, prob):\n        if prob not in enabled_problems:\n            raise NotImplementedError(\"skipped\")\n    \n        dir_path = os.path.dirname(os.path.realpath(__file__))\n        datafile = os.path.join(dir_path, \"linprog_benchmark_files\",\n                                prob + \".npz\")\n        data = np.load(datafile, allow_pickle=True)\n        self.c = data[\"c\"]\n        self.A_eq = data[\"A_eq\"]\n        self.A_ub = data[\"A_ub\"]\n        self.b_ub = data[\"b_ub\"]\n        self.b_eq = data[\"b_eq\"]\n        self.bounds = np.squeeze(data[\"bounds\"])\n        self.obj = float(data[\"obj\"].flatten()[0])\n        self.fun = None", "min_run_count": 2, "name": "optimize_linprog.Netlib.time_netlib", "number": 0, "param_names": ["method", "problems"], "params": [["('highs-ipm', {})", "('highs-ds', {})"], ["'25FV47'", "'80BAU3B'", "'ADLITTLE'", "'AFIRO'", "'AGG'", "'AGG2'", "'AGG3'", "'BANDM'", "'BEACONFD'", "'BLEND'", "'BNL1'", "'BNL2'", "'BORE3D'", "'BRANDY'", "'CAPRI'", "'CYCLE'", "'CZPROB'", "'D2Q06C'", "'D6CUBE'", "'DEGEN2'", "'DEGEN3'", "'DFL001'", "'E226'", "'ETAMACRO'", "'FFFFF800'", "'FINNIS'", "'FIT1D'", "'FIT1P'", "'FIT2D'", "'FIT2P'", "'GANGES'", "'GFRD-PNC'", "'GREENBEA'", "'GREENBEB'", "'GROW15'", "'GROW22'", "'GROW7'", "'ISRAEL'", "'KB2'", "'LOTFI'", "'MAROS'", "'MAROS-R7'", "'MODSZK1'", "'PEROLD'", "'PILOT'", "'PILOT4'", "'PILOT87'", "'PILOT-JA'", "'PILOTNOV'", "'PILOT-WE'", "'QAP8'", "'QAP12'", "'QAP15'", "'RECIPE'", "'SC105'", "'SC205'", "'SC50A'", "'SC50B'", "'SCAGR25'", "'SCAGR7'", "'SCFXM1'", "'SCFXM2'", "'SCFXM3'", "'SCORPION'", "'SCRS8'", "'SCSD1'", "'SCSD6'", "'SCSD8'", "'SCTAP1'", "'SCTAP2'", "'SCTAP3'", "'SHARE1B'", "'SHARE2B'", "'SHELL'", "'SHIP04L'", "'SHIP04S'", "'SHIP08L'", "'SHIP08S'", "'SHIP12L'", "'SHIP12S'", "'SIERRA'", "'STAIR'", "'STANDATA'", "'STANDMPS'", "'STOCFOR1'", "'STOCFOR2'", "'STOCFOR3'", "'TRUSS'", "'TUFF'", "'VTP-BASE'", "'WOOD1P'", "'WOODW'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0f8db47357a83308585eabf9bcd253727c0983fedb1679bd79a7fcbbd98b50c0", "warmup_time": -1}, "optimize_linprog.Netlib.track_netlib": {"code": "class Netlib:\n    def track_netlib(self, meth, prob):\n        if self.fun is None:\n            self.time_netlib(meth, prob)\n        self.abs_error = np.abs(self.fun - self.obj)\n        self.rel_error = np.abs((self.fun - self.obj)/self.obj)\n        return min(self.abs_error, self.rel_error)\n\n    def setup(self, meth, prob):\n        if prob not in enabled_problems:\n            raise NotImplementedError(\"skipped\")\n    \n        dir_path = os.path.dirname(os.path.realpath(__file__))\n        datafile = os.path.join(dir_path, \"linprog_benchmark_files\",\n                                prob + \".npz\")\n        data = np.load(datafile, allow_pickle=True)\n        self.c = data[\"c\"]\n        self.A_eq = data[\"A_eq\"]\n        self.A_ub = data[\"A_ub\"]\n        self.b_ub = data[\"b_ub\"]\n        self.b_eq = data[\"b_eq\"]\n        self.bounds = np.squeeze(data[\"bounds\"])\n        self.obj = float(data[\"obj\"].flatten()[0])\n        self.fun = None", "name": "optimize_linprog.Netlib.track_netlib", "param_names": ["method", "problems"], "params": [["('highs-ipm', {})", "('highs-ds', {})"], ["'25FV47'", "'80BAU3B'", "'ADLITTLE'", "'AFIRO'", "'AGG'", "'AGG2'", "'AGG3'", "'BANDM'", "'BEACONFD'", "'BLEND'", "'BNL1'", "'BNL2'", "'BORE3D'", "'BRANDY'", "'CAPRI'", "'CYCLE'", "'CZPROB'", "'D2Q06C'", "'D6CUBE'", "'DEGEN2'", "'DEGEN3'", "'DFL001'", "'E226'", "'ETAMACRO'", "'FFFFF800'", "'FINNIS'", "'FIT1D'", "'FIT1P'", "'FIT2D'", "'FIT2P'", "'GANGES'", "'GFRD-PNC'", "'GREENBEA'", "'GREENBEB'", "'GROW15'", "'GROW22'", "'GROW7'", "'ISRAEL'", "'KB2'", "'LOTFI'", "'MAROS'", "'MAROS-R7'", "'MODSZK1'", "'PEROLD'", "'PILOT'", "'PILOT4'", "'PILOT87'", "'PILOT-JA'", "'PILOTNOV'", "'PILOT-WE'", "'QAP8'", "'QAP12'", "'QAP15'", "'RECIPE'", "'SC105'", "'SC205'", "'SC50A'", "'SC50B'", "'SCAGR25'", "'SCAGR7'", "'SCFXM1'", "'SCFXM2'", "'SCFXM3'", "'SCORPION'", "'SCRS8'", "'SCSD1'", "'SCSD6'", "'SCSD8'", "'SCTAP1'", "'SCTAP2'", "'SCTAP3'", "'SHARE1B'", "'SHARE2B'", "'SHELL'", "'SHIP04L'", "'SHIP04S'", "'SHIP08L'", "'SHIP08S'", "'SHIP12L'", "'SHIP12S'", "'SIERRA'", "'STAIR'", "'STANDATA'", "'STANDMPS'", "'STOCFOR1'", "'STOCFOR2'", "'STOCFOR3'", "'TRUSS'", "'TUFF'", "'VTP-BASE'", "'WOOD1P'", "'WOODW'"]], "timeout": 60.0, "type": "track", "unit": "unit", "version": "befe1a7a33447935ad3d650fd130dc2fc23eb5db0f4181621556a468b07bec42"}, "optimize_linprog.Netlib_infeasible.time_netlib_infeasible": {"code": "class Netlib_infeasible:\n    def time_netlib_infeasible(self, meth, prob):\n        method, options = meth\n        res = linprog(c=self.c,\n                      A_ub=self.A_ub,\n                      b_ub=self.b_ub,\n                      A_eq=self.A_eq,\n                      b_eq=self.b_eq,\n                      bounds=self.bounds,\n                      method=method,\n                      options=options)\n        self.status = res.status\n\n    def setup(self, meth, prob):\n        if prob not in enabled_infeasible_problems:\n            raise NotImplementedError(\"skipped\")\n    \n        dir_path = os.path.dirname(os.path.realpath(__file__))\n        datafile = os.path.join(dir_path, \"linprog_benchmark_files\",\n                                \"infeasible\", prob + \".npz\")\n        data = np.load(datafile, allow_pickle=True)\n        self.c = data[\"c\"]\n        self.A_eq = data[\"A_eq\"]\n        self.A_ub = data[\"A_ub\"]\n        self.b_ub = data[\"b_ub\"]\n        self.b_eq = data[\"b_eq\"]\n        self.bounds = np.squeeze(data[\"bounds\"])\n        self.status = None", "min_run_count": 2, "name": "optimize_linprog.Netlib_infeasible.time_netlib_infeasible", "number": 0, "param_names": ["method", "problems"], "params": [["('highs-ipm', {})", "('highs-ds', {})"], ["'bgdbg1'", "'bgetam'", "'bgindy'", "'bgprtr'", "'box1'", "'ceria3d'", "'chemcom'", "'cplex1'", "'cplex2'", "'ex72a'", "'ex73a'", "'forest6'", "'galenet'", "'gosh'", "'gran'", "'itest2'", "'itest6'", "'klein1'", "'klein2'", "'klein3'", "'mondou2'", "'pang'", "'pilot4i'", "'qual'", "'reactor'", "'refinery'", "'vol1'", "'woodinfe'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "234e7cd5d84acbf11f9592c780274124c4dd0e95221d1070d296c9be8c63fde2", "warmup_time": -1}, "optimize_linprog.Netlib_infeasible.track_netlib_infeasible": {"code": "class Netlib_infeasible:\n    def track_netlib_infeasible(self, meth, prob):\n        if self.status is None:\n            self.time_netlib_infeasible(meth, prob)\n        return self.status\n\n    def setup(self, meth, prob):\n        if prob not in enabled_infeasible_problems:\n            raise NotImplementedError(\"skipped\")\n    \n        dir_path = os.path.dirname(os.path.realpath(__file__))\n        datafile = os.path.join(dir_path, \"linprog_benchmark_files\",\n                                \"infeasible\", prob + \".npz\")\n        data = np.load(datafile, allow_pickle=True)\n        self.c = data[\"c\"]\n        self.A_eq = data[\"A_eq\"]\n        self.A_ub = data[\"A_ub\"]\n        self.b_ub = data[\"b_ub\"]\n        self.b_eq = data[\"b_eq\"]\n        self.bounds = np.squeeze(data[\"bounds\"])\n        self.status = None", "name": "optimize_linprog.Netlib_infeasible.track_netlib_infeasible", "param_names": ["method", "problems"], "params": [["('highs-ipm', {})", "('highs-ds', {})"], ["'bgdbg1'", "'bgetam'", "'bgindy'", "'bgprtr'", "'box1'", "'ceria3d'", "'chemcom'", "'cplex1'", "'cplex2'", "'ex72a'", "'ex73a'", "'forest6'", "'galenet'", "'gosh'", "'gran'", "'itest2'", "'itest6'", "'klein1'", "'klein2'", "'klein3'", "'mondou2'", "'pang'", "'pilot4i'", "'qual'", "'reactor'", "'refinery'", "'vol1'", "'woodinfe'"]], "timeout": 60.0, "type": "track", "unit": "unit", "version": "e850b6f6e316fd1bf5294dabbb3b89686f0bd67a92e7c4b77f898c8170cba67d"}, "optimize_milp.MilpMagicSquare.time_magic_square": {"code": "class MilpMagicSquare:\n    def time_magic_square(self, n):\n        res = milp(c=self.c*0, constraints=self.constraints,\n                   bounds=(0, 1), integrality=True)\n        assert res.status == 0\n        x = np.round(res.x)\n        s = (self.numbers.flatten() * x).reshape(n**2, n, n)\n        square = np.sum(s, axis=0)\n        assert_allclose(square.sum(axis=0), self.M)\n        assert_allclose(square.sum(axis=1), self.M)\n        assert_allclose(np.diag(square).sum(), self.M)\n        assert_allclose(np.diag(square[:, ::-1]).sum(), self.M)\n\n    def setup(self, n):\n        A_eq, b_eq, self.c, self.numbers, self.M = magic_square(n)\n        self.constraints = (A_eq, b_eq, b_eq)", "min_run_count": 2, "name": "optimize_milp.MilpMagicSquare.time_magic_square", "number": 0, "param_names": ["size"], "params": [["3", "4", "5", "6"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "45001f35848be1c530f4d4dbb23da4aaf938b4ed16f02516a846d7ca76f8e59a", "warmup_time": -1}, "optimize_milp.MilpMiplibBenchmarks.time_milp": {"code": "class MilpMiplibBenchmarks:\n    def time_milp(self, prob):\n        res = milp(c=self.c, constraints=self.constraints, bounds=self.bounds,\n                   integrality=self.integrality)\n        assert res.success\n\n    def setup(self, prob):\n        if not hasattr(self, 'data'):\n            dir_path = os.path.dirname(os.path.realpath(__file__))\n            datafile = os.path.join(dir_path, \"linprog_benchmark_files\",\n                                    \"milp_benchmarks.npz\")\n            self.data = np.load(datafile, allow_pickle=True)\n    \n        c, A_ub, b_ub, A_eq, b_eq, bounds, integrality = self.data[prob]\n    \n        lb = [li for li, ui in bounds]\n        ub = [ui for li, ui in bounds]\n    \n        cons = []\n        if A_ub is not None:\n            cons.append((A_ub, -np.inf, b_ub))\n        if A_eq is not None:\n            cons.append((A_eq, b_eq, b_eq))\n    \n        self.c = c\n        self.constraints = cons\n        self.bounds = (lb, ub)\n        self.integrality = integrality", "min_run_count": 2, "name": "optimize_milp.MilpMiplibBenchmarks.time_milp", "number": 0, "param_names": ["problem"], "params": [["'piperout-27'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "768f84f9719db25c0a8ad7c565843bda06ffff5ce5d51520a8039b0bd6e76654", "warmup_time": -1}, "optimize_qap.QuadraticAssignment.time_evaluation": {"code": "class QuadraticAssignment:\n    def time_evaluation(self, method, qap_prob):\n        quadratic_assignment(self.A, self.B, self.method)\n\n    def setup(self, method, qap_prob):\n        dir_path = os.path.dirname(os.path.realpath(__file__))\n        datafile = np.load(os.path.join(dir_path, \"qapdata/qap_probs.npz\"),\n                           allow_pickle=True)\n        slnfile = np.load(os.path.join(dir_path, \"qapdata/qap_sols.npz\"),\n                          allow_pickle=True)\n        self.A = datafile[qap_prob][0]\n        self.B = datafile[qap_prob][1]\n        self.opt_solution = slnfile[qap_prob]\n        self.method = method", "min_run_count": 2, "name": "optimize_qap.QuadraticAssignment.time_evaluation", "number": 0, "param_names": ["Method", "QAP Problem"], "params": [["'faq'", "'2opt'"], ["'bur26a'", "'bur26b'", "'bur26c'", "'bur26d'", "'bur26e'", "'bur26f'", "'bur26g'", "'bur26h'", "'chr12a'", "'chr12b'", "'chr12c'", "'chr15a'", "'chr15b'", "'chr15c'", "'chr18a'", "'chr18b'", "'chr20a'", "'chr20b'", "'chr20c'", "'chr22a'", "'chr22b'", "'chr25a'", "'els19'", "'esc16a'", "'esc16b'", "'esc16c'", "'esc16d'", "'esc16e'", "'esc16g'", "'esc16h'", "'esc16i'", "'esc16j'", "'esc32e'", "'esc32g'", "'esc128'", "'had12'", "'had14'", "'had16'", "'had18'", "'had20'", "'kra30a'", "'kra30b'", "'kra32'", "'lipa20a'", "'lipa20b'", "'lipa30a'", "'lipa30b'", "'lipa40a'", "'lipa40b'", "'lipa50a'", "'lipa50b'", "'lipa60a'", "'lipa60b'", "'lipa70a'", "'lipa70b'", "'lipa80a'", "'lipa90a'", "'lipa90b'", "'nug12'", "'nug14'", "'nug16a'", "'nug16b'", "'nug17'", "'nug18'", "'nug20'", "'nug21'", "'nug22'", "'nug24'", "'nug25'", "'nug27'", "'nug28'", "'nug30'", "'rou12'", "'rou15'", "'rou20'", "'scr12'", "'scr15'", "'scr20'", "'sko42'", "'sko49'", "'sko56'", "'sko64'", "'sko72'", "'sko81'", "'sko90'", "'sko100a'", "'sko100b'", "'sko100c'", "'sko100d'", "'sko100e'", "'sko100f'", "'ste36b'", "'ste36c'", "'tai12a'", "'tai12b'", "'tai15a'", "'tai15b'", "'tai17a'", "'tai20a'", "'tai20b'", "'tai25a'", "'tai25b'", "'tai30a'", "'tai30b'", "'tai35a'", "'tai40a'", "'tai40b'", "'tai50a'", "'tai50b'", "'tai60a'", "'tai60b'", "'tai64c'", "'tai80a'", "'tai100a'", "'tai100b'", "'tai150b'", "'tai256c'", "'tho30'", "'tho40'", "'tho150'", "'wil50'", "'wil100'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c0a8e360f79b16ca85ddf8a2d090b72de71d8dd6c04c5ff2c090f39c0469bbb6", "warmup_time": -1}, "optimize_qap.QuadraticAssignment.track_score": {"code": "class QuadraticAssignment:\n    def track_score(self, method, qap_prob):\n        res = quadratic_assignment(self.A, self.B, self.method)\n        score = int(res['fun'])\n        percent_diff = (score - self.opt_solution) / self.opt_solution\n        return percent_diff\n\n    def setup(self, method, qap_prob):\n        dir_path = os.path.dirname(os.path.realpath(__file__))\n        datafile = np.load(os.path.join(dir_path, \"qapdata/qap_probs.npz\"),\n                           allow_pickle=True)\n        slnfile = np.load(os.path.join(dir_path, \"qapdata/qap_sols.npz\"),\n                          allow_pickle=True)\n        self.A = datafile[qap_prob][0]\n        self.B = datafile[qap_prob][1]\n        self.opt_solution = slnfile[qap_prob]\n        self.method = method", "name": "optimize_qap.QuadraticAssignment.track_score", "param_names": ["Method", "QAP Problem"], "params": [["'faq'", "'2opt'"], ["'bur26a'", "'bur26b'", "'bur26c'", "'bur26d'", "'bur26e'", "'bur26f'", "'bur26g'", "'bur26h'", "'chr12a'", "'chr12b'", "'chr12c'", "'chr15a'", "'chr15b'", "'chr15c'", "'chr18a'", "'chr18b'", "'chr20a'", "'chr20b'", "'chr20c'", "'chr22a'", "'chr22b'", "'chr25a'", "'els19'", "'esc16a'", "'esc16b'", "'esc16c'", "'esc16d'", "'esc16e'", "'esc16g'", "'esc16h'", "'esc16i'", "'esc16j'", "'esc32e'", "'esc32g'", "'esc128'", "'had12'", "'had14'", "'had16'", "'had18'", "'had20'", "'kra30a'", "'kra30b'", "'kra32'", "'lipa20a'", "'lipa20b'", "'lipa30a'", "'lipa30b'", "'lipa40a'", "'lipa40b'", "'lipa50a'", "'lipa50b'", "'lipa60a'", "'lipa60b'", "'lipa70a'", "'lipa70b'", "'lipa80a'", "'lipa90a'", "'lipa90b'", "'nug12'", "'nug14'", "'nug16a'", "'nug16b'", "'nug17'", "'nug18'", "'nug20'", "'nug21'", "'nug22'", "'nug24'", "'nug25'", "'nug27'", "'nug28'", "'nug30'", "'rou12'", "'rou15'", "'rou20'", "'scr12'", "'scr15'", "'scr20'", "'sko42'", "'sko49'", "'sko56'", "'sko64'", "'sko72'", "'sko81'", "'sko90'", "'sko100a'", "'sko100b'", "'sko100c'", "'sko100d'", "'sko100e'", "'sko100f'", "'ste36b'", "'ste36c'", "'tai12a'", "'tai12b'", "'tai15a'", "'tai15b'", "'tai17a'", "'tai20a'", "'tai20b'", "'tai25a'", "'tai25b'", "'tai30a'", "'tai30b'", "'tai35a'", "'tai40a'", "'tai40b'", "'tai50a'", "'tai50b'", "'tai60a'", "'tai60b'", "'tai64c'", "'tai80a'", "'tai100a'", "'tai100b'", "'tai150b'", "'tai256c'", "'tho30'", "'tho40'", "'tho150'", "'wil50'", "'wil100'"]], "timeout": 60.0, "type": "track", "unit": "unit", "version": "1c3a31da291b33b9e2a8136e0427f40e80e3cf63ac9508e5d5249c5c058a3cd1"}, "optimize_zeros.Newton.time_newton": {"code": "class Newton:\n    def time_newton(self, func, meth):\n        newton(self.f, self.x0, args=(), fprime=self.f_1, fprime2=self.f_2)\n\n    def setup(self, func, meth):\n        self.x0 = 3\n        self.f_1 = None\n        self.f_2 = None\n        if func == 'f1':\n            self.f = lambda x: x ** 2 - 2 * x - 1\n            if meth in ('newton', 'halley'):\n                self.f_1 = lambda x: 2 * x - 2\n            if meth == 'halley':\n                self.f_2 = lambda x: 2.0 + 0 * x\n        else:\n            self.f = lambda x: exp(x) - cos(x)\n            if meth in ('newton', 'halley'):\n                self.f_1 = lambda x: exp(x) + sin(x)\n            if meth == 'halley':\n                self.f_2 = lambda x: exp(x) + cos(x)", "min_run_count": 2, "name": "optimize_zeros.Newton.time_newton", "number": 0, "param_names": ["test function", "solver"], "params": [["'f1'", "'f2'"], ["'newton'", "'secant'", "'halley'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2c7e7c8c9002fcceb6a5f95ad638eb0f73720bf302d480fa391416abc5f6dfc9", "warmup_time": -1}, "optimize_zeros.NewtonArray.time_array_newton": {"code": "class NewtonArray:\n    def time_array_newton(self, vec, meth):\n    \n        def f(x, *a):\n            b = a[0] + x * a[3]\n            return a[1] - a[2] * (np.exp(b / a[5]) - 1.0) - b / a[4] - x\n    \n        def f_1(x, *a):\n            b = a[3] / a[5]\n            return -a[2] * np.exp(a[0] / a[5] + x * b) * b - a[3] / a[4] - 1\n    \n        def f_2(x, *a):\n            b = a[3] / a[5]\n            return -a[2] * np.exp(a[0] / a[5] + x * b) * b ** 2\n    \n        a0 = np.array([\n            5.32725221, 5.48673747, 5.49539973,\n            5.36387202, 4.80237316, 1.43764452,\n            5.23063958, 5.46094772, 5.50512718,\n            5.42046290\n        ])\n        a1 = (np.sin(range(10)) + 1.0) * 7.0\n        args = (a0, a1, 1e-09, 0.004, 10, 0.27456)\n        x0 = [7.0] * 10\n        self.fvec(f, x0, args=args, fprime=f_1, fprime2=f_2)\n\n    def setup(self, vec, meth):\n        if vec == 'loop':\n            if meth == 'newton':\n                self.fvec = lambda f, x0, args, fprime, fprime2: [\n                    newton(f, x, args=(a0, a1) + args[2:], fprime=fprime)\n                    for (x, a0, a1) in zip(x0, args[0], args[1])\n                ]\n            elif meth == 'halley':\n                self.fvec = lambda f, x0, args, fprime, fprime2: [\n                    newton(\n                        f, x, args=(a0, a1) + args[2:], fprime=fprime,\n                        fprime2=fprime2\n                    ) for (x, a0, a1) in zip(x0, args[0], args[1])\n                ]\n            else:\n                self.fvec = lambda f, x0, args, fprime, fprime2: [\n                    newton(f, x, args=(a0, a1) + args[2:]) for (x, a0, a1)\n                    in zip(x0, args[0], args[1])\n                ]\n        else:\n            if meth == 'newton':\n                self.fvec = lambda f, x0, args, fprime, fprime2: newton(\n                    f, x0, args=args, fprime=fprime\n                )\n            elif meth == 'halley':\n                self.fvec = newton\n            else:\n                self.fvec = lambda f, x0, args, fprime, fprime2: newton(\n                    f, x0, args=args\n                )", "min_run_count": 2, "name": "optimize_zeros.NewtonArray.time_array_newton", "number": 0, "param_names": ["vectorization", "solver"], "params": [["'loop'", "'array'"], ["'newton'", "'secant'", "'halley'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "08e3d8401f54536bbfe96c467755557f8ebe99ce10bf63de17e8fe5d7229bf4d", "warmup_time": -1}, "optimize_zeros.Zeros.time_zeros": {"code": "class Zeros:\n    def time_zeros(self, func, meth):\n        self.meth(self.func, self.a, self.b)\n\n    def setup(self, func, meth):\n        self.a = .5\n        self.b = sqrt(3)\n    \n        self.func = functions[fstrings.index(func)]\n        self.meth = methods[mstrings.index(meth)]", "min_run_count": 2, "name": "optimize_zeros.Zeros.time_zeros", "number": 0, "param_names": ["test function", "solver"], "params": [["'f2'", "'f3'", "'f4'", "'f5'", "'f6'"], ["'cc.bisect'", "'cc.ridder'", "'cc.brenth'", "'cc.brentq'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e70efd439f371e19964039ab8d954254811da7754783c41cc71759ad0f59e24a", "warmup_time": -1}, "peak_finding.FindPeaks.time_find_peaks": {"code": "class FindPeaks:\n    def time_find_peaks(self, distance):\n        find_peaks(self.x, distance=distance)\n\n    def setup(self, distance):\n        self.x = electrocardiogram()", "min_run_count": 2, "name": "peak_finding.FindPeaks.time_find_peaks", "number": 0, "param_names": ["distance"], "params": [["None", "8", "64", "512", "4096"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "69a82ba1236f6512a03a49fd386938b5f04df15b93f34eb5ac9b6b08a86e66e0", "warmup_time": -1}, "peak_finding.PeakProminences.time_peak_prominences": {"code": "class PeakProminences:\n    def time_peak_prominences(self, wlen):\n        peak_prominences(self.x, self.peaks, wlen)\n\n    def setup(self, wlen):\n        self.x = electrocardiogram()\n        self.peaks = find_peaks(self.x)[0]", "min_run_count": 2, "name": "peak_finding.PeakProminences.time_peak_prominences", "number": 0, "param_names": ["wlen"], "params": [["None", "8", "64", "512", "4096"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "76d52d7d796caad16fcd0900dc178ef04ea504a0d89c87ce861cc44808ee06d5", "warmup_time": -1}, "peak_finding.PeakWidths.time_peak_widths": {"code": "class PeakWidths:\n    def time_peak_widths(self, rel_height):\n        peak_widths(self.x, self.peaks, rel_height, self.prominence_data)\n\n    def setup(self, rel_height):\n        self.x = electrocardiogram()\n        self.peaks = find_peaks(self.x)[0]\n        self.prominence_data = peak_prominences(self.x, self.peaks)", "min_run_count": 2, "name": "peak_finding.PeakWidths.time_peak_widths", "number": 0, "param_names": ["rel_height"], "params": [["0", "0.25", "0.5", "0.75", "1"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "775a3e41b71d89f5c58cb2d36b19adaac830d6f9e21b6fa4b82f3bfc67dca1d3", "warmup_time": -1}, "signal.CalculateWindowedFFT.time_coherence": {"code": "class CalculateWindowedFFT:\n    def time_coherence(self):\n        signal.coherence(self.x, self.y)\n\n    def setup(self):\n        rng = np.random.default_rng(5678)\n        # Create some long arrays for computation\n        x = rng.standard_normal(2**20)\n        y = rng.standard_normal(2**20)\n        self.x = x\n        self.y = y", "min_run_count": 2, "name": "signal.CalculateWindowedFFT.time_coherence", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b5b89dc302836518ac4ab690b2537988209532d2d9d0670fe0adbdcd4a02f2cd", "warmup_time": -1}, "signal.CalculateWindowedFFT.time_csd": {"code": "class CalculateWindowedFFT:\n    def time_csd(self):\n        signal.csd(self.x, self.y)\n\n    def setup(self):\n        rng = np.random.default_rng(5678)\n        # Create some long arrays for computation\n        x = rng.standard_normal(2**20)\n        y = rng.standard_normal(2**20)\n        self.x = x\n        self.y = y", "min_run_count": 2, "name": "signal.CalculateWindowedFFT.time_csd", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c89e5cd1dd045c07ac9bbd03f78625d781b370388aab969e273032813a67b784", "warmup_time": -1}, "signal.CalculateWindowedFFT.time_periodogram": {"code": "class CalculateWindowedFFT:\n    def time_periodogram(self):\n        signal.periodogram(self.x)\n\n    def setup(self):\n        rng = np.random.default_rng(5678)\n        # Create some long arrays for computation\n        x = rng.standard_normal(2**20)\n        y = rng.standard_normal(2**20)\n        self.x = x\n        self.y = y", "min_run_count": 2, "name": "signal.CalculateWindowedFFT.time_periodogram", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3d3c1c1a17488e62907d9f29b770dce85ab631891f83e4e9bd99a94abdd51391", "warmup_time": -1}, "signal.CalculateWindowedFFT.time_spectrogram": {"code": "class CalculateWindowedFFT:\n    def time_spectrogram(self):\n        signal.spectrogram(self.x)\n\n    def setup(self):\n        rng = np.random.default_rng(5678)\n        # Create some long arrays for computation\n        x = rng.standard_normal(2**20)\n        y = rng.standard_normal(2**20)\n        self.x = x\n        self.y = y", "min_run_count": 2, "name": "signal.CalculateWindowedFFT.time_spectrogram", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d0a62671bdf6e28a932f7bd15a42819cbe20774845e94ffc750713b2a28e09a3", "warmup_time": -1}, "signal.CalculateWindowedFFT.time_welch": {"code": "class CalculateWindowedFFT:\n    def time_welch(self):\n        signal.welch(self.x)\n\n    def setup(self):\n        rng = np.random.default_rng(5678)\n        # Create some long arrays for computation\n        x = rng.standard_normal(2**20)\n        y = rng.standard_normal(2**20)\n        self.x = x\n        self.y = y", "min_run_count": 2, "name": "signal.CalculateWindowedFFT.time_welch", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "daa91143320a4233ad72fdca42b389e83e691a2fef5218936e4a0ac290f09d9b", "warmup_time": -1}, "signal.Convolve.time_convolve": {"code": "class Convolve:\n    def time_convolve(self, mode):\n        for a, b in self.pairs['1d']:\n            if b.shape[0] > a.shape[0]:\n                continue\n            signal.convolve(a, b, mode=mode)\n\n    def setup(self, mode):\n        rng = np.random.default_rng(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = {'1d': [], '2d': []}\n        for ma, nb in product((1, 2, 8, 13, 30, 36, 50, 75), repeat=2):\n            a = rng.standard_normal(ma)\n            b = rng.standard_normal(nb)\n            pairs['1d'].append((a, b))\n    \n        for n_image in [256, 512, 1024]:\n            for n_kernel in [3, 5, 7]:\n                x = rng.standard_normal((n_image, n_image))\n                h = rng.standard_normal((n_kernel, n_kernel))\n                pairs['2d'].append((x, h))\n        self.pairs = pairs", "min_run_count": 2, "name": "signal.Convolve.time_convolve", "number": 0, "param_names": ["mode"], "params": [["'full'", "'valid'", "'same'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9a604ce6bb1a6efab49ac946799ae0eb0144c464b1fac826c5818eeff8536f60", "warmup_time": -1}, "signal.Convolve.time_convolve2d": {"code": "class Convolve:\n    def time_convolve2d(self, mode):\n        for a, b in self.pairs['2d']:\n            if mode == 'valid':\n                if b.shape[0] > a.shape[0] or b.shape[1] > a.shape[1]:\n                    continue\n            signal.convolve(a, b, mode=mode)\n\n    def setup(self, mode):\n        rng = np.random.default_rng(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = {'1d': [], '2d': []}\n        for ma, nb in product((1, 2, 8, 13, 30, 36, 50, 75), repeat=2):\n            a = rng.standard_normal(ma)\n            b = rng.standard_normal(nb)\n            pairs['1d'].append((a, b))\n    \n        for n_image in [256, 512, 1024]:\n            for n_kernel in [3, 5, 7]:\n                x = rng.standard_normal((n_image, n_image))\n                h = rng.standard_normal((n_kernel, n_kernel))\n                pairs['2d'].append((x, h))\n        self.pairs = pairs", "min_run_count": 2, "name": "signal.Convolve.time_convolve2d", "number": 0, "param_names": ["mode"], "params": [["'full'", "'valid'", "'same'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5e0849552506b05a43ec95654bd3cea40a9df558c08442ea37e3b4804f7229d7", "warmup_time": -1}, "signal.Convolve.time_correlate": {"code": "class Convolve:\n    def time_correlate(self, mode):\n        for a, b in self.pairs['1d']:\n            if b.shape[0] > a.shape[0]:\n                continue\n            signal.correlate(a, b, mode=mode)\n\n    def setup(self, mode):\n        rng = np.random.default_rng(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = {'1d': [], '2d': []}\n        for ma, nb in product((1, 2, 8, 13, 30, 36, 50, 75), repeat=2):\n            a = rng.standard_normal(ma)\n            b = rng.standard_normal(nb)\n            pairs['1d'].append((a, b))\n    \n        for n_image in [256, 512, 1024]:\n            for n_kernel in [3, 5, 7]:\n                x = rng.standard_normal((n_image, n_image))\n                h = rng.standard_normal((n_kernel, n_kernel))\n                pairs['2d'].append((x, h))\n        self.pairs = pairs", "min_run_count": 2, "name": "signal.Convolve.time_correlate", "number": 0, "param_names": ["mode"], "params": [["'full'", "'valid'", "'same'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5d9c0895dde23c8e886d1820debeedc5dde5992ce2d91544fc9caecc8b6a4aac", "warmup_time": -1}, "signal.Convolve.time_correlate2d": {"code": "class Convolve:\n    def time_correlate2d(self, mode):\n        for a, b in self.pairs['2d']:\n            if mode == 'valid':\n                if b.shape[0] > a.shape[0] or b.shape[1] > a.shape[1]:\n                    continue\n            signal.correlate(a, b, mode=mode)\n\n    def setup(self, mode):\n        rng = np.random.default_rng(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = {'1d': [], '2d': []}\n        for ma, nb in product((1, 2, 8, 13, 30, 36, 50, 75), repeat=2):\n            a = rng.standard_normal(ma)\n            b = rng.standard_normal(nb)\n            pairs['1d'].append((a, b))\n    \n        for n_image in [256, 512, 1024]:\n            for n_kernel in [3, 5, 7]:\n                x = rng.standard_normal((n_image, n_image))\n                h = rng.standard_normal((n_kernel, n_kernel))\n                pairs['2d'].append((x, h))\n        self.pairs = pairs", "min_run_count": 2, "name": "signal.Convolve.time_correlate2d", "number": 0, "param_names": ["mode"], "params": [["'full'", "'valid'", "'same'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "717039ec5b96390dfae03a686bda830089363bcdb077443097fb948ae853718c", "warmup_time": -1}, "signal.Convolve2D.time_convolve2d": {"code": "class Convolve2D:\n    def time_convolve2d(self, mode, boundary):\n        for a, b in self.pairs:\n            if mode == 'valid':\n                if b.shape[0] > a.shape[0] or b.shape[1] > a.shape[1]:\n                    continue\n            signal.convolve2d(a, b, mode=mode, boundary=boundary)\n\n    def setup(self, mode, boundary):\n        rng = np.random.default_rng(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = []\n        for ma, na, mb, nb in product((8, 13, 30, 36), repeat=4):\n            a = rng.standard_normal((ma, na))\n            b = rng.standard_normal((mb, nb))\n            pairs.append((a, b))\n        self.pairs = pairs", "min_run_count": 2, "name": "signal.Convolve2D.time_convolve2d", "number": 0, "param_names": ["mode", "boundary"], "params": [["'full'", "'valid'", "'same'"], ["'fill'", "'wrap'", "'symm'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c5e519d911faf6683f81120d12e6e8eef18fe251024f30fe9ba8b162b9dbee13", "warmup_time": -1}, "signal.Convolve2D.time_correlate2d": {"code": "class Convolve2D:\n    def time_correlate2d(self, mode, boundary):\n        for a, b in self.pairs:\n            if mode == 'valid':\n                if b.shape[0] > a.shape[0] or b.shape[1] > a.shape[1]:\n                    continue\n            signal.correlate2d(a, b, mode=mode, boundary=boundary)\n\n    def setup(self, mode, boundary):\n        rng = np.random.default_rng(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = []\n        for ma, na, mb, nb in product((8, 13, 30, 36), repeat=4):\n            a = rng.standard_normal((ma, na))\n            b = rng.standard_normal((mb, nb))\n            pairs.append((a, b))\n        self.pairs = pairs", "min_run_count": 2, "name": "signal.Convolve2D.time_correlate2d", "number": 0, "param_names": ["mode", "boundary"], "params": [["'full'", "'valid'", "'same'"], ["'fill'", "'wrap'", "'symm'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "39438d7ee277f5ffcc5a9a72f76648fc570ee59cb4395f9717f74c3df3a19feb", "warmup_time": -1}, "signal.FFTConvolve.time_convolve2d": {"code": "class FFTConvolve:\n    def time_convolve2d(self, mode, size):\n        signal.fftconvolve(self.a, self.b, mode=mode)\n\n    def setup(self, mode, size):\n        rng = np.random.default_rng(1234)\n        self.a = rng.standard_normal(size[0])\n        self.b = rng.standard_normal(size[1])", "min_run_count": 2, "name": "signal.FFTConvolve.time_convolve2d", "number": 0, "param_names": ["mode", "size"], "params": [["'full'", "'valid'", "'same'"], ["(1, 1)", "(2, 1)", "(2, 2)", "(8, 1)", "(8, 2)", "(8, 8)", "(36, 1)", "(36, 2)", "(36, 8)", "(36, 36)", "(60, 1)", "(60, 2)", "(60, 8)", "(60, 36)", "(60, 60)", "(150, 1)", "(150, 2)", "(150, 8)", "(150, 36)", "(150, 60)", "(150, 150)", "(200, 1)", "(200, 2)", "(200, 8)", "(200, 36)", "(200, 60)", "(200, 150)", "(200, 200)", "(500, 1)", "(500, 2)", "(500, 8)", "(500, 36)", "(500, 60)", "(500, 150)", "(500, 200)", "(500, 500)"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "dce62910a489dc15af038ccccc437229eedbcba0f6285abdf3ab404c3bf6e712", "warmup_time": -1}, "signal.FIRLS.time_firls": {"code": "class FIRLS:\n    def time_firls(self, n, edges):\n        signal.firls(n, (0,) + edges + (1,), [1, 1, 0, 0])", "min_run_count": 2, "name": "signal.FIRLS.time_firls", "number": 0, "param_names": ["n", "edges"], "params": [["21", "101", "1001", "2001"], ["(0.1, 0.9)", "(0.01, 0.99)"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2f5dd858f18576cf308f8bd907d6a2ba6ac434e7e9e60212a00b6adb24baa7f4", "warmup_time": -1}, "signal.LTI.time_bode": {"code": "class LTI:\n    def time_bode(self):\n        signal.bode(self.system)\n\n    def setup(self):\n        self.system = signal.lti(1.0, [1, 0, 1])\n        self.t = np.arange(0, 100, 0.5)\n        self.u = np.sin(2 * self.t)", "min_run_count": 2, "name": "signal.LTI.time_bode", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9b6900694dcd1678ace232e739006f5edb8fd1ab439b2641c656a52a6a3570a5", "warmup_time": -1}, "signal.LTI.time_impulse": {"code": "class LTI:\n    def time_impulse(self):\n        signal.impulse(self.system, T=self.t)\n\n    def setup(self):\n        self.system = signal.lti(1.0, [1, 0, 1])\n        self.t = np.arange(0, 100, 0.5)\n        self.u = np.sin(2 * self.t)", "min_run_count": 2, "name": "signal.LTI.time_impulse", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "36ed9a1159c7a7896d49780e31bf765fedd30ff0e5170d6f5a90d31286ffdd04", "warmup_time": -1}, "signal.LTI.time_lsim": {"code": "class LTI:\n    def time_lsim(self):\n        signal.lsim(self.system, self.u, self.t)\n\n    def setup(self):\n        self.system = signal.lti(1.0, [1, 0, 1])\n        self.t = np.arange(0, 100, 0.5)\n        self.u = np.sin(2 * self.t)", "min_run_count": 2, "name": "signal.LTI.time_lsim", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ab2f127be1b0ae823db19367021a5a82ca4d3f9b41c29574f98efb3a4a9a48cc", "warmup_time": -1}, "signal.LTI.time_lsim2": {"code": "class LTI:\n    def time_lsim2(self):\n        signal.lsim2(self.system, self.u, self.t)\n\n    def setup(self):\n        self.system = signal.lti(1.0, [1, 0, 1])\n        self.t = np.arange(0, 100, 0.5)\n        self.u = np.sin(2 * self.t)", "min_run_count": 2, "name": "signal.LTI.time_lsim2", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5d54047fba8c4fd772104b076d52ba13045b21326e50ea9124871ff3a3924b6e", "warmup_time": -1}, "signal.LTI.time_step": {"code": "class LTI:\n    def time_step(self):\n        signal.step(self.system, T=self.t)\n\n    def setup(self):\n        self.system = signal.lti(1.0, [1, 0, 1])\n        self.t = np.arange(0, 100, 0.5)\n        self.u = np.sin(2 * self.t)", "min_run_count": 2, "name": "signal.LTI.time_step", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "02de19e2a7d49a4b5349af8a4765271980b219a4c890120b26195f0cae2578c4", "warmup_time": -1}, "signal.OAConvolve.time_convolve2d": {"code": "class OAConvolve:\n    def time_convolve2d(self, mode, size):\n        signal.oaconvolve(self.a, self.b, mode=mode)\n\n    def setup(self, mode, size):\n        rng = np.random.default_rng(1234)\n        self.a = rng.standard_normal(size[0])\n        self.b = rng.standard_normal(size[1])", "min_run_count": 2, "name": "signal.OAConvolve.time_convolve2d", "number": 0, "param_names": ["mode", "size"], "params": [["'full'", "'valid'", "'same'"], ["(200, 40)", "(3000, 40)", "(3000, 200)"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8b7ebbd14f386a03f961eb0479943494c8b931b466ddf5756a139bb74ca6485f", "warmup_time": -1}, "signal.Resample.time_complex": {"code": "class Resample:\n    def time_complex(self, N, num):\n        signal.resample(self.y + 0j, num)\n\n    def setup(self, N, num):\n        x = np.linspace(0, 10, N, endpoint=False)\n        self.y = np.cos(-x**2/6.0)", "min_run_count": 2, "name": "signal.Resample.time_complex", "number": 0, "param_names": ["N", "num"], "params": [["977", "9973", "16384", "65536"], ["977", "9973", "16384", "65536"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "55c642f290bf16f0ff9e966c50e70d48705973f05959f5008075efe985777bd9", "warmup_time": -1}, "signal.Resample.time_real": {"code": "class Resample:\n    def time_real(self, N, num):\n        signal.resample(self.y, num)\n\n    def setup(self, N, num):\n        x = np.linspace(0, 10, N, endpoint=False)\n        self.y = np.cos(-x**2/6.0)", "min_run_count": 2, "name": "signal.Resample.time_real", "number": 0, "param_names": ["N", "num"], "params": [["977", "9973", "16384", "65536"], ["977", "9973", "16384", "65536"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5ab4afe1c564b74994385ce0419ea640e36628bce8d72e88b411126057acd53e", "warmup_time": -1}, "signal.Upfirdn1D.time_upfirdn1d": {"code": "class Upfirdn1D:\n    def time_upfirdn1d(self, up, down):\n        for h, x in self.pairs:\n            signal.upfirdn(h, x, up=up, down=down)\n\n    def setup(self, up, down):\n        rng = np.random.default_rng(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = []\n        for nfilt in [8, ]:\n            for n in [32, 128, 512, 2048]:\n                h = rng.standard_normal(nfilt)\n                x = rng.standard_normal(n)\n                pairs.append((h, x))\n    \n        self.pairs = pairs", "min_run_count": 2, "name": "signal.Upfirdn1D.time_upfirdn1d", "number": 0, "param_names": ["up", "down"], "params": [["1", "4"], ["1", "4"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "88d172db21725ae48f928235856cf9f60ea0dd66229e358cd5dcb0de723350da", "warmup_time": -1}, "signal.Upfirdn2D.time_upfirdn2d": {"code": "class Upfirdn2D:\n    def time_upfirdn2d(self, up, down, axis):\n        for h, x in self.pairs:\n            signal.upfirdn(h, x, up=up, down=down, axis=axis)\n\n    def setup(self, up, down, axis):\n        rng = np.random.default_rng(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = []\n        for nfilt in [8, ]:\n            for n in [32, 128, 512]:\n                h = rng.standard_normal(nfilt)\n                x = rng.standard_normal((n, n))\n                pairs.append((h, x))\n    \n        self.pairs = pairs", "min_run_count": 2, "name": "signal.Upfirdn2D.time_upfirdn2d", "number": 0, "param_names": ["up", "down", "axis"], "params": [["1", "4"], ["1", "4"], ["0", "-1"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "022a682b56e4d9ed03b3a000b20464bf483e08daf36fd4dc1e0d786d74e63a0e", "warmup_time": -1}, "signal_filtering.Decimate.time_decimate": {"code": "class Decimate:\n    def time_decimate(self, q, ftype, zero_phase):\n        decimate(self.sig, q, ftype=ftype, zero_phase=zero_phase)\n\n    def setup(self, q, ftype, zero_phase):\n        np.random.seed(123456)\n        sample_rate = 10000.\n        t = np.arange(int(1e6), dtype=np.float64) / sample_rate\n        self.sig = np.sin(2*np.pi*500*t) + 0.3 * np.sin(2*np.pi*4e3*t)", "min_run_count": 2, "name": "signal_filtering.Decimate.time_decimate", "number": 0, "param_names": ["q", "ftype", "zero_phase"], "params": [["2", "10", "30"], ["'iir'", "'fir'"], ["True", "False"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "aae23358cbe3088f5e199c70a09eec3957561c00aa278ce63bace7052f266e3f", "warmup_time": -1}, "signal_filtering.Lfilter.time_lfilter": {"code": "class Lfilter:\n    def time_lfilter(self, n_samples, numtaps):\n        lfilter(self.coeff, 1.0, self.sig)\n\n    def setup(self, n_samples, numtaps):\n        np.random.seed(125678)\n        sample_rate = 25000.\n        t = np.arange(n_samples, dtype=np.float64) / sample_rate\n        nyq_rate = sample_rate / 2.\n        cutoff_hz = 3000.0\n        self.sig = np.sin(2*np.pi*500*t) + 0.3 * np.sin(2*np.pi*11e3*t)\n        self.coeff = firwin(numtaps, cutoff_hz/nyq_rate)", "min_run_count": 2, "name": "signal_filtering.Lfilter.time_lfilter", "number": 0, "param_names": ["n_samples", "numtaps"], "params": [["1000.0", "50000.0", "1000000.0"], ["9", "23", "51"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d30c400692d02cd1bbe665e3146724b8d0c3ba0b274d9816d543808508aecd6e", "warmup_time": -1}, "signal_filtering.MedFilt2D.peakmem_medfilt2d": {"code": "class MedFilt2D:\n    def peakmem_medfilt2d(self, threads):\n        self._medfilt2d(threads)\n\n    def setup(self, threads):\n        rng = np.random.default_rng(8176)\n        self.chunks = np.array_split(rng.standard_normal((250, 349)), threads)", "name": "signal_filtering.MedFilt2D.peakmem_medfilt2d", "param_names": ["threads"], "params": [["1", "2", "4"]], "timeout": 60.0, "type": "peakmemory", "unit": "bytes", "version": "953bd85e31c1ea64f017cc196388bdcec638344db8296fad61c5f1c808279fb3"}, "signal_filtering.MedFilt2D.time_medfilt2d": {"code": "class MedFilt2D:\n    def time_medfilt2d(self, threads):\n        self._medfilt2d(threads)\n\n    def setup(self, threads):\n        rng = np.random.default_rng(8176)\n        self.chunks = np.array_split(rng.standard_normal((250, 349)), threads)", "min_run_count": 2, "name": "signal_filtering.MedFilt2D.time_medfilt2d", "number": 0, "param_names": ["threads"], "params": [["1", "2", "4"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7cac260a764be8a665251041ae75f310d5c1005bb374f9464972429e9f0e4859", "warmup_time": -1}, "signal_filtering.ParallelSosfilt.time_sosfilt": {"code": "class ParallelSosfilt:\n    def time_sosfilt(self, n_samples, threads):\n        with ThreadPoolExecutor(max_workers=threads) as pool:\n            futures = []\n            for i in range(threads):\n                futures.append(pool.submit(sosfilt, self.filt, self.chunks[i]))\n    \n            wait(futures)\n\n    def setup(self, n_samples, threads):\n        self.filt = butter(8, 8e-6, \"lowpass\", output=\"sos\")\n        self.data = np.arange(int(n_samples) * 3000).reshape(int(n_samples), 3000)\n        self.chunks = np.array_split(self.data, threads)", "min_run_count": 2, "name": "signal_filtering.ParallelSosfilt.time_sosfilt", "number": 0, "param_names": ["n_samples", "threads"], "params": [["1000.0", "10000.0"], ["1", "2", "4"]], "rounds": 2, "sample_time": 0.01, "timeout": 100, "type": "time", "unit": "seconds", "version": "f13929d19d7ccbc2e5176b5f1a89c329dcd83713060a4b13b2953e15f49036ee", "warmup_time": -1}, "signal_filtering.Sosfilt.time_sosfilt_basic": {"code": "class Sosfilt:\n    def time_sosfilt_basic(self, n_samples, order):\n        sosfilt(self.sos, self.y)\n\n    def setup(self, n_samples, order):\n        self.sos = butter(order, [0.1575, 0.1625], 'band', output='sos')\n        self.y = np.random.RandomState(0).randn(n_samples)", "min_run_count": 2, "name": "signal_filtering.Sosfilt.time_sosfilt_basic", "number": 0, "param_names": ["n_samples", "order"], "params": [["1000", "1000000"], ["6", "20"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e5fc1f17e52700fc1f517544303ef4a7ebe97ff269f30c6d020d86540f0ff93f", "warmup_time": -1}, "sparse.Arithmetic.time_arithmetic": {"code": "class Arithmetic:\n    def time_arithmetic(self, format, XY, op):\n        self.fn(self.y)\n\n    def setup(self, format, XY, op):\n        matrices = dict(A=poisson2d(250, format=format),\n                        B=poisson2d(250, format=format)**2)\n    \n        x = matrices[XY[0]]\n        self.y = matrices[XY[1]]\n        self.fn = getattr(x, op)\n        self.fn(self.y)  # warmup", "min_run_count": 2, "name": "sparse.Arithmetic.time_arithmetic", "number": 0, "param_names": ["format", "XY", "op"], "params": [["'csr'", "'csc'", "'coo'", "'dia'"], ["'AA'", "'AB'", "'BA'", "'BB'"], ["'__add__'", "'__sub__'", "'multiply'", "'__mul__'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "83450868d03ffee8f8a2ee6f9f4232ba297f343516d53597fa4b8d544e8700ab", "warmup_time": -1}, "sparse.BlockDiagDenseConstruction.time_block_diag": {"code": "class BlockDiagDenseConstruction:\n    def time_block_diag(self, num_matrices):\n        sparse.block_diag(self.matrices)\n\n    def setup(self, num_matrices):\n        self.matrices = []\n        for i in range(num_matrices):\n            rows = np.random.randint(1, 4)\n            columns = np.random.randint(1, 4)\n            mat = np.random.randint(0, 10, (rows, columns))\n            self.matrices.append(mat)", "min_run_count": 2, "name": "sparse.BlockDiagDenseConstruction.time_block_diag", "number": 0, "param_names": ["num_matrices"], "params": [["1000", "5000", "10000", "15000", "20000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7d89c60d3f9a3f896db0a137cec267e26b32073fb884c7286d8ccb64ac4cf2cc", "warmup_time": -1}, "sparse.BlockDiagSparseConstruction.time_block_diag": {"code": "class BlockDiagSparseConstruction:\n    def time_block_diag(self, num_matrices):\n        sparse.block_diag(self.matrices)\n\n    def setup(self, num_matrices):\n        self.matrices = []\n        for i in range(num_matrices):\n            rows = np.random.randint(1, 20)\n            columns = np.random.randint(1, 20)\n            mat = np.random.randint(0, 10, (rows, columns))\n            self.matrices.append(mat)", "min_run_count": 2, "name": "sparse.BlockDiagSparseConstruction.time_block_diag", "number": 0, "param_names": ["num_matrices"], "params": [["100", "500", "1000", "1500", "2000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4a1e400ac75879f27f5430484625271ce5c67ad81ca2d26ce753d2c0e690d14d", "warmup_time": -1}, "sparse.Construction.time_construction": {"code": "class Construction:\n    def time_construction(self, name, format):\n        T = self.cls(self.A.shape)\n        for i, j, v in zip(self.A.row, self.A.col, self.A.data):\n            T[i, j] = v\n\n    def setup(self, name, format):\n        if name == 'Empty':\n            self.A = coo_matrix((10000, 10000))\n        elif name == 'Identity':\n            self.A = sparse.eye(10000, format='coo')\n        else:\n            self.A = poisson2d(100, format='coo')\n    \n        formats = {'lil': lil_matrix, 'dok': dok_matrix}\n        self.cls = formats[format]", "min_run_count": 2, "name": "sparse.Construction.time_construction", "number": 0, "param_names": ["matrix", "format"], "params": [["'Empty'", "'Identity'", "'Poisson5pt'"], ["'lil'", "'dok'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4051443d954b347f4100b6b10b48436673e8432d95dfcbe0a104249d96a3174f", "warmup_time": -1}, "sparse.Conversion.time_conversion": {"code": "class Conversion:\n    def time_conversion(self, fromfmt, tofmt):\n        self.fn()\n\n    def setup(self, fromfmt, tofmt):\n        base = poisson2d(100, format=fromfmt)\n    \n        try:\n            self.fn = getattr(base, 'to' + tofmt)\n        except Exception:\n            def fn():\n                raise RuntimeError()\n            self.fn = fn", "min_run_count": 2, "name": "sparse.Conversion.time_conversion", "number": 0, "param_names": ["from_format", "to_format"], "params": [["'csr'", "'csc'", "'coo'", "'dia'", "'lil'", "'dok'", "'bsr'"], ["'csr'", "'csc'", "'coo'", "'dia'", "'lil'", "'dok'", "'bsr'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "fb2157b5f6933e49f97c0545b2f85985bc912c4436d81538ead45e721ce9404e", "warmup_time": -1}, "sparse.CsrHstack.time_csr_hstack": {"code": "class CsrHstack:\n    def time_csr_hstack(self, num_rows):\n        sparse.hstack([self.mat, self.mat])\n\n    def setup(self, num_rows):\n        num_cols = int(1e5)\n        density = 2e-3\n        nnz_per_row = int(density*num_cols)\n        self.mat = random_sparse(num_rows, num_cols, nnz_per_row)", "min_run_count": 2, "name": "sparse.CsrHstack.time_csr_hstack", "number": 0, "param_names": ["num_rows"], "params": [["10000", "25000", "50000", "100000", "250000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "09719b41d20ade7d878bdbbbd053da7e66b7738c20eb23102b7ee3767ae7e1ee", "warmup_time": -1}, "sparse.Densify.time_toarray": {"code": "class Densify:\n    def time_toarray(self, format, order):\n        self.X.toarray(order=order)\n\n    def setup(self, format, order):\n        warnings.simplefilter('ignore', SparseEfficiencyWarning)\n        self.X = sparse.rand(1000, 1000, format=format, density=0.01)", "min_run_count": 2, "name": "sparse.Densify.time_toarray", "number": 0, "param_names": ["format", "order"], "params": [["'dia'", "'csr'", "'csc'", "'dok'", "'lil'", "'coo'", "'bsr'"], ["'C'", "'F'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2fbf492ec800b982946a62785beda803460b913cc80080043a5d407025893b2b", "warmup_time": -1}, "sparse.Diagonal.time_diagonal": {"code": "class Diagonal:\n    def time_diagonal(self, density, format):\n        self.X.diagonal()\n\n    def setup(self, density, format):\n        n = 1000\n        if format == 'dok' and n * density >= 500:\n            raise NotImplementedError()\n    \n        warnings.simplefilter('ignore', SparseEfficiencyWarning)\n    \n        self.X = sparse.rand(n, n, format=format, density=density)", "min_run_count": 2, "name": "sparse.Diagonal.time_diagonal", "number": 0, "param_names": ["density", "format"], "params": [["0.01", "0.1", "0.5"], ["'csr'", "'csc'", "'coo'", "'lil'", "'dok'", "'dia'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d84f53fdc6abc208136c8ce48ca156370f6803562f6908eb6bd1424f50310cf1", "warmup_time": -1}, "sparse.Getset.time_fancy_getitem": {"code": "class Getset:\n    def time_fancy_getitem(self, N, sparsity_pattern, format):\n        self.m[self.i, self.j]\n\n    def setup(self, N, sparsity_pattern, format):\n        if format == 'dok' and N > 500:\n            raise NotImplementedError()\n    \n        self.A = rand(1000, 1000, density=1e-5)\n    \n        A = self.A\n        N = int(N)\n    \n        # indices to assign to\n        i, j = [], []\n        while len(i) < N:\n            n = N - len(i)\n            ip = numpy.random.randint(0, A.shape[0], size=n)\n            jp = numpy.random.randint(0, A.shape[1], size=n)\n            i = numpy.r_[i, ip]\n            j = numpy.r_[j, jp]\n        v = numpy.random.rand(n)\n    \n        if N == 1:\n            i = int(i)\n            j = int(j)\n            v = float(v)\n    \n        base = A.asformat(format)\n    \n        self.m = base.copy()\n        self.i = i\n        self.j = j\n        self.v = v", "min_run_count": 2, "name": "sparse.Getset.time_fancy_getitem", "number": 0, "param_names": ["N", "sparsity pattern", "format"], "params": [["1", "10", "100", "1000", "10000"], ["'different'", "'same'"], ["'csr'", "'csc'", "'lil'", "'dok'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "db8f9fd8e5a7a1e507d59c8f0cca32bdfe0a50d43dde3bced0592759da801ea2", "warmup_time": -1}, "sparse.Getset.track_fancy_setitem": {"code": "class Getset:\n    def track_fancy_setitem(self, N, sparsity_pattern, format):\n        def kernel(A, i, j, v):\n            A[i, j] = v\n    \n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore', SparseEfficiencyWarning)\n            return self._timeit(kernel, sparsity_pattern == 'different')\n\n    def setup(self, N, sparsity_pattern, format):\n        if format == 'dok' and N > 500:\n            raise NotImplementedError()\n    \n        self.A = rand(1000, 1000, density=1e-5)\n    \n        A = self.A\n        N = int(N)\n    \n        # indices to assign to\n        i, j = [], []\n        while len(i) < N:\n            n = N - len(i)\n            ip = numpy.random.randint(0, A.shape[0], size=n)\n            jp = numpy.random.randint(0, A.shape[1], size=n)\n            i = numpy.r_[i, ip]\n            j = numpy.r_[j, jp]\n        v = numpy.random.rand(n)\n    \n        if N == 1:\n            i = int(i)\n            j = int(j)\n            v = float(v)\n    \n        base = A.asformat(format)\n    \n        self.m = base.copy()\n        self.i = i\n        self.j = j\n        self.v = v", "name": "sparse.Getset.track_fancy_setitem", "param_names": ["N", "sparsity pattern", "format"], "params": [["1", "10", "100", "1000", "10000"], ["'different'", "'same'"], ["'csr'", "'csc'", "'lil'", "'dok'"]], "timeout": 60.0, "type": "track", "unit": "seconds", "version": "d0a713aadd72a514aeaa359421b2323d0781bf2626876b398b7c667ccebabffd"}, "sparse.Iteration.time_iteration": {"code": "class Iteration:\n    def time_iteration(self, density, format):\n        for row in self.X:\n            pass\n\n    def setup(self, density, format):\n        n = 500\n        k = 1000\n        self.X = sparse.rand(n, k, format=format, density=density)", "min_run_count": 2, "name": "sparse.Iteration.time_iteration", "number": 0, "param_names": ["density", "format"], "params": [["0.05", "0.01"], ["'csr'", "'csc'", "'lil'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "fbefcb7469069e5c8675880657b3349b1035a37fbda9ae186e6f9351967c2ee4", "warmup_time": -1}, "sparse.Matmul.time_large": {"code": "class Matmul:\n    def time_large(self):\n        for i in range(100):\n            self.matrix1 * self.matrix2\n\n    def setup(self):\n        H1, W1 = 1, 100000\n        H2, W2 = W1, 1000\n        C1 = 10\n        C2 = 1000000\n    \n        rng = np.random.default_rng(0)\n    \n        i = rng.integers(H1, size=C1)\n        j = rng.integers(W1, size=C1)\n        data = rng.random(C1)\n        self.matrix1 = coo_matrix((data, (i, j)), shape=(H1, W1)).tocsr()\n    \n        i = rng.integers(H2, size=C2)\n        j = rng.integers(W2, size=C2)\n        data = rng.random(C2)\n        self.matrix2 = coo_matrix((data, (i, j)), shape=(H2, W2)).tocsr()", "min_run_count": 2, "name": "sparse.Matmul.time_large", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "33aee08539377a7cb0fabaf0d9ff9d6d80079a428873f451b378c39f6ead48cb", "warmup_time": -1}, "sparse.Matvec.time_matvec": {"code": "class Matvec:\n    def time_matvec(self, matrix, format):\n        self.A * self.x\n\n    def setup(self, matrix, format):\n        if matrix == 'Identity':\n            if format in ('lil', 'dok'):\n                raise NotImplementedError()\n            self.A = sparse.eye(10000, 10000, format=format)\n        elif matrix == 'Poisson5pt':\n            self.A = poisson2d(300, format=format)\n        elif matrix == 'Block2x2':\n            if format not in ('csr', 'bsr'):\n                raise NotImplementedError()\n            b = (2, 2)\n            self.A = sparse.kron(poisson2d(150),\n                                 ones(b)).tobsr(blocksize=b).asformat(format)\n        elif matrix == 'Block3x3':\n            if format not in ('csr', 'bsr'):\n                raise NotImplementedError()\n            b = (3, 3)\n            self.A = sparse.kron(poisson2d(100),\n                                 ones(b)).tobsr(blocksize=b).asformat(format)\n        else:\n            raise NotImplementedError()\n    \n        self.x = ones(self.A.shape[1], dtype=float)", "min_run_count": 2, "name": "sparse.Matvec.time_matvec", "number": 0, "param_names": ["matrix", "format"], "params": [["'Identity'", "'Poisson5pt'", "'Block2x2'", "'Block3x3'"], ["'dia'", "'csr'", "'csc'", "'dok'", "'lil'", "'coo'", "'bsr'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8becb02aa64d32a3defee8b0229f7e63128c6ca3463a313a08af8448d05c017d", "warmup_time": -1}, "sparse.Matvecs.time_matvecs": {"code": "class Matvecs:\n    def time_matvecs(self, format):\n        self.A * self.x\n\n    def setup(self, format):\n        self.A = poisson2d(300, format=format)\n        self.x = ones((self.A.shape[1], 10), dtype=self.A.dtype)", "min_run_count": 2, "name": "sparse.Matvecs.time_matvecs", "number": 0, "param_names": ["format"], "params": [["'dia'", "'coo'", "'csr'", "'csc'", "'bsr'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0e6c8e3b6d833c713ee6b32da28ca78fec9f77bb427c6f5db2956d2f3688d46c", "warmup_time": -1}, "sparse.NullSlice.time_10000_rows": {"code": "class NullSlice:\n    def time_10000_rows(self, density, format):\n        self.X[np.arange(10000), :]\n\n    def setup(self, density, format):\n        # Unpickling is faster than computing the random matrix...\n        with open('{}-{}.pck'.format(density, format), 'rb') as f:\n            self.X = pickle.load(f)\n\n    def setup_cache(self):\n        for density in self.params[0]:\n            for fmt in self.params[1]:\n                self._setup(density, fmt)", "min_run_count": 2, "name": "sparse.NullSlice.time_10000_rows", "number": 0, "param_names": ["density", "format"], "params": [["0.05", "0.01"], ["'csr'", "'csc'", "'lil'"]], "rounds": 2, "sample_time": 0.01, "setup_cache_key": "sparse:351", "setup_cache_timeout": 120, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "dc19210b894d5fd41d4563f85b7459ef5836cddaf77154b539df3ea91c5d5c1c", "warmup_time": -1}, "sparse.NullSlice.time_100_cols": {"code": "class NullSlice:\n    def time_100_cols(self, density, format):\n        self.X[:, np.arange(100)]\n\n    def setup(self, density, format):\n        # Unpickling is faster than computing the random matrix...\n        with open('{}-{}.pck'.format(density, format), 'rb') as f:\n            self.X = pickle.load(f)\n\n    def setup_cache(self):\n        for density in self.params[0]:\n            for fmt in self.params[1]:\n                self._setup(density, fmt)", "min_run_count": 2, "name": "sparse.NullSlice.time_100_cols", "number": 0, "param_names": ["density", "format"], "params": [["0.05", "0.01"], ["'csr'", "'csc'", "'lil'"]], "rounds": 2, "sample_time": 0.01, "setup_cache_key": "sparse:351", "setup_cache_timeout": 120, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8d43ed52084cdab150018eedb289a749a39f35d4dfa31f53280f1ef286a23046", "warmup_time": -1}, "sparse.NullSlice.time_3_cols": {"code": "class NullSlice:\n    def time_3_cols(self, density, format):\n        self.X[:, [0, 100, 105]]\n\n    def setup(self, density, format):\n        # Unpickling is faster than computing the random matrix...\n        with open('{}-{}.pck'.format(density, format), 'rb') as f:\n            self.X = pickle.load(f)\n\n    def setup_cache(self):\n        for density in self.params[0]:\n            for fmt in self.params[1]:\n                self._setup(density, fmt)", "min_run_count": 2, "name": "sparse.NullSlice.time_3_cols", "number": 0, "param_names": ["density", "format"], "params": [["0.05", "0.01"], ["'csr'", "'csc'", "'lil'"]], "rounds": 2, "sample_time": 0.01, "setup_cache_key": "sparse:351", "setup_cache_timeout": 120, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "93e5123910772d62b3f72abff56c2732f83d217221bce409b70e77b89c311d26", "warmup_time": -1}, "sparse.NullSlice.time_3_rows": {"code": "class NullSlice:\n    def time_3_rows(self, density, format):\n        self.X[[0, 100, 105], :]\n\n    def setup(self, density, format):\n        # Unpickling is faster than computing the random matrix...\n        with open('{}-{}.pck'.format(density, format), 'rb') as f:\n            self.X = pickle.load(f)\n\n    def setup_cache(self):\n        for density in self.params[0]:\n            for fmt in self.params[1]:\n                self._setup(density, fmt)", "min_run_count": 2, "name": "sparse.NullSlice.time_3_rows", "number": 0, "param_names": ["density", "format"], "params": [["0.05", "0.01"], ["'csr'", "'csc'", "'lil'"]], "rounds": 2, "sample_time": 0.01, "setup_cache_key": "sparse:351", "setup_cache_timeout": 120, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a9eac80863a0b2f4b510269955041930e5fdd15607238257eb78244f891ebfe6", "warmup_time": -1}, "sparse.NullSlice.time_getcol": {"code": "class NullSlice:\n    def time_getcol(self, density, format):\n        self.X.getcol(100)\n\n    def setup(self, density, format):\n        # Unpickling is faster than computing the random matrix...\n        with open('{}-{}.pck'.format(density, format), 'rb') as f:\n            self.X = pickle.load(f)\n\n    def setup_cache(self):\n        for density in self.params[0]:\n            for fmt in self.params[1]:\n                self._setup(density, fmt)", "min_run_count": 2, "name": "sparse.NullSlice.time_getcol", "number": 0, "param_names": ["density", "format"], "params": [["0.05", "0.01"], ["'csr'", "'csc'", "'lil'"]], "rounds": 2, "sample_time": 0.01, "setup_cache_key": "sparse:351", "setup_cache_timeout": 120, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "291388763b355f0f3935db9272a29965d14fa3f305d3306059381e15300e638b", "warmup_time": -1}, "sparse.NullSlice.time_getrow": {"code": "class NullSlice:\n    def time_getrow(self, density, format):\n        self.X.getrow(100)\n\n    def setup(self, density, format):\n        # Unpickling is faster than computing the random matrix...\n        with open('{}-{}.pck'.format(density, format), 'rb') as f:\n            self.X = pickle.load(f)\n\n    def setup_cache(self):\n        for density in self.params[0]:\n            for fmt in self.params[1]:\n                self._setup(density, fmt)", "min_run_count": 2, "name": "sparse.NullSlice.time_getrow", "number": 0, "param_names": ["density", "format"], "params": [["0.05", "0.01"], ["'csr'", "'csc'", "'lil'"]], "rounds": 2, "sample_time": 0.01, "setup_cache_key": "sparse:351", "setup_cache_timeout": 120, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "edb9e4291560d6ba8dd58ef371b3a343a333bc10744496adb3ff964762d33c68", "warmup_time": -1}, "sparse.Random.time_rand": {"code": "class Random:\n    def time_rand(self, density):\n        sparse.rand(self.nrows, self.ncols,\n                    format=self.format, density=density)\n\n    def setup(self, density):\n        warnings.simplefilter('ignore', SparseEfficiencyWarning)\n        self.nrows = 1000\n        self.ncols = 1000\n        self.format = 'csr'", "min_run_count": 2, "name": "sparse.Random.time_rand", "number": 0, "param_names": ["density"], "params": [["0.0", "0.1", "0.2", "0.30000000000000004", "0.4", "0.5", "0.6000000000000001", "0.7000000000000001", "0.8", "0.9", "1.0"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "320c3719a0f95052ea0841c9f8a7026e494039067d3b02a6ab91774e5afbbcd5", "warmup_time": -1}, "sparse.Sort.time_sort": {"code": "class Sort:\n    def time_sort(self, matrix):\n        \"\"\"sort CSR column indices\"\"\"\n        self.A.sort_indices()\n\n    def setup(self, matrix):\n        n = 10000\n        if matrix.startswith('Rand'):\n            k = int(matrix[4:])\n            self.A = random_sparse(n, n, k)\n            self.A.has_sorted_indices = False\n            self.A.indices[:2] = 2, 1\n        else:\n            raise NotImplementedError()", "min_run_count": 2, "name": "sparse.Sort.time_sort", "number": 0, "param_names": ["matrix"], "params": [["'Rand10'", "'Rand25'", "'Rand50'", "'Rand100'", "'Rand200'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4268949f8dfc20462c34ad9701546d2d0354296a0031229c0dcf602f5b745973", "warmup_time": -1}, "sparse.Sum.time_sum": {"code": "class Sum:\n    def time_sum(self, density, format):\n        self.X.sum()\n\n    def setup(self, density, format):\n        n = 1000\n        if format == 'dok' and n * density >= 500:\n            raise NotImplementedError()\n    \n        warnings.simplefilter('ignore', SparseEfficiencyWarning)\n        self.X = sparse.rand(n, n, format=format, density=density)", "min_run_count": 2, "name": "sparse.Sum.time_sum", "number": 0, "param_names": ["density", "format"], "params": [["0.01", "0.1", "0.5"], ["'csr'", "'csc'", "'coo'", "'lil'", "'dok'", "'dia'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "05c305857e771024535e546360203b17f5aca2b39b023a49ab296bd746d6cdd3", "warmup_time": -1}, "sparse.Sum.time_sum_axis0": {"code": "class Sum:\n    def time_sum_axis0(self, density, format):\n        self.X.sum(axis=0)\n\n    def setup(self, density, format):\n        n = 1000\n        if format == 'dok' and n * density >= 500:\n            raise NotImplementedError()\n    \n        warnings.simplefilter('ignore', SparseEfficiencyWarning)\n        self.X = sparse.rand(n, n, format=format, density=density)", "min_run_count": 2, "name": "sparse.Sum.time_sum_axis0", "number": 0, "param_names": ["density", "format"], "params": [["0.01", "0.1", "0.5"], ["'csr'", "'csc'", "'coo'", "'lil'", "'dok'", "'dia'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8aca682fd69aa140c69c028679826bdf43c717589b1961b4702d744ed72effc6", "warmup_time": -1}, "sparse.Sum.time_sum_axis1": {"code": "class Sum:\n    def time_sum_axis1(self, density, format):\n        self.X.sum(axis=1)\n\n    def setup(self, density, format):\n        n = 1000\n        if format == 'dok' and n * density >= 500:\n            raise NotImplementedError()\n    \n        warnings.simplefilter('ignore', SparseEfficiencyWarning)\n        self.X = sparse.rand(n, n, format=format, density=density)", "min_run_count": 2, "name": "sparse.Sum.time_sum_axis1", "number": 0, "param_names": ["density", "format"], "params": [["0.01", "0.1", "0.5"], ["'csr'", "'csc'", "'coo'", "'lil'", "'dok'", "'dia'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1a6e05244b77f857c61f8ee09ca3abd006a10ba07eff10b1c5f9e0ac20f331b2", "warmup_time": -1}, "sparse_csgraph.Laplacian.time_laplacian": {"code": "class Laplacian:\n    def time_laplacian(self, n, format, normed):\n        laplacian(self.A, normed=normed)\n\n    def setup(self, n, format, normed):\n        data = scipy.sparse.rand(9, n, density=0.5, random_state=42).toarray()\n        data = np.vstack((data, data))\n        diags = list(range(-9, 0)) + list(range(1, 10))\n        A = scipy.sparse.spdiags(data, diags, n, n)\n        if format == 'dense':\n            self.A = A.toarray()\n        else:\n            self.A = A.asformat(format)", "min_run_count": 2, "name": "sparse_csgraph.Laplacian.time_laplacian", "number": 0, "param_names": ["n", "format", "normed"], "params": [["30", "300", "900"], ["'dense'", "'coo'", "'csc'", "'csr'", "'dia'"], ["True", "False"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b92e9b88ee4c528c25ebb2cfe70b49009ea6137919484946765b5321b04dc79e", "warmup_time": -1}, "sparse_csgraph_djisktra.Dijkstra.time_dijkstra_multi": {"code": "class Dijkstra:\n    def time_dijkstra_multi(self, n, min_only):\n        dijkstra(self.data,\n                 directed=False,\n                 indices=self.indices,\n                 min_only=min_only)\n\n    def setup(self, n, min_only):\n        rng = np.random.default_rng(1234)\n        # make a random connectivity matrix\n        data = scipy.sparse.rand(n, n, density=0.2, format='csc',\n                                 random_state=42, dtype=np.bool_)\n        data.setdiag(np.zeros(n, dtype=np.bool_))\n        self.data = data\n        # choose some random vertices\n        v = np.arange(n)\n        rng.shuffle(v)\n        self.indices = v[:int(n*.1)]", "min_run_count": 2, "name": "sparse_csgraph_djisktra.Dijkstra.time_dijkstra_multi", "number": 0, "param_names": ["n", "min_only"], "params": [["30", "300", "900"], ["True", "False"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "eaefedd0a120b886387171dd0abb0b3f637394d7a7866f0cf7032de436a14390", "warmup_time": -1}, "sparse_csgraph_matching.MaximumBipartiteMatching.time_maximum_bipartite_matching": {"code": "class MaximumBipartiteMatching:\n    def time_maximum_bipartite_matching(self, n, density):\n        maximum_bipartite_matching(self.graph)\n\n    def setup(self, n, density):\n        # Create random sparse matrices. Note that we could use\n        # scipy.sparse.rand for this purpose, but simply using np.random and\n        # disregarding duplicates is quite a bit faster.\n        rng = np.random.default_rng(42)\n        d = rng.integers(0, n, size=(int(n*n*density), 2))\n        graph = scipy.sparse.csr_matrix((np.ones(len(d)), (d[:, 0], d[:, 1])),\n                                        shape=(n, n))\n        self.graph = graph", "min_run_count": 2, "name": "sparse_csgraph_matching.MaximumBipartiteMatching.time_maximum_bipartite_matching", "number": 0, "param_names": ["n", "density"], "params": [["5000", "7500", "10000"], ["0.0001", "0.0005", "0.001"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "31f71f40e27f1ce32dd2ba027dc6ad67c2141209e422069d0c1e7cc98a2e2ed3", "warmup_time": -1}, "sparse_csgraph_matching.MinWeightFullBipartiteMatching.time_evaluation": {"code": "class MinWeightFullBipartiteMatching:\n    def time_evaluation(self, *args):\n        min_weight_full_bipartite_matching(self.biadjacency_matrix)\n\n    def setup(self, shape, input_type):\n        rng = np.random.default_rng(42)\n        input_func = {'random_uniform': random_uniform,\n                      'random_uniform_sparse': random_uniform_sparse,\n                      'random_uniform_integer': random_uniform_integer,\n                      'random_geometric': random_geometric,\n                      'random_two_cost': random_two_cost,\n                      'machol_wien': machol_wien}[input_type]\n    \n        self.biadjacency_matrix = input_func(shape, rng)", "min_run_count": 2, "name": "sparse_csgraph_matching.MinWeightFullBipartiteMatching.time_evaluation", "number": 0, "param_names": ["shapes", "input_type"], "params": [["(100, 100)", "(200, 200)", "(300, 300)", "(400, 400)", "(100, 200)", "(200, 400)", "(300, 600)", "(400, 800)"], ["'random_uniform'", "'random_uniform_sparse'", "'random_uniform_integer'", "'random_geometric'", "'random_two_cost'", "'machol_wien'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7a964a0b0d5fac7f49cbb921c33f8d3762b10a9ae49818ec949fc6a67bd64135", "warmup_time": -1}, "sparse_csgraph_maxflow.MaximumFlow.time_maximum_flow": {"code": "class MaximumFlow:\n    def time_maximum_flow(self, n, density):\n        maximum_flow(self.data, 0, n - 1)\n\n    def setup(self, n, density):\n        # Create random matrices whose values are integers between 0 and 100.\n        data = (scipy.sparse.rand(n, n, density=density, format='lil',\n                                  random_state=42)*100).astype(np.int32)\n        data.setdiag(np.zeros(n, dtype=np.int32))\n        self.data = scipy.sparse.csr_matrix(data)", "min_run_count": 2, "name": "sparse_csgraph_maxflow.MaximumFlow.time_maximum_flow", "number": 0, "param_names": ["n", "density"], "params": [["200", "500", "1500"], ["0.1", "0.3", "0.5"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8ca0245768f27e9a1347d85875c05e5413e3759ddd8bdc4d1027f3aa901fd708", "warmup_time": -1}, "sparse_linalg_expm.Expm.time_expm": {"code": "class Expm:\n    def time_expm(self, n, format):\n        if format == 'sparse':\n            sp_expm(self.A_sparse)\n        elif format == 'dense':\n            scipy.linalg.expm(self.A_dense)\n\n    def setup(self, n, format):\n        rng = np.random.default_rng(1234)\n    \n        # Let the number of nonzero entries per row\n        # scale like the log of the order of the matrix.\n        nnz_per_row = int(math.ceil(math.log(n)))\n    \n        # time the sampling of a random sparse matrix\n        self.A_sparse = random_sparse_csc(n, n, nnz_per_row, rng)\n    \n        # first format conversion\n        self.A_dense = self.A_sparse.toarray()", "min_run_count": 2, "name": "sparse_linalg_expm.Expm.time_expm", "number": 0, "param_names": ["n", "format"], "params": [["30", "100", "300"], ["'sparse'", "'dense'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0872767333496288223a5b7d4c4ab78001a86756a95991d314c2cf6e45c6f384", "warmup_time": -1}, "sparse_linalg_expm.ExpmMultiply.time_expm_multiply": {"code": "class ExpmMultiply:\n    def time_expm_multiply(self):\n        # computing only column', j, 'of expm of the sparse matrix\n        v = np.zeros(self.n, dtype=float)\n        v[self.j] = 1\n        A_expm_col_j = expm_multiply(self.A, v)\n        A_expm_col_j[self.i]\n\n    def setup(self):\n        self.n = 2000\n        self.i = 100\n        self.j = 200\n        nnz_per_row = 25\n        self.A = random_sparse_csr(self.n, self.n, nnz_per_row)", "min_run_count": 2, "name": "sparse_linalg_expm.ExpmMultiply.time_expm_multiply", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e68511899de027ba6015238b1432f49ad0ef12cea66db1f175eec005a2991c58", "warmup_time": -1}, "sparse_linalg_lobpcg.Bench.time_mikota": {"code": "class Bench:\n    def time_mikota(self, n, solver):\n        m = 10\n        if solver == 'lobpcg':\n            X = rand(n, m)\n            X = orth(X)\n            LorU, lower = cho_factor(self.A, lower=0, overwrite_a=0)\n            M = LinearOperator(self.shape,\n                               matvec=partial(_precond, LorU, lower),\n                               matmat=partial(_precond, LorU, lower))\n            eigs, vecs = lobpcg(self.A, X, self.B, M, tol=1e-4, maxiter=40)\n        else:\n            eigh(self.A, self.B, eigvals_only=True, eigvals=(0, m - 1))\n\n    def setup_mikota(self, n, solver):\n        self.shape = (n, n)\n        self.A, self.B = _mikota_pair(n)\n    \n        if solver == 'eigh' and n >= 512:\n            # skip: slow, and not useful to benchmark\n            raise NotImplementedError()", "min_run_count": 2, "name": "sparse_linalg_lobpcg.Bench.time_mikota", "number": 0, "param_names": ["n", "solver"], "params": [["128", "256", "512", "1024", "2048"], ["'lobpcg'", "'eigh'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a1fb679758f7e5cf79d18cc4930afdff999fccc142fe7a4f63e73b39ab1f58bb", "warmup_time": -1}, "sparse_linalg_lobpcg.Bench.time_sakurai": {"code": "class Bench:\n    def time_sakurai(self, n, solver):\n        m = 3\n        if solver == 'lobpcg':\n            X = rand(n, m)\n            eigs, vecs, resnh = lobpcg(self.A, X, self.B, tol=1e-6, maxiter=500,\n                                       retResidualNormsHistory=1)\n        else:\n            eigh(self.A_dense, self.B_dense, eigvals_only=True, eigvals=(0, m - 1))\n\n    def setup_sakurai(self, n, solver):\n        self.shape = (n, n)\n        self.A, self.B, all_eigenvalues = _sakurai(n)\n        self.A_dense = self.A.A\n        self.B_dense = self.B.A", "min_run_count": 2, "name": "sparse_linalg_lobpcg.Bench.time_sakurai", "number": 0, "param_names": ["n", "solver"], "params": [["50", "400"], ["'lobpcg'", "'eigh'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7c38d449924fb71f777bd408072ecc883b8b05e53a6544e97da3887fbc10b235", "warmup_time": -1}, "sparse_linalg_onenormest.BenchmarkOneNormEst.time_onenormest": {"code": "class BenchmarkOneNormEst:\n    def time_onenormest(self, n, solver):\n        if solver == 'exact':\n            # Get the exact values of one-norms of squares.\n            for M in self.matrices:\n                M.dot(M)\n                scipy.sparse.linalg._matfuncs._onenorm(M)\n        elif solver == 'onenormest':\n            # Get the estimates of one-norms of squares.\n            for M in self.matrices:\n                scipy.sparse.linalg._matfuncs._onenormest_matrix_power(M, 2)\n\n    def setup(self, n, solver):\n        rng = np.random.default_rng(1234)\n        nrepeats = 100\n        shape = (int(n), int(n))\n    \n        if solver == 'exact' and n >= 300:\n            # skip: slow, and not useful to benchmark\n            raise NotImplementedError()\n    \n        if n <= 1000:\n            # Sample the matrices.\n            self.matrices = []\n            for i in range(nrepeats):\n                M = rng.standard_normal(shape)\n                self.matrices.append(M)\n        else:\n            max_nnz = 100000\n            nrepeats = 1\n    \n            self.matrices = []\n            for i in range(nrepeats):\n                M = scipy.sparse.rand(shape[0], shape[1], min(max_nnz/(shape[0]*shape[1]), 1e-5), random_state=rng)\n                self.matrices.append(M)", "min_run_count": 2, "name": "sparse_linalg_onenormest.BenchmarkOneNormEst.time_onenormest", "number": 0, "param_names": ["n", "solver"], "params": [["2", "3", "5", "10", "30", "100", "300", "500", "1000", "10000.0", "100000.0", "1000000.0"], ["'exact'", "'onenormest'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f7b31b4bf5caa50d435465e78dab6e133f3c263a52c4523eec785446185fdb6f", "warmup_time": -1}, "sparse_linalg_solve.Bench.time_solve": {"code": "class Bench:\n    def time_solve(self, n, solver):\n        if solver == 'dense':\n            linalg.solve(self.P_dense, self.b)\n        else:\n            self.mapping[solver](self.P_sparse, self.b)\n\n    def setup(self, n, solver):\n        if solver == 'dense' and n >= 25:\n            raise NotImplementedError()\n    \n        self.b = np.ones(n*n)\n        self.P_sparse = _create_sparse_poisson2d(n)\n    \n        if solver == 'dense':\n            self.P_dense = self.P_sparse.A", "min_run_count": 2, "name": "sparse_linalg_solve.Bench.time_solve", "number": 0, "param_names": ["(n,n)", "solver"], "params": [["4", "6", "10", "16", "25", "40", "64", "100"], ["'dense'", "'spsolve'", "'cg'", "'minres'", "'gmres'", "'lgmres'", "'gcrotmk'", "'tfqmr'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f2f689cccfc390b2f47b6d7aa6d9974d58b45e2ab77a73bbd2bce1a69d9ff378", "warmup_time": -1}, "sparse_linalg_solve.Lgmres.time_inner": {"code": "class Lgmres:\n    def time_inner(self, n, m):\n        lgmres(self.A, self.b, inner_m=m, maxiter=1)\n\n    def setup(self, n, m):\n        rng = np.random.default_rng(1234)\n        self.A = sparse.eye(n, n) + sparse.rand(n, n, density=0.01, random_state=rng)\n        self.b = np.ones(n)", "min_run_count": 2, "name": "sparse_linalg_solve.Lgmres.time_inner", "number": 0, "param_names": ["n", "m"], "params": [["10", "50", "100", "1000", "10000"], ["10", "30", "60", "90", "180"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d31c182067e0c1e06fa24a25ae9e5ed76b709f347960521b3f434c30e41e1530", "warmup_time": -1}, "sparse_linalg_svds.BenchSVDS.time_svds": {"code": "class BenchSVDS:\n    def time_svds(self, k, problem, solver):\n        # consider k = int(np.min(self.A.shape) * k)\n        np.random.seed(0)\n        svds(self.A, k=k, solver=solver)\n\n    def setup(self, k, problem, solver):\n        dir_path = os.path.dirname(os.path.realpath(__file__))\n        datafile = os.path.join(dir_path, \"svds_benchmark_files\",\n                                \"svds_benchmark_files.npz\")\n        matrices = np.load(datafile, allow_pickle=True)\n        self.A = matrices[problem][()]", "min_run_count": 2, "name": "sparse_linalg_svds.BenchSVDS.time_svds", "number": 0, "param_names": ["k", "problem", "solver"], "params": [["25"], ["'abb313'", "'illc1033'", "'illc1850'", "'qh1484'", "'rbs480a'", "'tols4000'", "'well1033'", "'well1850'", "'west0479'", "'west2021'"], ["'arpack'", "'lobpcg'", "'propack'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "30f98c71f4282694a9bb723cd2896a8d584018aa5c1cd79b1dada37899109f4d", "warmup_time": -1}, "spatial.Build.time_build": {"code": "class Build:\n    def time_build(self, mnr, cls_name):\n        \"\"\"\n        Constructing kd-tree\n        =======================\n        dim | # points |  time\n        \"\"\"\n        m, n, r = mnr\n        if cls_name == 'cKDTree_flat':\n            self.T = self.cls(self.data, leafsize=n)\n        else:\n            self.cls(self.data)\n\n    def setup(self, mnr, cls_name):\n        self.cls = KDTree if cls_name == 'KDTree' else cKDTree\n        m, n, r = mnr\n    \n        rng = np.random.default_rng(1234)\n        self.data = np.concatenate((rng.standard_normal((n//2,m)),\n                                    rng.standard_normal((n-n//2,m))+np.ones(m)))\n    \n        self.queries = np.concatenate((rng.standard_normal((r//2,m)),\n                                       rng.standard_normal((r-r//2,m))+np.ones(m)))", "min_run_count": 2, "name": "spatial.Build.time_build", "number": 0, "param_names": ["(m, n, r)", "class"], "params": [["(3, 10000, 1000)", "(8, 10000, 1000)", "(16, 10000, 1000)"], ["'KDTree'", "'cKDTree'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e56abf7977e5d2b2a335309fe281c887d0f0c584b6ed13af795e07b151af05d1", "warmup_time": -1}, "spatial.BuildUnbalanced.time_build": {"code": "class BuildUnbalanced:\n    def time_build(self, mnr, balanced, order):\n        cKDTree(self.data.get(order), balanced_tree=balanced)\n\n    def setup(self, *args):\n        super().setup(*args, None)", "min_run_count": 2, "name": "spatial.BuildUnbalanced.time_build", "number": 0, "param_names": ["(m, n, r)", "balanced", "order"], "params": [["(3, 10000, 1000)", "(8, 10000, 1000)", "(16, 10000, 1000)"], ["True", "False"], ["'random'", "'sorted'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b3f85876bde4578b41fe30a91936b5b252967ef1f73ab7022d1cde83f0b13fc4", "warmup_time": -1}, "spatial.CNeighbors.time_count_neighbors_deep": {"code": "class CNeighbors:\n    def time_count_neighbors_deep(self, mn1n2, Nr):\n        \"\"\"\n        Count neighbors for a very deep kd-tree\n        dim | # points T1 | # points T2 | Nr\n        \"\"\"\n        self.T1d.count_neighbors(self.T2d, self.r)\n\n    def setup(self, mn1n2, Nr):\n        m, n1, n2 = mn1n2\n    \n        data1 = np.random.uniform(size=(n1, m))\n        data2 = np.random.uniform(size=(n2, m))\n        self.w1 = np.ones(len(data1))\n        self.w2 = np.ones(len(data2))\n    \n        self.T1d = cKDTree(data1, leafsize=1)\n        self.T2d = cKDTree(data2, leafsize=1)\n        self.T1s = cKDTree(data1, leafsize=8)\n        self.T2s = cKDTree(data2, leafsize=8)\n        self.r = np.linspace(0, 0.5, Nr)", "min_run_count": 2, "name": "spatial.CNeighbors.time_count_neighbors_deep", "number": 0, "param_names": ["(m, n1, n2)", "Nr"], "params": [["(2, 1000, 1000)", "(8, 1000, 1000)", "(16, 1000, 1000)"], ["2", "10", "100", "400", "1000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "898c532420fe54ed2c5c8ac138c47fb2c526cc6068b1af36f4bb77fe14cbc921", "warmup_time": -1}, "spatial.CNeighbors.time_count_neighbors_shallow": {"code": "class CNeighbors:\n    def time_count_neighbors_shallow(self, mn1n2, Nr):\n        \"\"\"\n        Count neighbors for a shallow kd-tree\n        dim | # points T1 | # points T2 | Nr\n        \"\"\"\n        self.T1s.count_neighbors(self.T2s, self.r)\n\n    def setup(self, mn1n2, Nr):\n        m, n1, n2 = mn1n2\n    \n        data1 = np.random.uniform(size=(n1, m))\n        data2 = np.random.uniform(size=(n2, m))\n        self.w1 = np.ones(len(data1))\n        self.w2 = np.ones(len(data2))\n    \n        self.T1d = cKDTree(data1, leafsize=1)\n        self.T2d = cKDTree(data2, leafsize=1)\n        self.T1s = cKDTree(data1, leafsize=8)\n        self.T2s = cKDTree(data2, leafsize=8)\n        self.r = np.linspace(0, 0.5, Nr)", "min_run_count": 2, "name": "spatial.CNeighbors.time_count_neighbors_shallow", "number": 0, "param_names": ["(m, n1, n2)", "Nr"], "params": [["(2, 1000, 1000)", "(8, 1000, 1000)", "(16, 1000, 1000)"], ["2", "10", "100", "400", "1000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "77ff53b15a90b2222e3a224e25ae752587a0a69b3899f04a8689193cda97f368", "warmup_time": -1}, "spatial.ConvexHullBench.time_convex_hull": {"code": "class ConvexHullBench:\n    def time_convex_hull(self, num_points, incremental):\n        \"\"\"Time scipy.spatial.ConvexHull over a range of input data sizes\n        and settings.\n        \"\"\"\n        ConvexHull(self.points, incremental)\n\n    def setup(self, num_points, incremental):\n        rng = np.random.default_rng(123)\n        self.points = rng.random((num_points, 3))", "min_run_count": 2, "name": "spatial.ConvexHullBench.time_convex_hull", "number": 0, "param_names": ["num_points", "incremental"], "params": [["10", "100", "1000", "5000"], ["True", "False"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "cd8dd3be1521de1569d50d0a4469308672c2af59dca3345148e1fa78b00a65e6", "warmup_time": -1}, "spatial.GeometricSlerpBench.time_geometric_slerp_3d": {"code": "class GeometricSlerpBench:\n    def time_geometric_slerp_3d(self, num_points):\n        # time geometric_slerp() for 3D interpolation\n        geometric_slerp(start=self.start,\n                        end=self.end,\n                        t=self.t)\n\n    def setup(self, num_points):\n        points = generate_spherical_points(50)\n        # any two points from the random spherical points\n        # will suffice for the interpolation bounds:\n        self.start = points[0]\n        self.end = points[-1]\n        self.t = np.linspace(0, 1, num_points)", "min_run_count": 2, "name": "spatial.GeometricSlerpBench.time_geometric_slerp_3d", "number": 0, "param_names": ["num_points"], "params": [["10", "1000", "10000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "24e5a4b637081cea96f06a0e1ad72ac25282b6954c01f6bf387635de0ffe28ec", "warmup_time": -1}, "spatial.Hausdorff.time_directed_hausdorff": {"code": "class Hausdorff:\n    def time_directed_hausdorff(self, num_points):\n        # time directed_hausdorff code in 3 D\n        distance.directed_hausdorff(self.points1, self.points2)\n\n    def setup(self, num_points):\n        rng = np.random.default_rng(123)\n        self.points1 = rng.random((num_points, 3))\n        self.points2 = rng.random((num_points, 3))", "min_run_count": 2, "name": "spatial.Hausdorff.time_directed_hausdorff", "number": 0, "param_names": ["num_points"], "params": [["10", "100", "1000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c35368df2962162d1c3260e5b0776f6897780414c061124c486df8e21d2611d9", "warmup_time": -1}, "spatial.Neighbors.time_count_neighbors": {"code": "class Neighbors:\n    def time_count_neighbors(self, mn1n2, p, probe_radius, boxsize, leafsize, cls):\n        \"\"\"\n        Count neighbors kd-tree\n        dim | # points T1 | # points T2 | p | probe radius |  BoxSize | LeafSize | cls\n        \"\"\"\n    \n        if cls != 'cKDTree_weighted':\n            self.T1.count_neighbors(self.T2, probe_radius, p=p)\n        else:\n            self.T1.count_neighbors(self.T2, probe_radius, weights=(self.w1, self.w2), p=p)\n\n    def setup(self, mn1n2, p, probe_radius, boxsize, leafsize, cls):\n        LimitedParamBenchmark.setup(self, mn1n2, p, probe_radius, boxsize, leafsize, cls)\n    \n        m, n1, n2 = mn1n2\n    \n        self.data1 = np.random.uniform(size=(n1, m))\n        self.data2 = np.random.uniform(size=(n2, m))\n    \n        self.w1 = np.ones(n1)\n        self.w2 = np.ones(n2)\n    \n        self.T1 = cKDTree(self.data1, boxsize=boxsize, leafsize=leafsize)\n        self.T2 = cKDTree(self.data2, boxsize=boxsize, leafsize=leafsize)", "min_run_count": 2, "name": "spatial.Neighbors.time_count_neighbors", "number": 0, "param_names": ["(m, n1, n2)", "p", "probe radius", "boxsize", "leafsize", "cls"], "params": [["(3, 1000, 1000)", "(8, 1000, 1000)", "(16, 1000, 1000)"], ["1", "2", "inf"], ["0.2", "0.5"], ["None", "0.0", "1.0"], ["8", "128"], ["'cKDTree'", "'cKDTree_weighted'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "830287f1cf51fa6ba21854a60b03b2a6c70b2f2485c3cdcfb19a360e0a7e2ca2", "warmup_time": -1}, "spatial.Neighbors.time_sparse_distance_matrix": {"code": "class Neighbors:\n    def time_sparse_distance_matrix(self, mn1n2, p, probe_radius, boxsize, leafsize, cls):\n        self.T1.sparse_distance_matrix(self.T2, probe_radius, p=p)\n\n    def setup(self, mn1n2, p, probe_radius, boxsize, leafsize, cls):\n        LimitedParamBenchmark.setup(self, mn1n2, p, probe_radius, boxsize, leafsize, cls)\n    \n        m, n1, n2 = mn1n2\n    \n        self.data1 = np.random.uniform(size=(n1, m))\n        self.data2 = np.random.uniform(size=(n2, m))\n    \n        self.w1 = np.ones(n1)\n        self.w2 = np.ones(n2)\n    \n        self.T1 = cKDTree(self.data1, boxsize=boxsize, leafsize=leafsize)\n        self.T2 = cKDTree(self.data2, boxsize=boxsize, leafsize=leafsize)", "min_run_count": 2, "name": "spatial.Neighbors.time_sparse_distance_matrix", "number": 0, "param_names": ["(m, n1, n2)", "p", "probe radius", "boxsize", "leafsize", "cls"], "params": [["(3, 1000, 1000)", "(8, 1000, 1000)", "(16, 1000, 1000)"], ["1", "2", "inf"], ["0.2", "0.5"], ["None", "0.0", "1.0"], ["8", "128"], ["'cKDTree'", "'cKDTree_weighted'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9aa921dce6da78394ab29d949be27953484613dcf9c9632c01ae3973d4b29596", "warmup_time": -1}, "spatial.Query.time_query": {"code": "class Query:\n    def time_query(self, mnr, p, boxsize, leafsize):\n        \"\"\"\n        Querying kd-tree\n        dim | # points | # queries |  KDTree  | cKDTree | flat cKDTree\n        \"\"\"\n        self.T.query(self.queries, p=p)\n\n    def setup(self, mnr, p, boxsize, leafsize):\n        LimitedParamBenchmark.setup(self, mnr, p, boxsize, leafsize)\n        Query.do_setup(self, mnr, p, boxsize, leafsize)", "min_run_count": 2, "name": "spatial.Query.time_query", "number": 0, "param_names": ["(m, n, r)", "p", "boxsize", "leafsize"], "params": [["(3, 10000, 1000)", "(8, 10000, 1000)", "(16, 10000, 1000)"], ["1", "2", "inf"], ["None", "0.0", "1.0"], ["8", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "327bc0627d5387347e9cdcf4c52a550c813bb80a859eeb0f3e5bfe6650a8a1db", "warmup_time": -1}, "spatial.QueryUnbalanced.time_query": {"code": "class QueryUnbalanced:\n    def time_query(self, mnr, balanced, order):\n        self.T.query(self.queries)\n\n    def setup(self, *args):\n        super().setup(*args, None)", "min_run_count": 2, "name": "spatial.QueryUnbalanced.time_query", "number": 0, "param_names": ["(m, n, r)", "balanced", "order"], "params": [["(3, 10000, 1000)", "(8, 10000, 1000)", "(16, 10000, 1000)"], ["True", "False"], ["'random'", "'sorted'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a9d431feadb762330179e442072bf26158cb5969d79b1beae251b28526278f1b", "warmup_time": -1}, "spatial.Radius.time_query_ball_point": {"code": "class Radius:\n    def time_query_ball_point(self, mnr, p, probe_radius, boxsize, leafsize):\n        self.T.query_ball_point(self.queries, probe_radius, p=p)\n\n    def setup(self, *args):\n        pass\n\n    def setup_query_ball_point(self, mnr, p, probe_radius, boxsize, leafsize):\n        LimitedParamBenchmark.setup(self, mnr, p, probe_radius, boxsize, leafsize,\n                                    param_seed=3)\n        Query.do_setup(self, mnr, p, boxsize, leafsize)", "min_run_count": 2, "name": "spatial.Radius.time_query_ball_point", "number": 0, "param_names": ["(m, n, r)", "p", "probe radius", "boxsize", "leafsize"], "params": [["(3, 10000, 1000)"], ["1", "2", "inf"], ["0.2", "0.5"], ["None", "0.0", "1.0"], ["8", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e0c2074b35db7e5fca01a43b0fba8ab33a15ed73d8573871ea6feb57b3df4168", "warmup_time": -1}, "spatial.Radius.time_query_ball_point_nosort": {"code": "class Radius:\n    def time_query_ball_point_nosort(self, mnr, p, probe_radius, boxsize, leafsize):\n        self.T.query_ball_point(self.queries, probe_radius, p=p,\n                                return_sorted=False)\n\n    def setup(self, *args):\n        pass\n\n    def setup_query_ball_point(self, mnr, p, probe_radius, boxsize, leafsize):\n        LimitedParamBenchmark.setup(self, mnr, p, probe_radius, boxsize, leafsize,\n                                    param_seed=3)\n        Query.do_setup(self, mnr, p, boxsize, leafsize)", "min_run_count": 2, "name": "spatial.Radius.time_query_ball_point_nosort", "number": 0, "param_names": ["(m, n, r)", "p", "probe radius", "boxsize", "leafsize"], "params": [["(3, 10000, 1000)"], ["1", "2", "inf"], ["0.2", "0.5"], ["None", "0.0", "1.0"], ["8", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3b4af3fb728a8ddede3db373ad84acf4e35a28f8732e03553b45ee4486485380", "warmup_time": -1}, "spatial.Radius.time_query_pairs": {"code": "class Radius:\n    def time_query_pairs(self, mnr, p, probe_radius, boxsize, leafsize):\n        self.T.query_pairs(probe_radius, p=p)\n\n    def setup(self, *args):\n        pass\n\n    def setup_query_pairs(self, mnr, p, probe_radius, boxsize, leafsize):\n        # query_pairs is fast enough so we can run all parameter combinations\n        Query.do_setup(self, mnr, p, boxsize, leafsize)", "min_run_count": 2, "name": "spatial.Radius.time_query_pairs", "number": 0, "param_names": ["(m, n, r)", "p", "probe radius", "boxsize", "leafsize"], "params": [["(3, 1000, 30)", "(8, 1000, 30)", "(16, 1000, 30)"], ["1", "2", "inf"], ["0.2", "0.5"], ["None", "0.0", "1.0"], ["8", "128"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "cf669f7d619e81e4a09b28bb3fceaefbdd316d30faf01524ab33d41661a53f56", "warmup_time": -1}, "spatial.RadiusUnbalanced.time_query_ball_point": {"code": "class RadiusUnbalanced:\n    def time_query_ball_point(self, mnr, balanced, order, radius):\n        self.T.query_ball_point(self.queries, radius)\n\nclass PresortedDataSetup:\n    def setup(self, mnr, balanced, order, radius):\n        m, n, r = mnr\n    \n        rng = np.random.default_rng(1234)\n        self.data = {\n            'random': rng.uniform(size=(n, m)),\n            'sorted': np.repeat(np.arange(n, 0, -1)[:, np.newaxis],\n                                m,\n                                axis=1) / n\n        }\n    \n        self.queries = rng.uniform(size=(r, m))\n        self.T = cKDTree(self.data.get(order), balanced_tree=balanced)", "min_run_count": 2, "name": "spatial.RadiusUnbalanced.time_query_ball_point", "number": 0, "param_names": ["(m, n, r)", "balanced", "order", "radius"], "params": [["(3, 1000, 30)", "(8, 1000, 30)", "(16, 1000, 30)"], ["True", "False"], ["'random'", "'sorted'"], ["0.5"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "19ffec4578bc56ccb269e4d25bee6e18d61bd214fe600536a9b683fc36cc41ae", "warmup_time": -1}, "spatial.RadiusUnbalanced.time_query_pairs": {"code": "class RadiusUnbalanced:\n    def time_query_pairs(self, mnr, balanced, order, radius):\n        self.T.query_pairs(radius)\n\nclass PresortedDataSetup:\n    def setup(self, mnr, balanced, order, radius):\n        m, n, r = mnr\n    \n        rng = np.random.default_rng(1234)\n        self.data = {\n            'random': rng.uniform(size=(n, m)),\n            'sorted': np.repeat(np.arange(n, 0, -1)[:, np.newaxis],\n                                m,\n                                axis=1) / n\n        }\n    \n        self.queries = rng.uniform(size=(r, m))\n        self.T = cKDTree(self.data.get(order), balanced_tree=balanced)", "min_run_count": 2, "name": "spatial.RadiusUnbalanced.time_query_pairs", "number": 0, "param_names": ["(m, n, r)", "balanced", "order", "radius"], "params": [["(3, 1000, 30)", "(8, 1000, 30)", "(16, 1000, 30)"], ["True", "False"], ["'random'", "'sorted'"], ["0.5"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "395e405c839e9254e33e4d090b3bce650223754da2f1d4762069c7bd35fc562b", "warmup_time": -1}, "spatial.RotationBench.time_euler_conversion": {"code": "class RotationBench:\n    def time_euler_conversion(self, num_rotations):\n        '''Time converting rotation from and to euler angles'''\n        Rotation.from_euler(\"XYZ\", self.rotations.as_euler(\"XYZ\"))\n\n    def setup(self, num_rotations):\n        rng = np.random.default_rng(1234)\n        self.rotations = Rotation.random(num_rotations, random_state=rng)", "min_run_count": 2, "name": "spatial.RotationBench.time_euler_conversion", "number": 0, "param_names": ["num_rotations"], "params": [["1", "10", "1000", "10000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "317bef92ceb488d896f9e3fdeb5b679cf33775c842b0d69cb6cc86539c1140c7", "warmup_time": -1}, "spatial.RotationBench.time_matrix_conversion": {"code": "class RotationBench:\n    def time_matrix_conversion(self, num_rotations):\n        '''Time converting rotation from and to matrices'''\n        Rotation.from_matrix(self.rotations.as_matrix())\n\n    def setup(self, num_rotations):\n        rng = np.random.default_rng(1234)\n        self.rotations = Rotation.random(num_rotations, random_state=rng)", "min_run_count": 2, "name": "spatial.RotationBench.time_matrix_conversion", "number": 0, "param_names": ["num_rotations"], "params": [["1", "10", "1000", "10000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "941e658ebc52487aa8f391138f5dfcfa6f10ab6de655aac8db72e5a231efcfc5", "warmup_time": -1}, "spatial.RotationBench.time_mrp_conversion": {"code": "class RotationBench:\n    def time_mrp_conversion(self, num_rotations):\n        '''Time converting rotation from and to Modified Rodrigues Parameters'''\n        Rotation.from_mrp(self.rotations.as_mrp())\n\n    def setup(self, num_rotations):\n        rng = np.random.default_rng(1234)\n        self.rotations = Rotation.random(num_rotations, random_state=rng)", "min_run_count": 2, "name": "spatial.RotationBench.time_mrp_conversion", "number": 0, "param_names": ["num_rotations"], "params": [["1", "10", "1000", "10000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "06071e9ec00b90e3db994e7cbfc50bf3c434cf8f73d361e8f9d46d1580975b42", "warmup_time": -1}, "spatial.RotationBench.time_mul_inv": {"code": "class RotationBench:\n    def time_mul_inv(self, num_rotations):\n        '''Time multiplication and inverse of rotations'''\n        self.rotations * self.rotations.inv()\n\n    def setup(self, num_rotations):\n        rng = np.random.default_rng(1234)\n        self.rotations = Rotation.random(num_rotations, random_state=rng)", "min_run_count": 2, "name": "spatial.RotationBench.time_mul_inv", "number": 0, "param_names": ["num_rotations"], "params": [["1", "10", "1000", "10000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d9360181db56596df96c9a090a60487a253787016004be6f38880e7fa5cfa01a", "warmup_time": -1}, "spatial.RotationBench.time_rotvec_conversion": {"code": "class RotationBench:\n    def time_rotvec_conversion(self, num_rotations):\n        '''Time converting rotation from and to rotation vectors'''\n        Rotation.from_rotvec(self.rotations.as_rotvec())\n\n    def setup(self, num_rotations):\n        rng = np.random.default_rng(1234)\n        self.rotations = Rotation.random(num_rotations, random_state=rng)", "min_run_count": 2, "name": "spatial.RotationBench.time_rotvec_conversion", "number": 0, "param_names": ["num_rotations"], "params": [["1", "10", "1000", "10000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "95d00c40e16a565254066fe193bd2657b526df4851e5412e5c2ef3f05fbb8c73", "warmup_time": -1}, "spatial.SphericalVor.time_spherical_voronoi_calculation": {"code": "class SphericalVor:\n    def time_spherical_voronoi_calculation(self, num_points):\n        \"\"\"Perform spherical Voronoi calculation, but not the sorting of\n        vertices in the Voronoi polygons.\n        \"\"\"\n        SphericalVoronoi(self.points, radius=1, center=np.zeros(3))\n\n    def setup(self, num_points):\n        self.points = generate_spherical_points(num_points)", "min_run_count": 2, "name": "spatial.SphericalVor.time_spherical_voronoi_calculation", "number": 0, "param_names": ["num_points"], "params": [["10", "100", "1000", "5000", "10000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "108f4b104274b35e6ca904743fa9210c9aa3d2ca795577921ed22ab709f57684", "warmup_time": -1}, "spatial.SphericalVorAreas.time_spherical_polygon_area_calculation": {"code": "class SphericalVorAreas:\n    def time_spherical_polygon_area_calculation(self, num_points):\n        \"\"\"Time the area calculation in the Spherical Voronoi code.\"\"\"\n        self.sv.calculate_areas()\n\n    def setup(self, num_points):\n        self.points = generate_spherical_points(num_points)\n        self.sv = SphericalVoronoi(self.points, radius=1,\n                                   center=np.zeros(3))", "min_run_count": 2, "name": "spatial.SphericalVorAreas.time_spherical_polygon_area_calculation", "number": 0, "param_names": ["num_points"], "params": [["10", "100", "1000", "5000", "10000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "88caac659e86b94c166b03a7f78598dcd94d06f476f1f551f098a82095dc12e2", "warmup_time": -1}, "spatial.SphericalVorSort.time_spherical_polygon_vertex_sorting": {"code": "class SphericalVorSort:\n    def time_spherical_polygon_vertex_sorting(self, num_points):\n        \"\"\"Time the vertex sorting operation in the Spherical Voronoi\n        code.\n        \"\"\"\n        self.sv.sort_vertices_of_regions()\n\n    def setup(self, num_points):\n        self.points = generate_spherical_points(num_points)\n        self.sv = SphericalVoronoi(self.points, radius=1,\n                                   center=np.zeros(3))", "min_run_count": 2, "name": "spatial.SphericalVorSort.time_spherical_polygon_vertex_sorting", "number": 0, "param_names": ["num_points"], "params": [["10", "100", "1000", "5000", "10000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0f28dddb4c82c668099fe3a69f65ab059cfb4b7614a4444f0fd6d7c0d8dd7799", "warmup_time": -1}, "spatial.VoronoiBench.time_voronoi_calculation": {"code": "class VoronoiBench:\n    def time_voronoi_calculation(self, num_points, furthest_site):\n        \"\"\"Time conventional Voronoi diagram calculation.\"\"\"\n        Voronoi(self.points, furthest_site=furthest_site)\n\n    def setup(self, num_points, furthest_site):\n        rng = np.random.default_rng(123)\n        self.points = rng.random((num_points, 3))", "min_run_count": 2, "name": "spatial.VoronoiBench.time_voronoi_calculation", "number": 0, "param_names": ["num_points", "furthest_site"], "params": [["10", "100", "1000", "5000", "10000"], ["False", "True"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "32ec5cd864ed7eadb4d0aba633fa1af9109a3e15a9c58bd4b134208e93ac128d", "warmup_time": -1}, "spatial.Xdist.time_cdist": {"code": "class Xdist:\n    def time_cdist(self, num_points, metric):\n        \"\"\"Time scipy.spatial.distance.cdist over a range of input data\n        sizes and metrics.\n        \"\"\"\n        distance.cdist(self.points, self.points, self.metric, **self.kwargs)\n\n    def setup(self, num_points, metric):\n        rng = np.random.default_rng(123)\n        self.points = rng.random((num_points, 3))\n        self.metric = metric\n        if metric == 'minkowski-P3':\n            # p=2 is just the euclidean metric, try another p value as well\n            self.kwargs = {'p': 3.0}\n            self.metric = 'minkowski'\n        elif metric == 'wminkowski':\n            # use an equal weight vector since weights are required\n            self.kwargs = {'w': np.ones(3)}\n        else:\n            self.kwargs = {}", "min_run_count": 2, "name": "spatial.Xdist.time_cdist", "number": 0, "param_names": ["num_points", "metric"], "params": [["10", "100", "1000"], ["'euclidean'", "'minkowski'", "'cityblock'", "'seuclidean'", "'sqeuclidean'", "'cosine'", "'correlation'", "'hamming'", "'jaccard'", "'jensenshannon'", "'chebyshev'", "'canberra'", "'braycurtis'", "'mahalanobis'", "'yule'", "'dice'", "'kulsinski'", "'rogerstanimoto'", "'russellrao'", "'sokalmichener'", "'sokalsneath'", "'wminkowski'", "'minkowski-P3'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5b5ebb86a4332eb40947ef6f66245427e9c28cddbbd940096e700fdccf652163", "warmup_time": -1}, "spatial.Xdist.time_pdist": {"code": "class Xdist:\n    def time_pdist(self, num_points, metric):\n        \"\"\"Time scipy.spatial.distance.pdist over a range of input data\n        sizes and metrics.\n        \"\"\"\n        distance.pdist(self.points, self.metric, **self.kwargs)\n\n    def setup(self, num_points, metric):\n        rng = np.random.default_rng(123)\n        self.points = rng.random((num_points, 3))\n        self.metric = metric\n        if metric == 'minkowski-P3':\n            # p=2 is just the euclidean metric, try another p value as well\n            self.kwargs = {'p': 3.0}\n            self.metric = 'minkowski'\n        elif metric == 'wminkowski':\n            # use an equal weight vector since weights are required\n            self.kwargs = {'w': np.ones(3)}\n        else:\n            self.kwargs = {}", "min_run_count": 2, "name": "spatial.Xdist.time_pdist", "number": 0, "param_names": ["num_points", "metric"], "params": [["10", "100", "1000"], ["'euclidean'", "'minkowski'", "'cityblock'", "'seuclidean'", "'sqeuclidean'", "'cosine'", "'correlation'", "'hamming'", "'jaccard'", "'jensenshannon'", "'chebyshev'", "'canberra'", "'braycurtis'", "'mahalanobis'", "'yule'", "'dice'", "'kulsinski'", "'rogerstanimoto'", "'russellrao'", "'sokalmichener'", "'sokalsneath'", "'wminkowski'", "'minkowski-P3'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5c1a3b45b059d79c1b0fd8d4ed007720aa6e75921bae8ba343c4169ddf36df40", "warmup_time": -1}, "spatial.XdistWeighted.time_cdist": {"code": "class XdistWeighted:\n    def time_cdist(self, num_points, metric):\n        \"\"\"Time scipy.spatial.distance.cdist for weighted distance metrics.\"\"\"\n        distance.cdist(self.points, self.points, self.metric, w=self.weights,\n                       **self.kwargs)\n\n    def setup(self, num_points, metric):\n        rng = np.random.default_rng(123)\n        self.points = rng.random((num_points, 3))\n        self.metric = metric\n        if metric == 'minkowski-P3':\n            # p=2 is just the euclidean metric, try another p value as well\n            self.kwargs = {'p': 3.0}\n            self.metric = 'minkowski'\n        else:\n            self.kwargs = {}\n        self.weights = np.ones(3)", "min_run_count": 2, "name": "spatial.XdistWeighted.time_cdist", "number": 0, "param_names": ["num_points", "metric"], "params": [["10", "20", "100"], ["'euclidean'", "'minkowski'", "'cityblock'", "'sqeuclidean'", "'cosine'", "'correlation'", "'hamming'", "'jaccard'", "'chebyshev'", "'canberra'", "'braycurtis'", "'yule'", "'dice'", "'kulsinski'", "'rogerstanimoto'", "'russellrao'", "'sokalmichener'", "'sokalsneath'", "'minkowski-P3'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e1f4bf316e630291b53be079f149d57b062235f0fee0bdb623c31d2e00e56f09", "warmup_time": -1}, "spatial.XdistWeighted.time_pdist": {"code": "class XdistWeighted:\n    def time_pdist(self, num_points, metric):\n        \"\"\"Time scipy.spatial.distance.pdist for weighted distance metrics.\"\"\"\n        distance.pdist(self.points, self.metric, w=self.weights, **self.kwargs)\n\n    def setup(self, num_points, metric):\n        rng = np.random.default_rng(123)\n        self.points = rng.random((num_points, 3))\n        self.metric = metric\n        if metric == 'minkowski-P3':\n            # p=2 is just the euclidean metric, try another p value as well\n            self.kwargs = {'p': 3.0}\n            self.metric = 'minkowski'\n        else:\n            self.kwargs = {}\n        self.weights = np.ones(3)", "min_run_count": 2, "name": "spatial.XdistWeighted.time_pdist", "number": 0, "param_names": ["num_points", "metric"], "params": [["10", "20", "100"], ["'euclidean'", "'minkowski'", "'cityblock'", "'sqeuclidean'", "'cosine'", "'correlation'", "'hamming'", "'jaccard'", "'chebyshev'", "'canberra'", "'braycurtis'", "'yule'", "'dice'", "'kulsinski'", "'rogerstanimoto'", "'russellrao'", "'sokalmichener'", "'sokalsneath'", "'minkowski-P3'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "03b3befb7962cf01f7b724a86bc0394bcf361385da583bdcb1fa33d35b03cec2", "warmup_time": -1}, "special.Airy.time_ai_zeros": {"code": "class Airy:\n    def time_ai_zeros(self):\n        ai_zeros(100000)", "min_run_count": 2, "name": "special.Airy.time_ai_zeros", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9dcceb9408571060b6f02873fc4072f931f718ea2f5236772dddfc22332775d9", "warmup_time": -1}, "special.Airy.time_bi_zeros": {"code": "class Airy:\n    def time_bi_zeros(self):\n        bi_zeros(100000)", "min_run_count": 2, "name": "special.Airy.time_bi_zeros", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5a9724705235ef858c333ec7dae598b7e1557a4ecb55bf8608e91b5d3def7fc5", "warmup_time": -1}, "special.Comb.time_comb_exact": {"code": "class Comb:\n    @with_attributes(params=[(10, 100, 1000, 10000), (1, 10, 100)],\n                     param_names=['N', 'k'])\n    def time_comb_exact(self, N, k):\n        comb(N, k, exact=True)\n\n    def setup(self, *args):\n        self.N = np.arange(1, 1000, 50)\n        self.k = np.arange(1, 1000, 50)", "min_run_count": 2, "name": "special.Comb.time_comb_exact", "number": 0, "param_names": ["N", "k"], "params": [["10", "100", "1000", "10000"], ["1", "10", "100"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "640e03cb54bf500a9bb17a4558953841df67530fcc79cc6e256cff86801d934d", "warmup_time": -1}, "special.Comb.time_comb_float": {"code": "class Comb:\n    def time_comb_float(self):\n        comb(self.N[:,None], self.k[None,:])\n\n    def setup(self, *args):\n        self.N = np.arange(1, 1000, 50)\n        self.k = np.arange(1, 1000, 50)", "min_run_count": 2, "name": "special.Comb.time_comb_float", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "eaba845dac64e3a2ba0e5f67ff1bead19bcf0c033840ec965fc4d85582db711b", "warmup_time": -1}, "special.Erf.time_real": {"code": "class Erf:\n    def time_real(self, offset):\n        erf(self.rand + offset)\n\n    def setup(self, *args):\n        self.rand = np.random.rand(100000)", "min_run_count": 2, "name": "special.Erf.time_real", "number": 0, "param_names": ["offset"], "params": [["0.0", "2.0"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c985228bb6ecc680410d024c8c4ab56fa00a95b155e405c029044b487e93ab3a", "warmup_time": -1}, "special.Expn.time_expn_large_n": {"code": "class Expn:\n    def time_expn_large_n(self):\n        expn(self.n, self.x)\n\n    def setup(self):\n        n, x = np.arange(50, 500), np.logspace(0, 20, 100)\n        n, x = np.meshgrid(n, x)\n        self.n, self.x = n, x", "min_run_count": 2, "name": "special.Expn.time_expn_large_n", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1579c9226a7e0ebb2047466a04620c619f219cd514361ff859b0381365c498ab", "warmup_time": -1}, "special.Factorial.time_factorial_exact_false_array_negative_float": {"code": "class Factorial:\n    def time_factorial_exact_false_array_negative_float(self):\n        factorial(self.negative_floats, exact=False)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(10, 111, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints\n        self.positive_floats = np.linspace(100.2, 1000.8, num=10)\n        self.negative_floats = -1 * self.positive_floats", "min_run_count": 2, "name": "special.Factorial.time_factorial_exact_false_array_negative_float", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "52f4bb82b807563db9baf1731697c85d5cb81caf4c0feac66f6c56e22a4593e8", "warmup_time": -1}, "special.Factorial.time_factorial_exact_false_array_negative_int": {"code": "class Factorial:\n    def time_factorial_exact_false_array_negative_int(self):\n        factorial(self.negative_ints, exact=False)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(10, 111, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints\n        self.positive_floats = np.linspace(100.2, 1000.8, num=10)\n        self.negative_floats = -1 * self.positive_floats", "min_run_count": 2, "name": "special.Factorial.time_factorial_exact_false_array_negative_int", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "027e7a0d776fcd4d608054aef9403d6128ab8d2b633d6eb73b7e78856d7a4c36", "warmup_time": -1}, "special.Factorial.time_factorial_exact_false_array_positive_float": {"code": "class Factorial:\n    def time_factorial_exact_false_array_positive_float(self):\n        factorial(self.positive_floats, exact=False)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(10, 111, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints\n        self.positive_floats = np.linspace(100.2, 1000.8, num=10)\n        self.negative_floats = -1 * self.positive_floats", "min_run_count": 2, "name": "special.Factorial.time_factorial_exact_false_array_positive_float", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d2490cf130f6a09f01e4b2a8968b890b85bc35e9cda4f9483b4b907297f6a2cd", "warmup_time": -1}, "special.Factorial.time_factorial_exact_false_array_positive_int": {"code": "class Factorial:\n    def time_factorial_exact_false_array_positive_int(self):\n        factorial(self.positive_ints, exact=False)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(10, 111, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints\n        self.positive_floats = np.linspace(100.2, 1000.8, num=10)\n        self.negative_floats = -1 * self.positive_floats", "min_run_count": 2, "name": "special.Factorial.time_factorial_exact_false_array_positive_int", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3491c872d831a258a69fca05689ed23787c46da5b94694a27a5cb3da82942f7b", "warmup_time": -1}, "special.Factorial.time_factorial_exact_false_scalar_negative_float": {"code": "class Factorial:\n    def time_factorial_exact_false_scalar_negative_float(self):\n        factorial(-10000.8, exact=False)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(10, 111, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints\n        self.positive_floats = np.linspace(100.2, 1000.8, num=10)\n        self.negative_floats = -1 * self.positive_floats", "min_run_count": 2, "name": "special.Factorial.time_factorial_exact_false_scalar_negative_float", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "96d9c74b881904bd3e56b4268555ce76384be044bd2593bca8b76f7f955d7d3e", "warmup_time": -1}, "special.Factorial.time_factorial_exact_false_scalar_negative_int": {"code": "class Factorial:\n    def time_factorial_exact_false_scalar_negative_int(self):\n        factorial(-10000, exact=False)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(10, 111, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints\n        self.positive_floats = np.linspace(100.2, 1000.8, num=10)\n        self.negative_floats = -1 * self.positive_floats", "min_run_count": 2, "name": "special.Factorial.time_factorial_exact_false_scalar_negative_int", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "edc3d5a8947384d3d2d1168f417a84141e20628780a195cbbfa3dc252fa8c203", "warmup_time": -1}, "special.Factorial.time_factorial_exact_false_scalar_positive_float": {"code": "class Factorial:\n    @with_attributes(params=[(100.8, 1000.3, 10000.5)],\n                     param_names=['n'])\n    def time_factorial_exact_false_scalar_positive_float(self, n):\n        factorial(n, exact=False)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(10, 111, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints\n        self.positive_floats = np.linspace(100.2, 1000.8, num=10)\n        self.negative_floats = -1 * self.positive_floats", "min_run_count": 2, "name": "special.Factorial.time_factorial_exact_false_scalar_positive_float", "number": 0, "param_names": ["n"], "params": [["100.8", "1000.3", "10000.5"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2556b14897979afdb5ff30d8772766733b2b3a4099b2ebce0f3f3fcb36f01b2c", "warmup_time": -1}, "special.Factorial.time_factorial_exact_false_scalar_positive_int": {"code": "class Factorial:\n    @with_attributes(params=[(100, 1000, 10000)],\n                     param_names=['n'])\n    def time_factorial_exact_false_scalar_positive_int(self, n):\n        factorial(n, exact=False)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(10, 111, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints\n        self.positive_floats = np.linspace(100.2, 1000.8, num=10)\n        self.negative_floats = -1 * self.positive_floats", "min_run_count": 2, "name": "special.Factorial.time_factorial_exact_false_scalar_positive_int", "number": 0, "param_names": ["n"], "params": [["100", "1000", "10000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1c67c71f22fb6ba9b15651170d51dc6f4acf1faf4170c00a2aaec4f3ce16c41c", "warmup_time": -1}, "special.Factorial.time_factorial_exact_true_array_negative_float": {"code": "class Factorial:\n    def time_factorial_exact_true_array_negative_float(self):\n        factorial(self.negative_floats, exact=True)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(10, 111, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints\n        self.positive_floats = np.linspace(100.2, 1000.8, num=10)\n        self.negative_floats = -1 * self.positive_floats", "min_run_count": 2, "name": "special.Factorial.time_factorial_exact_true_array_negative_float", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "83b76206cb3d1a79bac38d0fa6f4a3bc91d34be23947125ef2ad90da5e0aceac", "warmup_time": -1}, "special.Factorial.time_factorial_exact_true_array_negative_int": {"code": "class Factorial:\n    def time_factorial_exact_true_array_negative_int(self):\n        factorial(self.negative_ints, exact=True)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(10, 111, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints\n        self.positive_floats = np.linspace(100.2, 1000.8, num=10)\n        self.negative_floats = -1 * self.positive_floats", "min_run_count": 2, "name": "special.Factorial.time_factorial_exact_true_array_negative_int", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "62e6998b2d87f26260ef15baeb2c63676539bd7b2df8b7f7e3a281ef330ff650", "warmup_time": -1}, "special.Factorial.time_factorial_exact_true_array_positive_int": {"code": "class Factorial:\n    def time_factorial_exact_true_array_positive_int(self):\n        factorial(self.positive_ints, exact=True)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(10, 111, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints\n        self.positive_floats = np.linspace(100.2, 1000.8, num=10)\n        self.negative_floats = -1 * self.positive_floats", "min_run_count": 2, "name": "special.Factorial.time_factorial_exact_true_array_positive_int", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2d2cb98b7434deac576c791e380b86c3934f9750dd5315c4cecfd2a7c5be4027", "warmup_time": -1}, "special.Factorial.time_factorial_exact_true_scalar_negative_float": {"code": "class Factorial:\n    def time_factorial_exact_true_scalar_negative_float(self):\n        factorial(-10000.8, exact=True)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(10, 111, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints\n        self.positive_floats = np.linspace(100.2, 1000.8, num=10)\n        self.negative_floats = -1 * self.positive_floats", "min_run_count": 2, "name": "special.Factorial.time_factorial_exact_true_scalar_negative_float", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6cc0c61b90f8715124ad96dfe819bb9d1571ae666fec8f3975aff95869f211cd", "warmup_time": -1}, "special.Factorial.time_factorial_exact_true_scalar_negative_int": {"code": "class Factorial:\n    def time_factorial_exact_true_scalar_negative_int(self):\n        factorial(-10000, exact=True)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(10, 111, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints\n        self.positive_floats = np.linspace(100.2, 1000.8, num=10)\n        self.negative_floats = -1 * self.positive_floats", "min_run_count": 2, "name": "special.Factorial.time_factorial_exact_true_scalar_negative_int", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0ba7ce5f97627d762ba86570c0947805cb66616be5b22e9ca59e8c399ccc8333", "warmup_time": -1}, "special.Factorial.time_factorial_exact_true_scalar_positive_int": {"code": "class Factorial:\n    @with_attributes(params=[(100, 200, 400)],\n                     param_names=['n'])\n    def time_factorial_exact_true_scalar_positive_int(self, n):\n        factorial(n, exact=True)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(10, 111, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints\n        self.positive_floats = np.linspace(100.2, 1000.8, num=10)\n        self.negative_floats = -1 * self.positive_floats", "min_run_count": 2, "name": "special.Factorial.time_factorial_exact_true_scalar_positive_int", "number": 0, "param_names": ["n"], "params": [["100", "200", "400"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3887e0a19b629929794ac2c1ee028d41a71d8ff986d18ac57590c109c0ed00eb", "warmup_time": -1}, "special.Factorial2.time_factorial2_exact_false_array_negative_int": {"code": "class Factorial2:\n    def time_factorial2_exact_false_array_negative_int(self):\n        factorial2(self.negative_ints, exact=False)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(100, 201, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints", "min_run_count": 2, "name": "special.Factorial2.time_factorial2_exact_false_array_negative_int", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1b77c8a78527e72085470594c22b6980b14f23995415d8b42dee2e8ba6c42728", "warmup_time": -1}, "special.Factorial2.time_factorial2_exact_false_array_positive_int": {"code": "class Factorial2:\n    def time_factorial2_exact_false_array_positive_int(self):\n        factorial2(self.positive_ints, exact=False)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(100, 201, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints", "min_run_count": 2, "name": "special.Factorial2.time_factorial2_exact_false_array_positive_int", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "269ab42491b1df6b2340ae99e451064ed72d938513912a31b581b7b99f8752d3", "warmup_time": -1}, "special.Factorial2.time_factorial2_exact_false_scalar_negative_int": {"code": "class Factorial2:\n    def time_factorial2_exact_false_scalar_negative_int(self):\n        factorial2(-10000, exact=False)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(100, 201, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints", "min_run_count": 2, "name": "special.Factorial2.time_factorial2_exact_false_scalar_negative_int", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8e3ebe5412028d7c9b80084a8f8909f4967b61d64e309360da682e617fcb1d24", "warmup_time": -1}, "special.Factorial2.time_factorial2_exact_false_scalar_positive_int": {"code": "class Factorial2:\n    @with_attributes(params=[(100, 200, 400)],\n                     param_names=['n'])\n    def time_factorial2_exact_false_scalar_positive_int(self, n):\n        factorial2(n, exact=False)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(100, 201, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints", "min_run_count": 2, "name": "special.Factorial2.time_factorial2_exact_false_scalar_positive_int", "number": 0, "param_names": ["n"], "params": [["100", "200", "400"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9103ec47b020aec0e0e6b42a0284980d952d74f59d42f02bef00070b3f1bec62", "warmup_time": -1}, "special.Factorial2.time_factorial2_exact_true_scalar_negative_int": {"code": "class Factorial2:\n    def time_factorial2_exact_true_scalar_negative_int(self):\n        factorial2(-10000, exact=True)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(100, 201, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints", "min_run_count": 2, "name": "special.Factorial2.time_factorial2_exact_true_scalar_negative_int", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "40adb7033cda41a81a61fbc58839e5f84dd57d0400257fbae82efdf69072ecd9", "warmup_time": -1}, "special.Factorial2.time_factorial2_exact_true_scalar_positive_int": {"code": "class Factorial2:\n    @with_attributes(params=[(100, 200, 400)],\n                     param_names=['n'])\n    def time_factorial2_exact_true_scalar_positive_int(self, n):\n        factorial2(n, exact=True)\n\n    def setup(self, *args):\n        self.positive_ints = np.arange(100, 201, step=20, dtype=int)\n        self.negative_ints = -1 * self.positive_ints", "min_run_count": 2, "name": "special.Factorial2.time_factorial2_exact_true_scalar_positive_int", "number": 0, "param_names": ["n"], "params": [["100", "200", "400"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3c00cb739b243c1ec018df42506617f8efc9a33b87efa4e5b35ebd889106a1b8", "warmup_time": -1}, "special.FactorialK.time_factorialk_exact_false_scalar_negative_int": {"code": "class FactorialK:\n    def time_factorialk_exact_false_scalar_negative_int(self):\n        factorialk(-10000, 3, exact=True)", "min_run_count": 2, "name": "special.FactorialK.time_factorialk_exact_false_scalar_negative_int", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7104a9bf068a517a1dcc6073c833f3161184b9b1170932e0455cd11ff5a8382c", "warmup_time": -1}, "special.FactorialK.time_factorialk_exact_true_scalar_positive_int": {"code": "class FactorialK:\n    @with_attributes(params=[(100, 500), range(1, 10)],\n                     param_names=['n', 'k'])\n    def time_factorialk_exact_true_scalar_positive_int(self, n, k):\n        factorialk(n, k, exact=True)", "min_run_count": 2, "name": "special.FactorialK.time_factorialk_exact_true_scalar_positive_int", "number": 0, "param_names": ["n", "k"], "params": [["100", "500"], ["1", "2", "3", "4", "5", "6", "7", "8", "9"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c20d9cfb24931092405db32dc72e47695359d489cdfdce4bf2bc5c63840fd05b", "warmup_time": -1}, "special.Loggamma.time_loggamma_asymptotic": {"code": "class Loggamma:\n    def time_loggamma_asymptotic(self):\n        loggamma(self.large_z)\n\n    def setup(self):\n        x, y = np.logspace(3, 5, 10), np.logspace(3, 5, 10)\n        x, y = np.meshgrid(x, y)\n        self.large_z = x + 1j*y", "min_run_count": 2, "name": "special.Loggamma.time_loggamma_asymptotic", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "fc273c10f60175c84fce376754825356457225e1b78d83e3beabbf886352585a", "warmup_time": -1}, "stats.ANOVAFunction.time_f_oneway": {"code": "class ANOVAFunction:\n    def time_f_oneway(self):\n        statistic, pvalue = stats.f_oneway(self.a, self.b, self.c)\n        statistic, pvalue = stats.f_oneway(self.a, self.b, self.c, axis=1)\n\n    def setup(self):\n        rng = np.random.default_rng(12345678)\n        self.a = rng.random((6,3)) * 10\n        self.b = rng.random((6,3)) * 10\n        self.c = rng.random((6,3)) * 10", "min_run_count": 2, "name": "stats.ANOVAFunction.time_f_oneway", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "cef34d59506cffae002ae1bc160af2e5d0663aee6610a49d1a1226fd29279fb4", "warmup_time": -1}, "stats.Anderson_KSamp.time_anderson_ksamp": {"code": "class Anderson_KSamp:\n    def time_anderson_ksamp(self):\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore', UserWarning)\n            stats.anderson_ksamp(self.rand)\n\n    def setup(self, *args):\n        self.rand = [np.random.normal(loc=i, size=1000) for i in range(3)]", "min_run_count": 2, "name": "stats.Anderson_KSamp.time_anderson_ksamp", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "339fc253c3add6deadbc1edc1112cf1b1fff85f70f57aeb9dd81e0ea23de9384", "warmup_time": -1}, "stats.BenchMoment.time_moment": {"code": "class BenchMoment:\n    def time_moment(self, order, size):\n        stats.moment(self.x, order)\n\n    def setup(self, order, size):\n        np.random.random(1234)\n        self.x = np.random.random(size)", "min_run_count": 2, "name": "stats.BenchMoment.time_moment", "number": 0, "param_names": ["order", "size"], "params": [["1", "2", "3", "8"], ["100", "1000", "10000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "10b78316c2b4c34d35f14269b05b4a47ecc2cb83dd5c864d6d19ea7d660fe3ea", "warmup_time": -1}, "stats.BenchQMCDiscrepancy.time_discrepancy": {"code": "class BenchQMCDiscrepancy:\n    def time_discrepancy(self, method):\n        disc = stats.qmc.discrepancy(self.sample, method=method)\n\n    def setup(self, method):\n        rng = np.random.default_rng(1234)\n        sample = rng.random((1000, 10))\n        self.sample = sample", "min_run_count": 2, "name": "stats.BenchQMCDiscrepancy.time_discrepancy", "number": 0, "param_names": ["method"], "params": [["'CD'", "'WD'", "'MD'", "'L2-star'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ec7d2d3338198de06cd2b52b697f8bd2396d55eb2c575a67686ff32a83c126a3", "warmup_time": -1}, "stats.BenchQMCHalton.time_halton": {"code": "class BenchQMCHalton:\n    def time_halton(self, d, scramble, n, workers):\n        seq = stats.qmc.Halton(d, scramble=scramble, seed=self.rng)\n        seq.random(n, workers=workers)\n\n    def setup(self, d, scramble, n, workers):\n        self.rng = np.random.default_rng(1234)", "min_run_count": 2, "name": "stats.BenchQMCHalton.time_halton", "number": 0, "param_names": ["d", "scramble", "n", "workers"], "params": [["1", "10"], ["True", "False"], ["10", "1000", "100000"], ["1", "4"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "89c2063cf24f2f43ae17d191bb2ba0a5841f0cb1a0a9f791e2e14e70aa884f08", "warmup_time": -1}, "stats.BenchQMCSobol.time_sobol": {"code": "class BenchQMCSobol:\n    def time_sobol(self, d, base2):\n        # scrambling is happening at init only, not worth checking\n        seq = stats.qmc.Sobol(d, scramble=False, bits=32, seed=self.rng)\n        seq.random_base2(base2)\n\n    def setup(self, d, base2):\n        self.rng = np.random.default_rng(168525179735951991038384544)\n        stats.qmc.Sobol(1, bits=32)  # make it load direction numbers", "min_run_count": 2, "name": "stats.BenchQMCSobol.time_sobol", "number": 0, "param_names": ["d", "base2"], "params": [["1", "50", "100"], ["3", "10", "11", "12"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d41585ac7d1c696a19e0a10bf372b493122bbdd395085430170744471a0d6676", "warmup_time": -1}, "stats.BenchSkewKurtosis.time_kurtosis": {"code": "class BenchSkewKurtosis:\n    def time_kurtosis(self, order, size, bias):\n        stats.kurtosis(self.x, bias=bias)\n\n    def setup(self, order, size, bias):\n        np.random.random(1234)\n        self.x = np.random.random(size)", "min_run_count": 2, "name": "stats.BenchSkewKurtosis.time_kurtosis", "number": 0, "param_names": ["order", "size", "bias"], "params": [["1", "2", "3", "8"], ["100", "1000", "10000"], ["False", "True"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "404e2f215122985b9853a3c8c9d11a8b7e2299624fc7ae4542663780f2fbacca", "warmup_time": -1}, "stats.BenchSkewKurtosis.time_skew": {"code": "class BenchSkewKurtosis:\n    def time_skew(self, order, size, bias):\n        stats.skew(self.x, bias=bias)\n\n    def setup(self, order, size, bias):\n        np.random.random(1234)\n        self.x = np.random.random(size)", "min_run_count": 2, "name": "stats.BenchSkewKurtosis.time_skew", "number": 0, "param_names": ["order", "size", "bias"], "params": [["1", "2", "3", "8"], ["100", "1000", "10000"], ["False", "True"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7ba4ed309da2b86678985696e2619be245f9c103916d1a9bd457cafc7ed9b3e9", "warmup_time": -1}, "stats.BinnedStatisticDD.time_binned_statistic_dd": {"code": "class BinnedStatisticDD:\n    def time_binned_statistic_dd(self, statistic):\n        stats.binned_statistic_dd(\n            [self.inp[0], self.inp[1]], self.inp[2], statistic=statistic,\n            bins=[self.subbin_x_edges, self.subbin_y_edges])\n\n    def setup(self, statistic):\n        rng = np.random.default_rng(12345678)\n        self.inp = rng.random(9999).reshape(3, 3333) * 200\n        self.subbin_x_edges = np.arange(0, 200, dtype=np.float32)\n        self.subbin_y_edges = np.arange(0, 200, dtype=np.float64)\n        self.ret = stats.binned_statistic_dd(\n            [self.inp[0], self.inp[1]], self.inp[2], statistic=statistic,\n            bins=[self.subbin_x_edges, self.subbin_y_edges])", "min_run_count": 2, "name": "stats.BinnedStatisticDD.time_binned_statistic_dd", "number": 0, "param_names": ["param1"], "params": [["'count'", "'sum'", "'mean'", "'min'", "'max'", "'median'", "'std'", "<function std>"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7a3c87d67ca9e724d002df80767df631be17cf7d9d034b2cd1b4a17c631adc00", "warmup_time": -1}, "stats.BinnedStatisticDD.time_binned_statistic_dd_reuse_bin": {"code": "class BinnedStatisticDD:\n    def time_binned_statistic_dd_reuse_bin(self, statistic):\n        stats.binned_statistic_dd(\n            [self.inp[0], self.inp[1]], self.inp[2], statistic=statistic,\n            binned_statistic_result=self.ret)\n\n    def setup(self, statistic):\n        rng = np.random.default_rng(12345678)\n        self.inp = rng.random(9999).reshape(3, 3333) * 200\n        self.subbin_x_edges = np.arange(0, 200, dtype=np.float32)\n        self.subbin_y_edges = np.arange(0, 200, dtype=np.float64)\n        self.ret = stats.binned_statistic_dd(\n            [self.inp[0], self.inp[1]], self.inp[2], statistic=statistic,\n            bins=[self.subbin_x_edges, self.subbin_y_edges])", "min_run_count": 2, "name": "stats.BinnedStatisticDD.time_binned_statistic_dd_reuse_bin", "number": 0, "param_names": ["param1"], "params": [["'count'", "'sum'", "'mean'", "'min'", "'max'", "'median'", "'std'", "<function std>"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "82b2d5c6e62123e3b067049ef37d7bc6b1b72227cf39069214820e444c6819e7", "warmup_time": -1}, "stats.BrunnerMunzel.time_brunnermunzel": {"code": "class BrunnerMunzel:\n    def time_brunnermunzel(self, alternative, nan_policy, distribution):\n        stats.brunnermunzel(self.u1, self.u2, alternative=alternative,\n                            distribution=distribution, nan_policy=nan_policy)\n\n    def setup(self, alternative, nan_policy, distribution):\n        rng = np.random.default_rng(0xb82c4db22b2818bdbc5dbe15ad7528fe)\n        self.u1 = rng.uniform(-1, 1, 200)\n        self.u2 = rng.uniform(-0.5, 1.5, 300)", "min_run_count": 2, "name": "stats.BrunnerMunzel.time_brunnermunzel", "number": 0, "param_names": ["alternative", "nan_policy", "distribution"], "params": [["'two-sided'", "'less'", "'greater'"], ["'propagate'", "'raise'", "'omit'"], ["'t'", "'normal'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "929e16416fb3eb20df886125a507f7d074a5cbd223185cc646ab8483843632b3", "warmup_time": -1}, "stats.ContinuousFitAnalyticalMLEOverride.time_fit": {"code": "class ContinuousFitAnalyticalMLEOverride:\n    def time_fit(self, dist_name, loc_fixed, scale_fixed, shape1_fixed,\n                 shape2_fixed, shape3_fixed):\n        self.distn.fit(self.data, **self.fixed)\n\n    def setup(self, dist_name, loc_fixed, scale_fixed, shape1_fixed,\n              shape2_fixed, shape3_fixed):\n        self.distn = eval(\"stats.\" + dist_name)\n    \n        # default `loc` and `scale` are .834 and 4.342, and shapes are from\n        # `_distr_params.py`\n        default_shapes = self.distcont[dist_name]\n        param_values = self.custom_input.get(dist_name, [.834, 4.342,\n                                                         *default_shapes])\n        # separate relevant and non-relevant parameters for this distribution\n        # based on the number of shapes\n        nparam = len(param_values)\n        all_parameters = [loc_fixed, scale_fixed, shape1_fixed, shape2_fixed,\n                          shape3_fixed]\n        relevant_parameters = all_parameters[:nparam]\n        nonrelevant_parameters = all_parameters[nparam:]\n    \n        # skip if all parameters are fixed or if non relevant parameters are\n        # not all false\n        if True in nonrelevant_parameters or False not in relevant_parameters:\n            raise NotImplementedError(\"skip non-relevant case\")\n    \n        # add fixed values if fixed in relevant_parameters to self.fixed\n        # with keys from self.fnames and values from parameter_values\n        self.fixed = dict(zip(compress(self.fnames, relevant_parameters),\n                          compress(param_values, relevant_parameters)))\n        self.data = self.distn.rvs(*param_values, size=1000)", "min_run_count": 2, "name": "stats.ContinuousFitAnalyticalMLEOverride.time_fit", "number": 0, "param_names": ["distribution", "loc_fixed", "scale_fixed", "shape1_fixed", "shape2_fixed", "shape3_fixed"], "params": [["'pareto'", "'laplace'", "'rayleigh'", "'invgauss'", "'gumbel_r'", "'gumbel_l'"], ["True", "False"], ["True", "False"], ["True", "False"], ["True", "False"], ["True", "False"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "00ab390e8376de544acfcdfc3079f96a3d213a37c576fa752ffdd93d6711bc75", "warmup_time": -1}, "stats.CorrelationFunctions.time_barnard_exact": {"code": "class CorrelationFunctions:\n    def time_barnard_exact(self, alternative):\n        resBarnard = stats.barnard_exact(self.a, alternative=alternative)\n\n    def setup(self, mode):\n        a = np.random.rand(2,2) * 10\n        self.a = a", "min_run_count": 2, "name": "stats.CorrelationFunctions.time_barnard_exact", "number": 0, "param_names": ["alternative"], "params": [["'two-sided'", "'less'", "'greater'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8bfd6a8e8c9d0499c4e863e7fbe337dc69ecf2d0f4cc46f2c8ec2da49a01693c", "warmup_time": -1}, "stats.CorrelationFunctions.time_boschloo_exact": {"code": "class CorrelationFunctions:\n    def time_boschloo_exact(self, alternative):\n        resBoschloo = stats.boschloo_exact(self.a, alternative=alternative)\n\n    def setup(self, mode):\n        a = np.random.rand(2,2) * 10\n        self.a = a", "min_run_count": 2, "name": "stats.CorrelationFunctions.time_boschloo_exact", "number": 0, "param_names": ["alternative"], "params": [["'two-sided'", "'less'", "'greater'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "80b2babbd4d98ce10ec0d77cac7963732463b57be5a6cbcce73feda2e207c809", "warmup_time": -1}, "stats.CorrelationFunctions.time_fisher_exact": {"code": "class CorrelationFunctions:\n    def time_fisher_exact(self, alternative):\n        oddsratio, pvalue = stats.fisher_exact(self.a, alternative=alternative)\n\n    def setup(self, mode):\n        a = np.random.rand(2,2) * 10\n        self.a = a", "min_run_count": 2, "name": "stats.CorrelationFunctions.time_fisher_exact", "number": 0, "param_names": ["alternative"], "params": [["'two-sided'", "'less'", "'greater'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1b6fbd666591799952616c1c2b9786a0098344fa0a5e28a5b5cdb0df0b62f92a", "warmup_time": -1}, "stats.DescriptiveStats.time_mode": {"code": "class DescriptiveStats:\n    def time_mode(self, n_levels):\n        stats.mode(self.levels, axis=0)\n\n    def setup(self, n_levels):\n        rng = np.random.default_rng(12345678)\n        self.levels = rng.integers(n_levels, size=(1000, 10))", "min_run_count": 2, "name": "stats.DescriptiveStats.time_mode", "number": 0, "param_names": ["n_levels"], "params": [["10", "1000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f86630b539b378654085c43863880a1d482b02c7cc01eade90599efb9e32886a", "warmup_time": -1}, "stats.DistanceFunctions.time_energy_distance": {"code": "class DistanceFunctions:\n    def time_energy_distance(self, n_size):\n        distance = stats.energy_distance(\n                 self.u_values, self.v_values,\n                 self.u_weights, self.v_weights)\n\n    def setup(self, n_size):\n        rng = np.random.default_rng(12345678)\n        self.u_values = rng.random(n_size) * 10\n        self.u_weights = rng.random(n_size) * 10\n        self.v_values = rng.random(n_size // 2) * 10\n        self.v_weights = rng.random(n_size // 2) * 10", "min_run_count": 2, "name": "stats.DistanceFunctions.time_energy_distance", "number": 0, "param_names": ["n_size"], "params": [["10", "4000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5746629059f9114dbfe97400d67eda07ce74ecb137e5f1f70b7df3564f95b0aa", "warmup_time": -1}, "stats.DistanceFunctions.time_wasserstein_distance": {"code": "class DistanceFunctions:\n    def time_wasserstein_distance(self, n_size):\n        distance = stats.wasserstein_distance(\n                 self.u_values, self.v_values,\n                 self.u_weights, self.v_weights)\n\n    def setup(self, n_size):\n        rng = np.random.default_rng(12345678)\n        self.u_values = rng.random(n_size) * 10\n        self.u_weights = rng.random(n_size) * 10\n        self.v_values = rng.random(n_size // 2) * 10\n        self.v_weights = rng.random(n_size // 2) * 10", "min_run_count": 2, "name": "stats.DistanceFunctions.time_wasserstein_distance", "number": 0, "param_names": ["n_size"], "params": [["10", "4000"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8fd4e183f388121f6421934cbf90df4dba7ab7e139dcf17a27b5582fa9adae0d", "warmup_time": -1}, "stats.Distribution.time_distribution": {"code": "class Distribution:\n    def time_distribution(self, distribution, properties):\n        if distribution == 'gamma':\n            if properties == 'pdf':\n                stats.gamma.pdf(self.x, a=5, loc=4, scale=10)\n            elif properties == 'cdf':\n                stats.gamma.cdf(self.x, a=5, loc=4, scale=10)\n            elif properties == 'rvs':\n                stats.gamma.rvs(size=1000, a=5, loc=4, scale=10)\n            elif properties == 'fit':\n                stats.gamma.fit(self.x, loc=4, scale=10)\n        elif distribution == 'cauchy':\n            if properties == 'pdf':\n                stats.cauchy.pdf(self.x, loc=4, scale=10)\n            elif properties == 'cdf':\n                stats.cauchy.cdf(self.x, loc=4, scale=10)\n            elif properties == 'rvs':\n                stats.cauchy.rvs(size=1000, loc=4, scale=10)\n            elif properties == 'fit':\n                stats.cauchy.fit(self.x, loc=4, scale=10)\n        elif distribution == 'beta':\n            if properties == 'pdf':\n                stats.beta.pdf(self.x, a=5, b=3, loc=4, scale=10)\n            elif properties == 'cdf':\n                stats.beta.cdf(self.x, a=5, b=3, loc=4, scale=10)\n            elif properties == 'rvs':\n                stats.beta.rvs(size=1000, a=5, b=3, loc=4, scale=10)\n            elif properties == 'fit':\n                stats.beta.fit(self.x, loc=4, scale=10)\n\n    def setup(self, distribution, properties):\n        rng = np.random.default_rng(12345678)\n        self.x = rng.random(100)", "min_run_count": 2, "name": "stats.Distribution.time_distribution", "number": 0, "param_names": ["distribution", "properties"], "params": [["'cauchy'", "'gamma'", "'beta'"], ["'pdf'", "'cdf'", "'rvs'", "'fit'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "fb22ae5386501008d945783921fe44aef3f82c1dafc40cddfaccaeec38b792b0", "warmup_time": -1}, "stats.DistributionsAll.time_distribution": {"code": "class DistributionsAll:\n    def time_distribution(self, dist_name, method):\n        self.method(*self.args, **self.kwds)\n\n    def setup(self, dist_name, method):\n        if not is_xslow() and (dist_name in self.slow_dists\n                               or method in self.slow_methods):\n            raise NotImplementedError(\"Skipped\")\n    \n        self.dist = getattr(stats, dist_name)\n    \n        dist_shapes = self.dist_data[dist_name]\n    \n        if isinstance(self.dist, stats.rv_discrete):\n            # discrete distributions only use location\n            self.isCont = False\n            kwds = {'loc': 4}\n        else:\n            # continuous distributions use location and scale\n            self.isCont = True\n            kwds = {'loc': 4, 'scale': 10}\n    \n        bounds = self.dist.interval(.99, *dist_shapes, **kwds)\n        x = np.linspace(*bounds, 100)\n        args = [x, *self.custom_input.get(dist_name, dist_shapes)]\n        self.args = args\n        self.kwds = kwds\n        if method == 'fit':\n            # there are no fit methods for discrete distributions\n            if isinstance(self.dist, stats.rv_discrete):\n                raise NotImplementedError(\"This attribute is not a member \"\n                                          \"of the distribution\")\n            # the only positional argument is the data to be fitted\n            self.args = [self.dist.rvs(*dist_shapes, size=100, random_state=0, **kwds)]\n        elif method == 'rvs':\n            # add size keyword argument for data creation\n            kwds['size'] = 1000\n            kwds['random_state'] = 0\n            # keep shapes as positional arguments, omit linearly spaced data\n            self.args = args[1:]\n        elif method == 'pdf/pmf':\n            method = ('pmf' if isinstance(self.dist, stats.rv_discrete)\n                      else 'pdf')\n        elif method == 'logpdf/logpmf':\n            method = ('logpmf' if isinstance(self.dist, stats.rv_discrete)\n                      else 'logpdf')\n        elif method in ['ppf', 'isf']:\n            self.args = [np.linspace((0, 1), 100), *args[1:]]\n        elif method == 'moment':\n            # the first four moments may be optimized, so compute the fifth\n            self.args = [5, *args[1:]]\n        elif method.startswith('stats_'):\n            kwds['moments'] = method[6:]\n            method = 'stats'\n            self.args = args[1:]\n        elif method == 'entropy':\n            self.args = args[1:]\n    \n        self.method = getattr(self.dist, method)", "min_run_count": 2, "name": "stats.DistributionsAll.time_distribution", "number": 0, "param_names": ["dist_name", "method"], "params": [["'alpha'", "'anglit'", "'arcsine'", "'argus'", "'bernoulli'", "'beta'", "'betabinom'", "'betaprime'", "'binom'", "'boltzmann'", "'bradford'", "'burr'", "'burr12'", "'cauchy'", "'chi'", "'chi2'", "'cosine'", "'crystalball'", "'dgamma'", "'dlaplace'", "'dweibull'", "'erlang'", "'expon'", "'exponnorm'", "'exponpow'", "'exponweib'", "'f'", "'fatiguelife'", "'fisk'", "'foldcauchy'", "'foldnorm'", "'gamma'", "'gausshyper'", "'genexpon'", "'genextreme'", "'gengamma'", "'genhalflogistic'", "'genhyperbolic'", "'geninvgauss'", "'genlogistic'", "'gennorm'", "'genpareto'", "'geom'", "'gibrat'", "'gompertz'", "'gumbel_l'", "'gumbel_r'", "'halfcauchy'", "'halfgennorm'", "'halflogistic'", "'halfnorm'", "'hypergeom'", "'hypsecant'", "'invgamma'", "'invgauss'", "'invweibull'", "'johnsonsb'", "'johnsonsu'", "'kappa3'", "'kappa4'", "'ksone'", "'kstwo'", "'kstwobign'", "'laplace'", "'laplace_asymmetric'", "'levy'", "'levy_l'", "'levy_stable'", "'loggamma'", "'logistic'", "'loglaplace'", "'lognorm'", "'logser'", "'loguniform'", "'lomax'", "'maxwell'", "'mielke'", "'moyal'", "'nakagami'", "'nbinom'", "'ncf'", "'nchypergeom_fisher'", "'nchypergeom_wallenius'", "'nct'", "'ncx2'", "'nhypergeom'", "'norm'", "'norminvgauss'", "'pareto'", "'pearson3'", "'planck'", "'poisson'", "'powerlaw'", "'powerlognorm'", "'powernorm'", "'randint'", "'rayleigh'", "'rdist'", "'recipinvgauss'", "'reciprocal'", "'rice'", "'semicircular'", "'skellam'", "'skewcauchy'", "'skewnorm'", "'studentized_range'", "'t'", "'trapezoid'", "'triang'", "'truncexpon'", "'truncnorm'", "'truncweibull_min'", "'tukeylambda'", "'uniform'", "'vonmises'", "'vonmises_line'", "'wald'", "'weibull_max'", "'weibull_min'", "'wrapcauchy'", "'yulesimon'", "'zipf'", "'zipfian'"], ["'pdf/pmf'", "'logpdf/logpmf'", "'cdf'", "'logcdf'", "'rvs'", "'fit'", "'sf'", "'logsf'", "'ppf'", "'isf'", "'moment'", "'stats_s'", "'stats_v'", "'stats_m'", "'stats_k'", "'stats_mvsk'", "'entropy'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f25ead4e627cf3167961e84504bc57749793d87f7ae5fdeef86ead5b79f761b7", "warmup_time": -1}, "stats.GaussianKDE.time_gaussian_kde_evaluate_few_points": {"code": "class GaussianKDE:\n    def time_gaussian_kde_evaluate_few_points(self):\n        # test gaussian_kde evaluate on a small number of points\n        self.kernel(self.positions[:, :10])\n\n    def setup(self):\n        rng = np.random.default_rng(12345678)\n        n = 2000\n        m1 = rng.normal(size=n)\n        m2 = rng.normal(scale=0.5, size=n)\n    \n        xmin = m1.min()\n        xmax = m1.max()\n        ymin = m2.min()\n        ymax = m2.max()\n    \n        X, Y = np.mgrid[xmin:xmax:200j, ymin:ymax:200j]\n        self.positions = np.vstack([X.ravel(), Y.ravel()])\n        values = np.vstack([m1, m2])\n        self.kernel = stats.gaussian_kde(values)", "min_run_count": 2, "name": "stats.GaussianKDE.time_gaussian_kde_evaluate_few_points", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "308194c7334a4a538b11825b2d3c8af1c98d8781be384b66ba60cdf3a74172bd", "warmup_time": -1}, "stats.GaussianKDE.time_gaussian_kde_evaluate_many_points": {"code": "class GaussianKDE:\n    def time_gaussian_kde_evaluate_many_points(self):\n        # test gaussian_kde evaluate on many points\n        self.kernel(self.positions)\n\n    def setup(self):\n        rng = np.random.default_rng(12345678)\n        n = 2000\n        m1 = rng.normal(size=n)\n        m2 = rng.normal(scale=0.5, size=n)\n    \n        xmin = m1.min()\n        xmax = m1.max()\n        ymin = m2.min()\n        ymax = m2.max()\n    \n        X, Y = np.mgrid[xmin:xmax:200j, ymin:ymax:200j]\n        self.positions = np.vstack([X.ravel(), Y.ravel()])\n        values = np.vstack([m1, m2])\n        self.kernel = stats.gaussian_kde(values)", "min_run_count": 2, "name": "stats.GaussianKDE.time_gaussian_kde_evaluate_many_points", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3c2e299b62fd8e3ba479e90c5bd344e34fb8f7022216fc1d7b04abe974b8fccb", "warmup_time": -1}, "stats.GroupSampling.time_ortho_group": {"code": "class GroupSampling:\n    def time_ortho_group(self, dim):\n        stats.ortho_group.rvs(dim, random_state=self.rng)\n\n    def setup(self, dim):\n        self.rng = np.random.default_rng(12345678)", "min_run_count": 2, "name": "stats.GroupSampling.time_ortho_group", "number": 0, "param_names": ["dim"], "params": [["3", "10", "50", "200"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "990e7dccd766d90861f0219f1c0d310d1d3b59bb4b4e6799315da81ce9145221", "warmup_time": -1}, "stats.GroupSampling.time_special_ortho_group": {"code": "class GroupSampling:\n    def time_special_ortho_group(self, dim):\n        stats.special_ortho_group.rvs(dim, random_state=self.rng)\n\n    def setup(self, dim):\n        self.rng = np.random.default_rng(12345678)", "min_run_count": 2, "name": "stats.GroupSampling.time_special_ortho_group", "number": 0, "param_names": ["dim"], "params": [["3", "10", "50", "200"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f4e28da0afccf9a82fb77c3b935947e05c6e29cf0d7f17d5fea109f1a80dd724", "warmup_time": -1}, "stats.GroupSampling.time_unitary_group": {"code": "class GroupSampling:\n    def time_unitary_group(self, dim):\n        stats.unitary_group.rvs(dim, random_state=self.rng)\n\n    def setup(self, dim):\n        self.rng = np.random.default_rng(12345678)", "min_run_count": 2, "name": "stats.GroupSampling.time_unitary_group", "number": 0, "param_names": ["dim"], "params": [["3", "10", "50", "200"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "38be16fe30bc049ce08b7c656fd6269a98aa0a39e8b6bb5801aaf0dbd85f4be9", "warmup_time": -1}, "stats.InferentialStats.time_chisqure": {"code": "class InferentialStats:\n    def time_chisqure(self):\n        stats.chisquare(self.chisq)\n\n    def setup(self):\n        rng = np.random.default_rng(0x13d756fadb635ae7f5a8d39bbfb0c931)\n        self.a = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)\n        self.b = stats.norm.rvs(loc=8, scale=10, size=500, random_state=rng)\n        self.c = stats.norm.rvs(loc=8, scale=20, size=500, random_state=rng)\n        self.chisq = rng.integers(1, 20, 500)", "min_run_count": 2, "name": "stats.InferentialStats.time_chisqure", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2b82acd7edaab0853afc2954fc7d26b2fbece117e3c0d459f0990793bc564ce2", "warmup_time": -1}, "stats.InferentialStats.time_epps_singleton_2samp": {"code": "class InferentialStats:\n    def time_epps_singleton_2samp(self):\n        stats.epps_singleton_2samp(self.a, self.b)\n\n    def setup(self):\n        rng = np.random.default_rng(0x13d756fadb635ae7f5a8d39bbfb0c931)\n        self.a = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)\n        self.b = stats.norm.rvs(loc=8, scale=10, size=500, random_state=rng)\n        self.c = stats.norm.rvs(loc=8, scale=20, size=500, random_state=rng)\n        self.chisq = rng.integers(1, 20, 500)", "min_run_count": 2, "name": "stats.InferentialStats.time_epps_singleton_2samp", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6efcd731d2a8d010eb3877c1fe7bc88cc21daf3bcbc40a420f0d22431a054835", "warmup_time": -1}, "stats.InferentialStats.time_friedmanchisquare": {"code": "class InferentialStats:\n    def time_friedmanchisquare(self):\n        stats.friedmanchisquare(self.a, self.b, self.c)\n\n    def setup(self):\n        rng = np.random.default_rng(0x13d756fadb635ae7f5a8d39bbfb0c931)\n        self.a = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)\n        self.b = stats.norm.rvs(loc=8, scale=10, size=500, random_state=rng)\n        self.c = stats.norm.rvs(loc=8, scale=20, size=500, random_state=rng)\n        self.chisq = rng.integers(1, 20, 500)", "min_run_count": 2, "name": "stats.InferentialStats.time_friedmanchisquare", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "fc7f3729b32e0cd02654b3dd718da6ec3306a0497e2556e1b38ff638e7c22faa", "warmup_time": -1}, "stats.InferentialStats.time_kruskal": {"code": "class InferentialStats:\n    def time_kruskal(self):\n        stats.mstats.kruskal(self.a, self.b)\n\n    def setup(self):\n        rng = np.random.default_rng(0x13d756fadb635ae7f5a8d39bbfb0c931)\n        self.a = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)\n        self.b = stats.norm.rvs(loc=8, scale=10, size=500, random_state=rng)\n        self.c = stats.norm.rvs(loc=8, scale=20, size=500, random_state=rng)\n        self.chisq = rng.integers(1, 20, 500)", "min_run_count": 2, "name": "stats.InferentialStats.time_kruskal", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "21d84808240b33a9b0320914f0a36e4e0b4f53d6af35fc5eca48e8cb318d030b", "warmup_time": -1}, "stats.InferentialStats.time_ttest_ind_diff_var": {"code": "class InferentialStats:\n    def time_ttest_ind_diff_var(self):\n        # test different sized sample with different variances\n        stats.ttest_ind(self.a, self.c)\n        stats.ttest_ind(self.a, self.c, equal_var=False)\n\n    def setup(self):\n        rng = np.random.default_rng(0x13d756fadb635ae7f5a8d39bbfb0c931)\n        self.a = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)\n        self.b = stats.norm.rvs(loc=8, scale=10, size=500, random_state=rng)\n        self.c = stats.norm.rvs(loc=8, scale=20, size=500, random_state=rng)\n        self.chisq = rng.integers(1, 20, 500)", "min_run_count": 2, "name": "stats.InferentialStats.time_ttest_ind_diff_var", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3322080ce68756e5d25f8ef18e5851d11939b4539e1910e9abf5313eaf18863c", "warmup_time": -1}, "stats.InferentialStats.time_ttest_ind_same_var": {"code": "class InferentialStats:\n    def time_ttest_ind_same_var(self):\n        # test different sized sample with variances\n        stats.ttest_ind(self.a, self.b)\n        stats.ttest_ind(self.a, self.b, equal_var=False)\n\n    def setup(self):\n        rng = np.random.default_rng(0x13d756fadb635ae7f5a8d39bbfb0c931)\n        self.a = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)\n        self.b = stats.norm.rvs(loc=8, scale=10, size=500, random_state=rng)\n        self.c = stats.norm.rvs(loc=8, scale=20, size=500, random_state=rng)\n        self.chisq = rng.integers(1, 20, 500)", "min_run_count": 2, "name": "stats.InferentialStats.time_ttest_ind_same_var", "number": 0, "param_names": [], "params": [], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "17a6e5c93ebf6c137e9bd143291d501f5ca184e9958b0079c9ef7abdfff22cce", "warmup_time": -1}, "stats.KS.time_ks_1samp": {"code": "class KS:\n    def time_ks_1samp(self, alternative, mode):\n        stats.ks_1samp(self.a, stats.norm.cdf,\n                       alternative=alternative, mode=mode)\n\n    def setup(self, alternative, mode):\n        rng = np.random.default_rng(0x2e7c964ff9a5cd6be22014c09f1dbba9)\n        self.a = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)\n        self.b = stats.norm.rvs(loc=8, scale=10, size=500, random_state=rng)", "min_run_count": 2, "name": "stats.KS.time_ks_1samp", "number": 0, "param_names": ["alternative", "mode"], "params": [["'two-sided'", "'less'", "'greater'"], ["'auto'", "'exact'", "'asymp'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ab2e4513f1fdaa0262a96d85712ca3849f6769f443c6050bc486d9d4a577c5fb", "warmup_time": -1}, "stats.KS.time_ks_2samp": {"code": "class KS:\n    def time_ks_2samp(self, alternative, mode):\n        stats.ks_2samp(self.a, self.b, alternative=alternative, mode=mode)\n\n    def setup(self, alternative, mode):\n        rng = np.random.default_rng(0x2e7c964ff9a5cd6be22014c09f1dbba9)\n        self.a = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)\n        self.b = stats.norm.rvs(loc=8, scale=10, size=500, random_state=rng)", "min_run_count": 2, "name": "stats.KS.time_ks_2samp", "number": 0, "param_names": ["alternative", "mode"], "params": [["'two-sided'", "'less'", "'greater'"], ["'auto'", "'exact'", "'asymp'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "12e4059fbc7a35aba1e7f95480507b66164a804286beefa3fb3f9cd773985875", "warmup_time": -1}, "stats.Kendalltau.time_kendalltau": {"code": "class Kendalltau:\n    def time_kendalltau(self, nan_policy, method, variant):\n        stats.kendalltau(self.a, self.b, nan_policy=nan_policy,\n                         method=method, variant=variant)\n\n    def setup(self, nan_policy, method, variant):\n        rng = np.random.default_rng(12345678)\n        a = np.arange(200)\n        rng.shuffle(a)\n        b = np.arange(200)\n        rng.shuffle(b)\n        self.a = a\n        self.b = b", "min_run_count": 2, "name": "stats.Kendalltau.time_kendalltau", "number": 0, "param_names": ["nan_policy", "method", "variant"], "params": [["'propagate'", "'raise'", "'omit'"], ["'auto'", "'asymptotic'", "'exact'"], ["'b'", "'c'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e40c6966209a7519ed42c879b1c63cd2316c4b165c0d274919c8c83485eefdfd", "warmup_time": -1}, "stats.PDFPeakMemory.peakmem_bigarr_pdf": {"code": "class PDFPeakMemory:\n    def peakmem_bigarr_pdf(self, dist_name):\n        self.dist.pdf(self.x, *self.shape_args)\n\n    def setup(self, dist_name):\n        # This benchmark is demanding. Skip it if the env isn't xslow.\n        if not is_xslow():\n            raise NotImplementedError(\"skipped - enviroment is not xslow. \"\n                                      \"To enable this benchamark, set the \"\n                                      \"enviroment variable SCIPY_XSLOW=1\")\n    \n        if dist_name in self.slow_dists:\n            raise NotImplementedError(\"skipped - dist is too slow.\")\n    \n        self.dist = getattr(stats, dist_name)\n        self.shape_args = self.dist_data[dist_name]", "name": "stats.PDFPeakMemory.peakmem_bigarr_pdf", "param_names": ["dist_name"], "params": [["'alpha'", "'anglit'", "'arcsine'", "'argus'", "'beta'", "'betaprime'", "'bradford'", "'burr'", "'burr12'", "'cauchy'", "'chi'", "'chi2'", "'cosine'", "'crystalball'", "'dgamma'", "'dweibull'", "'erlang'", "'expon'", "'exponnorm'", "'exponpow'", "'exponweib'", "'f'", "'fatiguelife'", "'fisk'", "'foldcauchy'", "'foldnorm'", "'gamma'", "'gausshyper'", "'genexpon'", "'genextreme'", "'gengamma'", "'genhalflogistic'", "'genhyperbolic'", "'geninvgauss'", "'genlogistic'", "'gennorm'", "'halfgennorm'", "'genpareto'", "'gibrat'", "'gompertz'", "'gumbel_l'", "'gumbel_r'", "'halfcauchy'", "'halflogistic'", "'halfnorm'", "'hypsecant'", "'invgamma'", "'invgauss'", "'invweibull'", "'johnsonsb'", "'johnsonsu'", "'kappa4'", "'kappa3'", "'ksone'", "'kstwo'", "'kstwobign'", "'laplace'", "'laplace_asymmetric'", "'levy'", "'levy_l'", "'levy_stable'", "'loggamma'", "'logistic'", "'loglaplace'", "'lognorm'", "'loguniform'", "'lomax'", "'maxwell'", "'mielke'", "'moyal'", "'nakagami'", "'ncf'", "'nct'", "'ncx2'", "'norm'", "'norminvgauss'", "'pareto'", "'pearson3'", "'powerlaw'", "'powerlognorm'", "'powernorm'", "'rayleigh'", "'rdist'", "'recipinvgauss'", "'reciprocal'", "'rice'", "'semicircular'", "'skewcauchy'", "'skewnorm'", "'studentized_range'", "'t'", "'trapezoid'", "'triang'", "'truncexpon'", "'truncnorm'", "'truncweibull_min'", "'tukeylambda'", "'uniform'", "'vonmises'", "'vonmises_line'", "'wald'", "'weibull_max'", "'weibull_min'", "'wrapcauchy'"]], "timeout": 1800.0, "type": "peakmemory", "unit": "bytes", "version": "310522bb862723d3585ec54730a867fb9584d5b2ce85d8a65f385193ff517bcd"}, "stats.RankSums.time_ranksums": {"code": "class RankSums:\n    def time_ranksums(self, alternative):\n        stats.ranksums(self.u1, self.u2, alternative=alternative)\n\n    def setup(self, alternative):\n        rng = np.random.default_rng(0xb6acd7192d6e5da0f68b5d8ab8ce7af2)\n        self.u1 = rng.uniform(-1, 1, 200)\n        self.u2 = rng.uniform(-0.5, 1.5, 300)", "min_run_count": 2, "name": "stats.RankSums.time_ranksums", "number": 0, "param_names": ["alternative"], "params": [["'two-sided'", "'less'", "'greater'"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "54c65c868dd065a2078473ffbb4c9f9e8f2e794a1a9a4890a9434bfaded364a7", "warmup_time": -1}, "stats.Somersd.time_somersd": {"code": "class Somersd:\n    def time_somersd(self, n_size):\n        res = stats.somersd(self.x, self.y)\n\n    def setup(self, n_size):\n        rng = np.random.default_rng(12345678)\n        self.x = rng.choice(n_size, size=n_size)\n        self.y = rng.choice(n_size, size=n_size)", "min_run_count": 2, "name": "stats.Somersd.time_somersd", "number": 0, "param_names": ["n_size"], "params": [["10", "100"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "dfb33ea1548666287ee2f0edabc510bf8b4dfff0921b0815dab88622e98d081f", "warmup_time": -1}, "stats.TrackContinuousRoundtrip.track_distribution_isf_roundtrip": {"code": "class TrackContinuousRoundtrip:\n    def track_distribution_isf_roundtrip(self, dist_name):\n        # Tracks the worst relative error of a\n        # couple of round-trip isf -> sf calculations.\n        vals = [0.001, 0.5, 0.999]\n    \n        isf = self.dist.isf(vals, *self.shape_args)\n        round_trip = self.dist.sf(isf, *self.shape_args)\n    \n        err_rel = np.abs(vals - round_trip) / vals\n        return np.max(err_rel)\n\n    def setup(self, dist_name):\n        # Distribution setup follows `DistributionsAll` benchmark.\n        # This focuses on ppf, so the code for handling other functions is\n        # removed for simplicity.\n        self.dist = getattr(stats, dist_name)\n        self.shape_args = self.dist_data[dist_name]", "name": "stats.TrackContinuousRoundtrip.track_distribution_isf_roundtrip", "param_names": ["dist_name"], "params": [["'alpha'", "'anglit'", "'arcsine'", "'argus'", "'beta'", "'betaprime'", "'bradford'", "'burr'", "'burr12'", "'cauchy'", "'chi'", "'chi2'", "'cosine'", "'crystalball'", "'dgamma'", "'dweibull'", "'erlang'", "'expon'", "'exponnorm'", "'exponpow'", "'exponweib'", "'f'", "'fatiguelife'", "'fisk'", "'foldcauchy'", "'foldnorm'", "'gamma'", "'gausshyper'", "'genexpon'", "'genextreme'", "'gengamma'", "'genhalflogistic'", "'genhyperbolic'", "'geninvgauss'", "'genlogistic'", "'gennorm'", "'halfgennorm'", "'genpareto'", "'gibrat'", "'gompertz'", "'gumbel_l'", "'gumbel_r'", "'halfcauchy'", "'halflogistic'", "'halfnorm'", "'hypsecant'", "'invgamma'", "'invgauss'", "'invweibull'", "'johnsonsb'", "'johnsonsu'", "'kappa4'", "'kappa3'", "'ksone'", "'kstwo'", "'kstwobign'", "'laplace'", "'laplace_asymmetric'", "'levy'", "'levy_l'", "'levy_stable'", "'loggamma'", "'logistic'", "'loglaplace'", "'lognorm'", "'loguniform'", "'lomax'", "'maxwell'", "'mielke'", "'moyal'", "'nakagami'", "'ncf'", "'nct'", "'ncx2'", "'norm'", "'norminvgauss'", "'pareto'", "'pearson3'", "'powerlaw'", "'powerlognorm'", "'powernorm'", "'rayleigh'", "'rdist'", "'recipinvgauss'", "'reciprocal'", "'rice'", "'semicircular'", "'skewcauchy'", "'skewnorm'", "'studentized_range'", "'t'", "'trapezoid'", "'triang'", "'truncexpon'", "'truncnorm'", "'truncweibull_min'", "'tukeylambda'", "'uniform'", "'vonmises'", "'vonmises_line'", "'wald'", "'weibull_max'", "'weibull_min'", "'wrapcauchy'"]], "timeout": 60.0, "type": "track", "unit": "unit", "version": "3d08b3928aef3becb3751bbc25b3e0ca9833388b327013029b4a5eedbd0427cc"}, "stats.TrackContinuousRoundtrip.track_distribution_isf_roundtrip_extrema": {"code": "class TrackContinuousRoundtrip:\n    def track_distribution_isf_roundtrip_extrema(self, dist_name):\n        # Tracks the absolute error of an \"extreme\" round-trip\n        # isf -> sf calculation.\n        v = 1e-6\n        ppf = self.dist.isf(v, *self.shape_args)\n        round_trip = self.dist.sf(ppf, *self.shape_args)\n    \n        err_abs = np.abs(v - round_trip)\n        return err_abs\n\n    def setup(self, dist_name):\n        # Distribution setup follows `DistributionsAll` benchmark.\n        # This focuses on ppf, so the code for handling other functions is\n        # removed for simplicity.\n        self.dist = getattr(stats, dist_name)\n        self.shape_args = self.dist_data[dist_name]", "name": "stats.TrackContinuousRoundtrip.track_distribution_isf_roundtrip_extrema", "param_names": ["dist_name"], "params": [["'alpha'", "'anglit'", "'arcsine'", "'argus'", "'beta'", "'betaprime'", "'bradford'", "'burr'", "'burr12'", "'cauchy'", "'chi'", "'chi2'", "'cosine'", "'crystalball'", "'dgamma'", "'dweibull'", "'erlang'", "'expon'", "'exponnorm'", "'exponpow'", "'exponweib'", "'f'", "'fatiguelife'", "'fisk'", "'foldcauchy'", "'foldnorm'", "'gamma'", "'gausshyper'", "'genexpon'", "'genextreme'", "'gengamma'", "'genhalflogistic'", "'genhyperbolic'", "'geninvgauss'", "'genlogistic'", "'gennorm'", "'halfgennorm'", "'genpareto'", "'gibrat'", "'gompertz'", "'gumbel_l'", "'gumbel_r'", "'halfcauchy'", "'halflogistic'", "'halfnorm'", "'hypsecant'", "'invgamma'", "'invgauss'", "'invweibull'", "'johnsonsb'", "'johnsonsu'", "'kappa4'", "'kappa3'", "'ksone'", "'kstwo'", "'kstwobign'", "'laplace'", "'laplace_asymmetric'", "'levy'", "'levy_l'", "'levy_stable'", "'loggamma'", "'logistic'", "'loglaplace'", "'lognorm'", "'loguniform'", "'lomax'", "'maxwell'", "'mielke'", "'moyal'", "'nakagami'", "'ncf'", "'nct'", "'ncx2'", "'norm'", "'norminvgauss'", "'pareto'", "'pearson3'", "'powerlaw'", "'powerlognorm'", "'powernorm'", "'rayleigh'", "'rdist'", "'recipinvgauss'", "'reciprocal'", "'rice'", "'semicircular'", "'skewcauchy'", "'skewnorm'", "'studentized_range'", "'t'", "'trapezoid'", "'triang'", "'truncexpon'", "'truncnorm'", "'truncweibull_min'", "'tukeylambda'", "'uniform'", "'vonmises'", "'vonmises_line'", "'wald'", "'weibull_max'", "'weibull_min'", "'wrapcauchy'"]], "timeout": 60.0, "type": "track", "unit": "unit", "version": "ce7783cbc2492418427a90441cc92f3b888da6a2354898493b05c72277ff2d54"}, "stats.TrackContinuousRoundtrip.track_distribution_ppf_roundtrip": {"code": "class TrackContinuousRoundtrip:\n    def track_distribution_ppf_roundtrip(self, dist_name):\n        # Tracks the worst relative error of a\n        # couple of round-trip ppf -> cdf calculations.\n        vals = [0.001, 0.5, 0.999]\n    \n        ppf = self.dist.ppf(vals, *self.shape_args)\n        round_trip = self.dist.cdf(ppf, *self.shape_args)\n    \n        err_rel = np.abs(vals - round_trip) / vals\n        return np.max(err_rel)\n\n    def setup(self, dist_name):\n        # Distribution setup follows `DistributionsAll` benchmark.\n        # This focuses on ppf, so the code for handling other functions is\n        # removed for simplicity.\n        self.dist = getattr(stats, dist_name)\n        self.shape_args = self.dist_data[dist_name]", "name": "stats.TrackContinuousRoundtrip.track_distribution_ppf_roundtrip", "param_names": ["dist_name"], "params": [["'alpha'", "'anglit'", "'arcsine'", "'argus'", "'beta'", "'betaprime'", "'bradford'", "'burr'", "'burr12'", "'cauchy'", "'chi'", "'chi2'", "'cosine'", "'crystalball'", "'dgamma'", "'dweibull'", "'erlang'", "'expon'", "'exponnorm'", "'exponpow'", "'exponweib'", "'f'", "'fatiguelife'", "'fisk'", "'foldcauchy'", "'foldnorm'", "'gamma'", "'gausshyper'", "'genexpon'", "'genextreme'", "'gengamma'", "'genhalflogistic'", "'genhyperbolic'", "'geninvgauss'", "'genlogistic'", "'gennorm'", "'halfgennorm'", "'genpareto'", "'gibrat'", "'gompertz'", "'gumbel_l'", "'gumbel_r'", "'halfcauchy'", "'halflogistic'", "'halfnorm'", "'hypsecant'", "'invgamma'", "'invgauss'", "'invweibull'", "'johnsonsb'", "'johnsonsu'", "'kappa4'", "'kappa3'", "'ksone'", "'kstwo'", "'kstwobign'", "'laplace'", "'laplace_asymmetric'", "'levy'", "'levy_l'", "'levy_stable'", "'loggamma'", "'logistic'", "'loglaplace'", "'lognorm'", "'loguniform'", "'lomax'", "'maxwell'", "'mielke'", "'moyal'", "'nakagami'", "'ncf'", "'nct'", "'ncx2'", "'norm'", "'norminvgauss'", "'pareto'", "'pearson3'", "'powerlaw'", "'powerlognorm'", "'powernorm'", "'rayleigh'", "'rdist'", "'recipinvgauss'", "'reciprocal'", "'rice'", "'semicircular'", "'skewcauchy'", "'skewnorm'", "'studentized_range'", "'t'", "'trapezoid'", "'triang'", "'truncexpon'", "'truncnorm'", "'truncweibull_min'", "'tukeylambda'", "'uniform'", "'vonmises'", "'vonmises_line'", "'wald'", "'weibull_max'", "'weibull_min'", "'wrapcauchy'"]], "timeout": 60.0, "type": "track", "unit": "unit", "version": "bdcffa4e9f0936af05489a07e5367fd87a1a6e4c5fb53329a531e27a2ee22577"}, "stats.TrackContinuousRoundtrip.track_distribution_ppf_roundtrip_extrema": {"code": "class TrackContinuousRoundtrip:\n    def track_distribution_ppf_roundtrip_extrema(self, dist_name):\n        # Tracks the absolute error of an \"extreme\" round-trip\n        # ppf -> cdf calculation.\n        v = 1e-6\n        ppf = self.dist.ppf(v, *self.shape_args)\n        round_trip = self.dist.cdf(ppf, *self.shape_args)\n    \n        err_abs = np.abs(v - round_trip)\n        return err_abs\n\n    def setup(self, dist_name):\n        # Distribution setup follows `DistributionsAll` benchmark.\n        # This focuses on ppf, so the code for handling other functions is\n        # removed for simplicity.\n        self.dist = getattr(stats, dist_name)\n        self.shape_args = self.dist_data[dist_name]", "name": "stats.TrackContinuousRoundtrip.track_distribution_ppf_roundtrip_extrema", "param_names": ["dist_name"], "params": [["'alpha'", "'anglit'", "'arcsine'", "'argus'", "'beta'", "'betaprime'", "'bradford'", "'burr'", "'burr12'", "'cauchy'", "'chi'", "'chi2'", "'cosine'", "'crystalball'", "'dgamma'", "'dweibull'", "'erlang'", "'expon'", "'exponnorm'", "'exponpow'", "'exponweib'", "'f'", "'fatiguelife'", "'fisk'", "'foldcauchy'", "'foldnorm'", "'gamma'", "'gausshyper'", "'genexpon'", "'genextreme'", "'gengamma'", "'genhalflogistic'", "'genhyperbolic'", "'geninvgauss'", "'genlogistic'", "'gennorm'", "'halfgennorm'", "'genpareto'", "'gibrat'", "'gompertz'", "'gumbel_l'", "'gumbel_r'", "'halfcauchy'", "'halflogistic'", "'halfnorm'", "'hypsecant'", "'invgamma'", "'invgauss'", "'invweibull'", "'johnsonsb'", "'johnsonsu'", "'kappa4'", "'kappa3'", "'ksone'", "'kstwo'", "'kstwobign'", "'laplace'", "'laplace_asymmetric'", "'levy'", "'levy_l'", "'levy_stable'", "'loggamma'", "'logistic'", "'loglaplace'", "'lognorm'", "'loguniform'", "'lomax'", "'maxwell'", "'mielke'", "'moyal'", "'nakagami'", "'ncf'", "'nct'", "'ncx2'", "'norm'", "'norminvgauss'", "'pareto'", "'pearson3'", "'powerlaw'", "'powerlognorm'", "'powernorm'", "'rayleigh'", "'rdist'", "'recipinvgauss'", "'reciprocal'", "'rice'", "'semicircular'", "'skewcauchy'", "'skewnorm'", "'studentized_range'", "'t'", "'trapezoid'", "'triang'", "'truncexpon'", "'truncnorm'", "'truncweibull_min'", "'tukeylambda'", "'uniform'", "'vonmises'", "'vonmises_line'", "'wald'", "'weibull_max'", "'weibull_min'", "'wrapcauchy'"]], "timeout": 60.0, "type": "track", "unit": "unit", "version": "5d79bbd0e10609b3b006d8d49561e8cc7ba495f12ed7ed5f86c2f4793ca907b8"}, "stats_sampling.DiscreteAliasUrn.time_dau_rvs": {"code": "class DiscreteAliasUrn:\n    def time_dau_rvs(self, distribution):\n        self.rng.rvs(100000)\n\n    def setup(self, distribution):\n        distname, params = distribution\n        dist = getattr(stats, distname)\n        domain = dist.support(*params)\n        self.urng = np.random.default_rng(0x2fc9eb71cd5120352fa31b7a048aa867)\n        x = np.arange(domain[0], domain[1] + 1)\n        self.pv = dist.pmf(x, *params)\n        self.rng = sampling.DiscreteAliasUrn(self.pv, random_state=self.urng)", "min_run_count": 2, "name": "stats_sampling.DiscreteAliasUrn.time_dau_rvs", "number": 0, "param_names": ["distribution"], "params": [["['nhypergeom', (20, 7, 1)]", "['hypergeom', (30, 12, 6)]", "['nchypergeom_wallenius', (140, 80, 60, 0.5)]", "['binom', (5, 0.4)]"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6b88f34846069c9939ef15e29eb5201c5607871e4eeca7adecf002d011f52eae", "warmup_time": -1}, "stats_sampling.DiscreteAliasUrn.time_dau_setup": {"code": "class DiscreteAliasUrn:\n    def time_dau_setup(self, distribution):\n        sampling.DiscreteAliasUrn(self.pv, random_state=self.urng)\n\n    def setup(self, distribution):\n        distname, params = distribution\n        dist = getattr(stats, distname)\n        domain = dist.support(*params)\n        self.urng = np.random.default_rng(0x2fc9eb71cd5120352fa31b7a048aa867)\n        x = np.arange(domain[0], domain[1] + 1)\n        self.pv = dist.pmf(x, *params)\n        self.rng = sampling.DiscreteAliasUrn(self.pv, random_state=self.urng)", "min_run_count": 2, "name": "stats_sampling.DiscreteAliasUrn.time_dau_setup", "number": 0, "param_names": ["distribution"], "params": [["['nhypergeom', (20, 7, 1)]", "['hypergeom', (30, 12, 6)]", "['nchypergeom_wallenius', (140, 80, 60, 0.5)]", "['binom', (5, 0.4)]"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "bda0f2e0e6255266e59e6bc96a02be428321d96692599632d7624f13553d042a", "warmup_time": -1}, "stats_sampling.DiscreteGuideTable.time_dgt_rvs": {"code": "class DiscreteGuideTable:\n    def time_dgt_rvs(self, distribution):\n        self.rng.rvs(100000)\n\n    def setup(self, distribution):\n        distname, params = distribution\n        dist = getattr(stats, distname)\n        domain = dist.support(*params)\n        self.urng = np.random.default_rng(0x2fc9eb71cd5120352fa31b7a048aa867)\n        x = np.arange(domain[0], domain[1] + 1)\n        self.pv = dist.pmf(x, *params)\n        self.rng = sampling.DiscreteGuideTable(self.pv, random_state=self.urng)", "min_run_count": 2, "name": "stats_sampling.DiscreteGuideTable.time_dgt_rvs", "number": 0, "param_names": ["distribution"], "params": [["['nhypergeom', (20, 7, 1)]", "['hypergeom', (30, 12, 6)]", "['nchypergeom_wallenius', (140, 80, 60, 0.5)]", "['binom', (5, 0.4)]"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e03788c7b128ba2a175cabd5b86368ca897f689b938592bac71fc9624ca77f6e", "warmup_time": -1}, "stats_sampling.DiscreteGuideTable.time_dgt_setup": {"code": "class DiscreteGuideTable:\n    def time_dgt_setup(self, distribution):\n        sampling.DiscreteGuideTable(self.pv, random_state=self.urng)\n\n    def setup(self, distribution):\n        distname, params = distribution\n        dist = getattr(stats, distname)\n        domain = dist.support(*params)\n        self.urng = np.random.default_rng(0x2fc9eb71cd5120352fa31b7a048aa867)\n        x = np.arange(domain[0], domain[1] + 1)\n        self.pv = dist.pmf(x, *params)\n        self.rng = sampling.DiscreteGuideTable(self.pv, random_state=self.urng)", "min_run_count": 2, "name": "stats_sampling.DiscreteGuideTable.time_dgt_setup", "number": 0, "param_names": ["distribution"], "params": [["['nhypergeom', (20, 7, 1)]", "['hypergeom', (30, 12, 6)]", "['nchypergeom_wallenius', (140, 80, 60, 0.5)]", "['binom', (5, 0.4)]"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3be59357b3df606b44ad30c5541c3b96b674eea3dd862f35a3adc2efed76a174", "warmup_time": -1}, "stats_sampling.NumericalInverseHermite.time_hinv_rvs": {"code": "class NumericalInverseHermite:\n    def time_hinv_rvs(self, dist, order):\n        self.rng.rvs(100000)\n\n    def setup(self, dist, order):\n        self.urng = np.random.default_rng(0xb235b58c1f616c59c18d8568f77d44d1)\n        with np.testing.suppress_warnings() as sup:\n            sup.filter(RuntimeWarning)\n            try:\n                self.rng = sampling.NumericalInverseHermite(\n                    dist, order=order, random_state=self.urng\n                )\n            except sampling.UNURANError:\n                raise NotImplementedError(f\"setup failed for {dist}\")", "min_run_count": 2, "name": "stats_sampling.NumericalInverseHermite.time_hinv_rvs", "number": 0, "param_names": ["dist", "order"], "params": [["beta(2, 3)", "norm(0, 1)", "sqrtlinshft(0.0)", "sqrtlinshft(10000.0)", "sin2", "sin10"], ["3", "5"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "19863e9777cdcdcfd71246653f38a6e98d181fb7798b397db10e4bdb133dbef5", "warmup_time": -1}, "stats_sampling.NumericalInverseHermite.time_hinv_setup": {"code": "class NumericalInverseHermite:\n    def time_hinv_setup(self, dist, order):\n        with np.testing.suppress_warnings() as sup:\n            sup.filter(RuntimeWarning)\n            sampling.NumericalInverseHermite(\n                dist, order=order, random_state=self.urng\n            )\n\n    def setup(self, dist, order):\n        self.urng = np.random.default_rng(0xb235b58c1f616c59c18d8568f77d44d1)\n        with np.testing.suppress_warnings() as sup:\n            sup.filter(RuntimeWarning)\n            try:\n                self.rng = sampling.NumericalInverseHermite(\n                    dist, order=order, random_state=self.urng\n                )\n            except sampling.UNURANError:\n                raise NotImplementedError(f\"setup failed for {dist}\")", "min_run_count": 2, "name": "stats_sampling.NumericalInverseHermite.time_hinv_setup", "number": 0, "param_names": ["dist", "order"], "params": [["beta(2, 3)", "norm(0, 1)", "sqrtlinshft(0.0)", "sqrtlinshft(10000.0)", "sin2", "sin10"], ["3", "5"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b46b63615ca1af51e386dfc1a23464aaf2e2092bff3f8fbdf7c4e6470724089f", "warmup_time": -1}, "stats_sampling.NumericalInversePolynomial.time_pinv_rvs": {"code": "class NumericalInversePolynomial:\n    def time_pinv_rvs(self, dist):\n        self.rng.rvs(100000)\n\n    def setup(self, dist):\n        self.urng = np.random.default_rng(0xb235b58c1f616c59c18d8568f77d44d1)\n        with np.testing.suppress_warnings() as sup:\n            sup.filter(RuntimeWarning)\n            try:\n                self.rng = sampling.NumericalInversePolynomial(\n                    dist, random_state=self.urng\n                )\n            except sampling.UNURANError:\n                raise NotImplementedError(f\"setup failed for {dist}\")", "min_run_count": 2, "name": "stats_sampling.NumericalInversePolynomial.time_pinv_rvs", "number": 0, "param_names": ["dist"], "params": [["beta(2, 3)", "norm(0, 1)", "sqrtlinshft(0.0)", "sqrtlinshft(10000.0)", "sin2", "sin10"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9409c98ae118772734ceabc492303ed555b4c7342b4ec90d1634cc175af284af", "warmup_time": -1}, "stats_sampling.NumericalInversePolynomial.time_pinv_setup": {"code": "class NumericalInversePolynomial:\n    def time_pinv_setup(self, dist):\n        with np.testing.suppress_warnings() as sup:\n            sup.filter(RuntimeWarning)\n            sampling.NumericalInversePolynomial(\n                dist, random_state=self.urng\n            )\n\n    def setup(self, dist):\n        self.urng = np.random.default_rng(0xb235b58c1f616c59c18d8568f77d44d1)\n        with np.testing.suppress_warnings() as sup:\n            sup.filter(RuntimeWarning)\n            try:\n                self.rng = sampling.NumericalInversePolynomial(\n                    dist, random_state=self.urng\n                )\n            except sampling.UNURANError:\n                raise NotImplementedError(f\"setup failed for {dist}\")", "min_run_count": 2, "name": "stats_sampling.NumericalInversePolynomial.time_pinv_setup", "number": 0, "param_names": ["dist"], "params": [["beta(2, 3)", "norm(0, 1)", "sqrtlinshft(0.0)", "sqrtlinshft(10000.0)", "sin2", "sin10"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2f626ddf9731113d2c15a8107e8261759ba51e82a4a9cab95feb4d000575d3ab", "warmup_time": -1}, "stats_sampling.SimpleRatioUniforms.time_srou_rvs": {"code": "class SimpleRatioUniforms:\n    def time_srou_rvs(self, dist, cdf_at_mode):\n        self.rng.rvs(100000)\n\n    def setup(self, dist, cdf_at_mode):\n        self.urng = np.random.default_rng(0xfaad7df1c89e050200dbe258636b3265)\n        try:\n            if cdf_at_mode:\n                cdf_at_mode = dist.cdf(dist.mode)\n            else:\n                cdf_at_mode = None\n            self.rng = sampling.SimpleRatioUniforms(\n                dist, mode=dist.mode,\n                cdf_at_mode=cdf_at_mode,\n                random_state=self.urng\n            )\n        except sampling.UNURANError:\n            raise NotImplementedError(f\"{dist} not T-concave\")", "min_run_count": 2, "name": "stats_sampling.SimpleRatioUniforms.time_srou_rvs", "number": 0, "param_names": ["dist", "cdf_at_mode"], "params": [["beta(2, 3)", "norm(0, 1)", "sqrtlinshft(0.0)", "sqrtlinshft(10000.0)", "sin2", "sin10"], ["0", "1"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d0c99572fe2cccc755afca2eb664efead270cc60d099ce47e4a00154c4ee0182", "warmup_time": -1}, "stats_sampling.SimpleRatioUniforms.time_srou_setup": {"code": "class SimpleRatioUniforms:\n    def time_srou_setup(self, dist, cdf_at_mode):\n        if cdf_at_mode:\n            cdf_at_mode = dist.cdf(dist.mode)\n        else:\n            cdf_at_mode = None\n        sampling.SimpleRatioUniforms(\n            dist, mode=dist.mode,\n            cdf_at_mode=cdf_at_mode,\n            random_state=self.urng\n        )\n\n    def setup(self, dist, cdf_at_mode):\n        self.urng = np.random.default_rng(0xfaad7df1c89e050200dbe258636b3265)\n        try:\n            if cdf_at_mode:\n                cdf_at_mode = dist.cdf(dist.mode)\n            else:\n                cdf_at_mode = None\n            self.rng = sampling.SimpleRatioUniforms(\n                dist, mode=dist.mode,\n                cdf_at_mode=cdf_at_mode,\n                random_state=self.urng\n            )\n        except sampling.UNURANError:\n            raise NotImplementedError(f\"{dist} not T-concave\")", "min_run_count": 2, "name": "stats_sampling.SimpleRatioUniforms.time_srou_setup", "number": 0, "param_names": ["dist", "cdf_at_mode"], "params": [["beta(2, 3)", "norm(0, 1)", "sqrtlinshft(0.0)", "sqrtlinshft(10000.0)", "sin2", "sin10"], ["0", "1"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8054131086182a80820d80803108b2a2e7c75e6c05e40defad1226a5c3a89d01", "warmup_time": -1}, "stats_sampling.TransformedDensityRejection.time_tdr_rvs": {"code": "class TransformedDensityRejection:\n    def time_tdr_rvs(self, dist, c):\n        self.rng.rvs(100000)\n\n    def setup(self, dist, c):\n        self.urng = np.random.default_rng(0xfaad7df1c89e050200dbe258636b3265)\n        with np.testing.suppress_warnings() as sup:\n            sup.filter(RuntimeWarning)\n            try:\n                self.rng = sampling.TransformedDensityRejection(\n                    dist, c=c, random_state=self.urng\n                )\n            except sampling.UNURANError:\n                # contdist3 is not T-concave for c=0. So, skip such test-cases\n                raise NotImplementedError(f\"{dist} not T-concave for c={c}\")", "min_run_count": 2, "name": "stats_sampling.TransformedDensityRejection.time_tdr_rvs", "number": 0, "param_names": ["dist", "c"], "params": [["beta(2, 3)", "norm(0, 1)", "sqrtlinshft(0.0)", "sqrtlinshft(10000.0)", "sin2", "sin10"], ["0.0", "-0.5"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a332c89030a337f1703538e1b696b24df50fdb2df9d7f87463adf8cf2ccbc748", "warmup_time": -1}, "stats_sampling.TransformedDensityRejection.time_tdr_setup": {"code": "class TransformedDensityRejection:\n    def time_tdr_setup(self, dist, c):\n        with np.testing.suppress_warnings() as sup:\n            sup.filter(RuntimeWarning)\n            sampling.TransformedDensityRejection(\n                dist, c=c, random_state=self.urng\n            )\n\n    def setup(self, dist, c):\n        self.urng = np.random.default_rng(0xfaad7df1c89e050200dbe258636b3265)\n        with np.testing.suppress_warnings() as sup:\n            sup.filter(RuntimeWarning)\n            try:\n                self.rng = sampling.TransformedDensityRejection(\n                    dist, c=c, random_state=self.urng\n                )\n            except sampling.UNURANError:\n                # contdist3 is not T-concave for c=0. So, skip such test-cases\n                raise NotImplementedError(f\"{dist} not T-concave for c={c}\")", "min_run_count": 2, "name": "stats_sampling.TransformedDensityRejection.time_tdr_setup", "number": 0, "param_names": ["dist", "c"], "params": [["beta(2, 3)", "norm(0, 1)", "sqrtlinshft(0.0)", "sqrtlinshft(10000.0)", "sin2", "sin10"], ["0.0", "-0.5"]], "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "42f37a6626008856bf5460fe9e6eaaac803a080624a60f7406cb0a58df06187f", "warmup_time": -1}}, "machines": {"i7": {"arch": "x86_64", "cpu": "Intel(R) Core(TM) i7 CPU 920 @ 2.67GHz", "machine": "i7", "num_cpu": "8", "os": "Linux", "ram": "16416652", "version": 1}, "atom": {"arch": "x86_64", "cpu": "Intel(R) Atom(TM) CPU N2800   @ 1.86GHz", "machine": "atom", "os": "Linux 3.16.0-4-amd64", "ram": "4041288", "version": 1}}, "tags": {"v0.1.0": 163, "v0.1.1": 165, "v0.1.2": 165, "v0.10.0": 7046, "v0.10.0b1": 6894, "v0.10.0b2": 6915, "v0.10.0rc1": 7024, "v0.10.1": 7336, "v0.10.1rc1": 7247, "v0.10.1rc2": 7306, "v0.11.0": 8015, "v0.11.0b1": 7742, "v0.11.0rc1": 7806, "v0.11.0rc2": 7863, "v0.12.0": 9003, "v0.12.0b1": 8684, "v0.12.0rc1": 8939, "v0.12.1": 10483, "v0.13.0": 10569, "v0.13.0b1": 10009, "v0.13.0rc1": 10492, "v0.13.1": 10704, "v0.13.2": 10845, "v0.13.3": 11142, "v0.14.0": 11791, "v0.14.0b1": 11580, "v0.14.0rc1": 11679, "v0.14.0rc2": 11741, "v0.14.1": 12991, "v0.14.1rc1": 12841, "v0.15.0": 13101, "v0.15.0b1": 12717, "v0.15.0rc1": 12859, "v0.15.1": 13179, "v0.16.0": 14253, "v0.16.0b1": 13996, "v0.16.0b2": 14034, "v0.16.0rc1": 14186, "v0.16.1": 14947, "v0.17.0": 15505, "v0.17.0rc1": 15298, "v0.17.0rc2": 15406, "v0.17.1": 16259, "v0.17pre": 15200, "v0.18.0": 16651, "v0.18.0-1": 16651, "v0.18.0rc1": 16524, "v0.18.0rc2": 16596, "v0.18.1": 16931, "v0.19.0": 17861, "v0.19.0rc1": 17746, "v0.19.0rc2": 17815, "v0.19.1": 18296, "v0.2.0": 814, "v0.2.2": 962, "v0.3.0": 998, "v0.3.2": 1117, "v0.4.2": 1407, "v0.4.3": 1439, "v0.4.4": 1521, "v0.4.6": 1581, "v0.4.8": 1699, "v0.4.9": 1840, "v0.5.0": 2062, "v0.5.1": 2114, "v0.5.2": 2287, "v0.5.2.1": 3158, "v0.6.0": 3258, "v0.7.0": 5103, "v0.7.0b1": 4726, "v0.7.0rc1": 5014, "v0.7.0rc2": 5053, "v0.7.1": 5433, "v0.7.1rc1": 5331, "v0.7.1rc2": 5348, "v0.7.1rc3": 5360, "v0.7.2": 5747, "v0.7.2rc1": 5728, "v0.7.2rc2": 5742, "v0.7.2rc3": 5746, "v0.8.0": 6041, "v0.8.0b1": 5892, "v0.8.0rc1": 5996, "v0.8.0rc2": 6001, "v0.8.0rc3": 6015, "v0.9.0": 6567, "v0.9.0b1": 6406, "v0.9.0rc1": 6478, "v0.9.0rc2": 6502, "v0.9.0rc3": 6533, "v0.9.0rc4": 6547, "v0.9.0rc5": 6553, "v1.0.0": 19376, "v1.0.0b1": 19142, "v1.0.0rc1": 19208, "v1.0.0rc2": 19344, "v1.0.1": 19853, "v1.1.0": 20145, "v1.1.0rc1": 20098, "v1.2.0": 21213, "v1.2.0rc1": 21142, "v1.2.0rc2": 21178, "v1.2.1": 21433, "v1.2.2": 22210, "v1.2.3": 23910, "v1.3.0": 22134, "v1.3.0rc1": 22050, "v1.3.0rc2": 22103, "v1.3.1": 22668, "v1.3.2": 23355, "v1.3.3": 23519, "v1.4.0": 23650, "v1.4.0rc1": 23513, "v1.4.0rc2": 23619, "v1.4.1": 23670, "v1.5.0": 25139, "v1.5.0rc1": 25030, "v1.5.0rc2": 25113, "v1.5.1": 25208, "v1.5.2": 25399, "v1.5.3": 25687, "v1.5.4": 25781, "v1.6.0": 26218, "v1.6.0rc1": 26054, "v1.6.0rc2": 26168, "v1.6.1": 26541, "v1.6.2": 26753, "v1.6.3": 27053, "v1.7.0": 27493, "v1.7.0rc1": 27383, "v1.7.0rc2": 27459, "v1.7.1": 27730, "v1.7.2": 28192, "v1.7.3": 28344, "v1.8.0": 28935, "v1.8.0rc1": 28478, "v1.8.0rc2": 28529, "v1.8.0rc3": 28783, "v1.8.0rc4": 28890, "v1.8.1": 29543}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}